%
% File specification.tex
%

\documentclass[11pt,a4paper]{article}

\usepackage[hscale=0.75,vscale=0.8]{geometry}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{fontspec}
\usepackage{latexsym}
\usepackage{url}
\usepackage{natbib}
\usepackage{multicol}
\usepackage{xstring}
\usepackage{xspace}
\usepackage{todonotes}
\usepackage[toc,page]{appendix}
\usepackage{comment} % for commenting out the huge draft lists
%\usepackage{inconsolata} % to have Consolas as font for verbatim and tt
\usepackage{bera}% optional: just to have a nice mono-spaced font
\usepackage{listings}
\usepackage{enumitem}
\usepackage{cprotect}
\usepackage{fancyvrb}
\usepackage{xcolor}
\usepackage{forest}
\usepackage[rounded]{syntax}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{ntheorem}
\usepackage[capitalise]{cleveref} % must be loaded after hyperref!

\usepackage{acro}

\DeclareAcronym{cql}{short = CQL, long = corpus query language}
\DeclareAcronym{cqs}{short = CQS, long = corpus query system}
\DeclareAcronym{rdbms}{short = RDBMS, long = relational database management system}
\DeclareAcronym{rdb}{short = RDB, long = relational database}
\DeclareAcronym{iql}{short = IQL, long = ICARUS2 Query Language}
\DeclareAcronym{icmf}{short = ICMF, long = ICARUS2 Corpus Modeling Framework}
\DeclareAcronym{iqp}{short = IQP, long = ICARUS2 Query Processor}
\DeclareAcronym{kwic}{short = KWIC, long = keyword-in-context}
\DeclareAcronym{uoi}{short = UoI, long = unit-of-interest, long-plural-form = units-of-interest}

\newfontfamily\DejaSans{DejaVu Sans}

\setmonofont{Consolas}

\lstset{
	basicstyle=\ttfamily,
}

\definecolor{eclipseStrings}{RGB}{42,0.0,255}
\definecolor{eclipseKeywords}{RGB}{127,0,85}
\colorlet{numb}{magenta!60!black}

\definecolor{gray}{rgb}{220, 220, 220}
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{darkred}{rgb}{0.8, 0.0, 0.0}

\theoremstyle{break}
\newtheorem{gram}{Grammar Snippet}

\crefname{gram}{snippet}{snippets}

\newcommand{\compresslist}{ % Define a command to reduce spacing within itemize/enumerate environments, this is used right after \begin{itemize} or \begin{enumerate}
	\setlength{\topsep}{0pt}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
}

\newcommand{\icarus}{ICARUS2\xspace}
\newcommand{\iql}{IQL\xspace}

\newcommand{\keyword}[1]{\textcolor{purple}{\texttt{#1}}}

\newcommand{\member}[1]{\texttt{#1}}

\newcommand{\query}[1]{\texttt{#1}}
\newcommand{\switch}[1]{``\texttt{#1}''}


% constants
\newcommand{\iqlns}{iql:}
\newcommand{\repoUrl}{https://github.com/ICARUS-tooling/icarus2-modeling-framework/blob/dev/}
\newcommand{\manifestsUrl}{\repoUrl icarus2-manifest-api/src/main/java/de/ims/icarus2/model/manifest/api/}
\newcommand{\modelsUrl}{\repoUrl icarus2-model-api/src/main/java/de/ims/icarus2/model/api/}

\newcommand{\repoLink}[2]{\href{#1}{#2}}

\newcommand{\iqlType}[1]{\texttt{\iqlns#1}}
\newcommand{\iqlBaseType}[1]{\texttt{\textless#1\textgreater}}

\newcommand{\desc}[1]{\noindent#1\newline\medskip}
\newcommand{\extends}[2]{\noindent\textbf{Extends #1(#2).}\newline\medskip}

% Environment to wrap JSON attributes of IQL elements into tables
\newenvironment{attributes}[1]{
\noindent\textbf{Attributes of #1:}\newline\medskip
\begin{tabular}{|p{0.3\textwidth}|p{0.20\textwidth}|p{0.20\textwidth}|p{0.17\textwidth}|}
	\hline
	\textbf{Attribute} & \textbf{Type} & \textbf{Required} & \textbf{Default} \\ 
	\hline
	\hline
}{
\end{tabular}
}
% shorthand methods for filling attributes table: name, type, required, default
\newcommand{\attribute}[4]{
	#1 & #2 & #3 & #4 \\
	\hline
}

% Environment to wrap nested JSON elements of IQL elements into tables
\newenvironment{elements}[1]{
\noindent\textbf{Nested Elements of #1:}\newline\medskip
\begin{tabular}{|p{0.3\textwidth}|p{0.42\textwidth}|p{0.17\textwidth}|}
	\hline
	\textbf{Element} & \textbf{Type} & \textbf{Required} \\ 
	\hline
	\hline
}{
\end{tabular}
}
% shorthand methods for filling elements table: name, type, required
\newcommand{\element}[3]{
#1 & #2 & #3 \\
\hline
}

% make a noticable skip and set a horizontal separator
\newcommand{\diagsep}{\bigskip\hrule}

\newcommand{\rrhead}[1]{\medskip\noindent\synt{#1}:\newline\medskip}

% wrap syntax diagram with a title label (uses syntdiag)
\newenvironment{rrdiag}[1]{
	\rrhead{#1}
	\hspace{-\medskipamount}
	\begin{syntdiag}
	}{
	\end{syntdiag}
}

% wrap syntax diagram with a title label (uses syntdiag*)
\newenvironment{rrdiag*}[1]{
	\rrhead{#1}
	\begin{syntdiag*}
	}{
	\end{syntdiag*}
}

% allows to split a railroad diagram manually
\newenvironment{rrfrag}[2]{
	\begin{syntdiag*}[\left{#1}\right{#2}]
	}{
	\end{syntdiag*}
}

\newcommand{\sst}{\begin{stack}}
\newcommand{\est}{\end{stack}}
\newcommand{\srp}{\begin{rep}}
\newcommand{\erp}{\end{rep}}

%\newcommand*\BitAnd{\mathbin{\&}}
%\newcommand*\BitOr{\mathbin{|}}
%\newcommand*\ShiftLeft{\ll}
%\newcommand*\ShiftRight{\gg}
%\newcommand*\BitNeg{\ensuremath{\mathord{\sim}}}

%\counterwithin{paragraph}{subsubsection}

\lstdefinelanguage{json}{
	basicstyle=\normalfont\ttfamily,
	commentstyle=\color{eclipseStrings}, % style of comment
	stringstyle=\color{eclipseKeywords}, % style of strings
	numbers=left,
	numberstyle=\scriptsize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
%	backgroundcolor=\color{gray}, %only if you like
	string=[s]{"}{"},
	comment=[l]{:\ "},
	morecomment=[l]{:"},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
}

\title{ICARUS2 Query Language Specification}

\author{Markus GÃ¤rtner}

\date{2020}

\begin{document}

\maketitle

\tableofcontents

\section{Query Structure}
\label{sec:query-structure}

Queries in \iql are designed to be self-contained with logical sections for specifying all the information required to determine the target of a query and its granularity, resolve additional dependencies such as extensions or scripts, link and validate constraints to parts of the target corpus or corpora and finally optional pre- and post-processing steps.
To achieve this complex task \iql embeds a keyword-based syntax for the query payload within a JSON-LD structure to drive declaration of all the aforementioned information. 
As a side effect queries can become quite verbose and potentially cumbersome to define manually. 
As a countermeasure the overall structure of a query is composed of blocks that can be glued together incrementally and that make it very easy for an application built on top of it to provision boilerplate query code based on settings or a GUI so that the user only needs to type the actual constraints used in the query (the so called \textit{query payload}). 
This document lists the basic building blocks of queries and their compositions.

\begin{lstlisting}[language=json]
{
  "@context" : "http://www.ims.uni-stuttgart.de/icarus/jsonld/iql/query" 
}
\end{lstlisting}


\section{JSON-LD Elements}
\label{sec:elements}

\todo{say something about the namespace and general iql: prefixing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     BINDING
\subsection{Binding}
\label{sec:json-ld-binding}
%\begin{itemize}
%	\item distinct
%	\item target
%	\item edges
%	\item members
%\end{itemize}
\desc{A binding associates a collection of member variables (\ref{sec:variables-references}) with the content of a specific \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} or derived layer type.}
\begin{attributes}{\iqlType{Binding}}
	\attribute{distinct}{Boolean}{no}{false}
	\attribute{edges}{Boolean}{no}{false}
	\attribute{target}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{distinct}] Enforces that the bound member references in this binding do \textbf{not} match the same target items during evaluation. Depending on the structural constraints used in the query, this setting might be redundant (e.g. when using the member references as identifiers for tree nodes who already are structurally distinct), but can still be used to make that fact explicit. 
	\item[\iqlType{edges}] Signals that the member labels are to be used for \repoLink{\modelsUrl members/item/Edge.java}{edges} within a \repoLink{\modelsUrl members/structure/Structure.java}{structure}.
	\item[\iqlType{target}] The name or alias of the layer to whose content the member variables should be bound.
\end{description}
\begin{elements}{\iqlType{Binding}}
	\element{members}{array of \iqlType{Reference} (\ref{sec:json-ld-reference})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{members}] Non-empty collection of member references that are bound to the target layer's content. Every such instance of \iqlType{Reference} (\ref{sec:json-ld-reference}) must be unique within the surrounding \iqlType{Payload} (\ref{sec:json-ld-payload}).
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     CONSTRAINT
\subsection{Constraint}
\label{sec:json-ld-constraint}
%\begin{itemize}
%	\item id
%	\item solved
%	\item solvedAs
%\end{itemize}
\desc{Constraints represent the actual content filtering of every query.}
\begin{attributes}{\iqlBaseType{Constraint}}
	\attribute{id}{string}{yes}{}
	\attribute{solved}{Boolean}{no}{false}
	\attribute{solvedAs}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the constraint within the entire query.
	\item[\iqlType{solved}] Hint for the evaluation engine that this constraint has already been solved, either by a back-end implementation or as a result of (partial) query evaluation by the engine itself.
	\item[\iqlType{solvedAs}] Specifies to what Boolean value (\keyword{true} or \keyword{false}) the constraint has been evaluated.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PREDICATE
\subsubsection{Predicate}
\label{sec:json-ld-predicate}
%\begin{itemize}
%	\item expression
%\end{itemize}
\desc{Wraps a Boolean \iqlType{Expression} into an atomic constraint element that represents the smallest unit of evaluation for the top-level evaluation engine.}
\extends{\iqlBaseType{Constraint}}{\ref{sec:json-ld-constraint}}
\begin{elements}{\iqlType{Predicate}}
	\element{expression}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{expression}] The actual expression to be evaluated to a Boolean result. Note that typically this expression \textbf{cannot} be composed of directly nested Boolean conjunctions or disjunctions, as the engine will have parsed those into \iqlType{Term} (\ref{sec:json-ld-term}) objects already during the first processing phase.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     TERM
\subsubsection{Term}
\label{sec:json-ld-term}
%\begin{itemize}
%	\item items
%	\item operation
%\end{itemize}
\desc{A collection of constraints with a logical connective.}
\extends{\iqlBaseType{Constraint}}{\ref{sec:json-ld-constraint}}
\begin{attributes}{\iqlType{Term}}
	\attribute{operation}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{operation}] The Boolean connective to be applied to all the constraint items. Legal values are the strings ``conjunction'' or ``disjunction''.
\end{description}
\begin{elements}{\iqlType{Term}}
\element{items}{array of \iqlType{Constraint} (\ref{sec:json-ld-constraint})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{items}] The constraints which are to be combined by the specified \iqlType{operation}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Corpus}
\label{sec:json-ld-corpus}
%\begin{itemize}
%\item id
%\item name
%\end{itemize}
\desc{Top-level entry point for querying a single stream.}
\begin{attributes}{\iqlType{Corpus}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the corpus within the entire query.
	\item[\iqlType{name}] The identifier used by the query engine's \repoLink{\manifestsUrl ManifestRegistry.java}{manifest registry} for the corpus.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     DATA
\subsection{Data}
\label{sec:json-ld-data}
%\begin{itemize}
%\item id
%\item name
%\item content
%\item codec
%\item checksum
%\item checksumType
%\end{itemize}
\desc{Allows to embed binary data in the query and make it usable from within constraint expressions via a designated reference.}
\begin{attributes}{\iqlType{Data}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{content}{string}{yes}{}
	\attribute{codec}{string}{no}{hex}
	\attribute{checksum}{string}{no}{}
	\attribute{checksumType}{enum}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the corpus within the entire query.
	\item[\iqlType{name}] The identifier used for the expression (\ref{sec:expressions}) which can be used to reference the binary payload from within query constraints.
	\item[\iqlType{content}] The actual content of the payload in textual form. How to properly convert the textual form to a binary stream is defined by the \iqlType{codec} attribute.
	\item[\iqlType{codec}] Specifies the mechanism of converting the \iqlType{content} data into an actual binary stream. If left empty, defaults to \texttt{hex}.
	\item[\iqlType{checksum}] Optional hex-string of the checksum to check the \iqlType{content} against.
	\item[\iqlType{checksumType}] Defines the algorithm for computing the checksum. Currently only \texttt{MD5} is supported as legal value.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     ELEMENT
\subsection{Element}
\label{sec:json-ld-element}
%\begin{itemize}
%\item id
%\item consumed
%\end{itemize}
\desc{Abstract base type for all logical and/or structural units that can be matched against content of a target corpus.}
\begin{attributes}{\iqlBaseType{Element}}
	\attribute{id}{string}{yes}{}
	\attribute{consumed}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the element within the entire query.
	\item[\iqlType{consumed}] Signals that the element has already been \textit{used up} in the context of a partial query evaluation. An element that has been consumed can safely be ignored in the further evaluation of the query. Note that this state can be propagated according to the following rules:
	\begin{itemize}[leftmargin=*,topsep=0pt]\compresslist
		\item A \iqlType{Node}(\ref{sec:json-ld-node}) can be marked as \texttt{consumed} if its \iqlType{constraint} is marked as \texttt{solved} and its match count satisfies the \iqlType{quantifiers} requirement. Note that cross-referencing constraints can only be considered solved when all other aspects of the involved elements support the \texttt{consumed} state.
		\item A \iqlType{TreeNode}(\ref{sec:json-ld-tree-node}) can be marked as \texttt{consumed} if above conditions are met and all nested \iqlType{children} are marked \texttt{consumed}.
		\item An \iqlType{Edge}(\ref{sec:json-ld-edge}) is considered \texttt{consumed} when both its terminals are \texttt{consumed} and the same conditions regarding its \iqlType{constraint} are fulfilled as mentioned above.
		\item A \iqlType{ElementDisjunction}(\ref{sec:json-ld-element-disjunction}) is considered \texttt{consumed} if at least one of its \iqlType{alternatives} has been marked \texttt{consumed}.
	\end{itemize}
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     NODE SET
\subsubsection{Node Set}
\label{sec:json-ld-node-set}
%\begin{itemize}
%\item nodes
%\item nodeArrangement
%\end{itemize}
\desc{Wrapper around a list of \iqlType{Element} (\ref{sec:json-ld-element}) instances to group them for either nesting or disjunction.}
\extends{\iqlType{Node}}{\ref{sec:json-ld-node}}
\begin{attributes}{\iqlType{NodeSet}}
	\attribute{nodeArrangement}{enum}{no}{unspecified}
\end{attributes}
\begin{description}
	\item[\iqlType{nodeArrangement}] Defines what kind of order or arrangement should be assumed between the elements in this set. Legal values are \texttt{unspecified}, \texttt{ordered} (matched elements must occur in exactly the order specified in this set but need not form a continuous span) or \texttt{adjacent} (matched elements must form a continuous span).
\end{description}
\begin{elements}{\iqlType{NodeSet}}
	\element{nodes}{array of \iqlBaseType{Element} (\ref{sec:json-ld-element})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{nodes}] List of nested \iqlBaseType{Element} instances. Legal types depend on the context in which this set is being used.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     NODE
\subsubsection{Node}
\label{sec:json-ld-node}
%\begin{itemize}
%\item label
%\item constraint
%\item quantifiers
%\end{itemize}
\desc{Logical unit for sequence or graph matching in a target corpus. May contain local constraints and can also be quantified.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{attributes}{\iqlType{Node}}
	\attribute{label}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{label}] Identifier to bind the node through a previously defined \iqlType{Binding} (\ref{sec:json-ld-binding}) declaration.
\end{description}
\begin{elements}{\iqlType{Node}}
	\element{constraint}{\iqlBaseType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{quantifiers}{array of \iqlType{Quantifier} (\ref{sec:json-ld-quantifier})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{constraint}] Optional local constraint to be matched against the content of potential target candidates during query evaluation.
	\item[\iqlType{quantifiers}] Optional quantifiers to define the multiplicity of matches of this node required for a positive evaluation. Multiple quantifiers behave disjunctively. Note that \iql defines some restrictions on the legal combinations of quantifiers: The all-quantifier (\texttt{*} or \texttt{all}) and not-quantifier (\texttt{!} or \texttt{not}) can only be used in isolation, all other quantifiers can be combined in disjunctive fashion.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     TREE NODE
\subsubsection{Tree Node}
\label{sec:json-ld-tree-node}
%\begin{itemize}
%\item children
%\end{itemize}
\desc{Extension of the simple \iqlType{Node} type (\ref{sec:json-ld-node}) to add implicit hierarchical constraints related to dominance within tree structures.}
\extends{\iqlType{Node}}{\ref{sec:json-ld-node}}
\begin{elements}{\iqlType{TreeNode}}
	\element{children}{instance of \iqlBaseType{Element} (\ref{sec:json-ld-element})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{children}] Optional nested nodes or node alternatives.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     EDGE
\subsubsection{Edge}
\label{sec:json-ld-edge}
%\begin{itemize}
%\item label
%\item constraint
%\item source
%\item target
%\item edgeType
%\end{itemize}
\desc{Specialized element extension to query structural information in graphs.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{attributes}{\iqlType{Edge}}
	\attribute{label}{string}{no}{}
	\attribute{edgeType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{label}] Identifier to bind the edge through a previously defined \iqlType{Binding} (\ref{sec:json-ld-binding}) declaration.
	\item[\iqlType{edgeType}] The type specification for this edge, primarily a directionality information. Legal values are \texttt{simple}, \texttt{one-way} or \texttt{two-way}.
\end{description}
\begin{elements}{\iqlType{Edge}}
	\element{constraint}{\iqlBaseType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{source}{\iqlType{Node} (\ref{sec:json-ld-node})}{yes}
	\element{target}{\iqlType{Node} (\ref{sec:json-ld-node})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{constraint}] Optional local constraint to be matched against the content of potential target candidates during query evaluation.
	\item[\iqlType{source}] Source node declaration. 
	\item[\iqlType{target}] Target node declaration. 
\end{description}
For complex graph declarations multiple nodes can be defined having the same \iqlType{label}. The evaluation engine will treat them as being the same node. Note however, that at most \textbf{one} node per label is allowed to declare a local \iqlType{constraint} attribute!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     ELEMENT DISJUNCTION
\subsubsection{Element Disjunction}
\label{sec:json-ld-element-disjunction}
%\begin{itemize}
%	\item alternatives
%\end{itemize}
\desc{Allows declaration of multiple alternative element definitions. When evaluating the query, each such alternative that is matched successfully will cause this element declaration to evaluate positively.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{elements}{\iqlType{ElementDisjunction}}
	\element{alternatives}{array of \iqlType{Element} (\ref{sec:json-ld-element})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{alternatives}] The alternative element declarations, each of which constitutes a legal match for this element declaration. Must not contain less than 2 elements!
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     EXPRESSION
\subsection{Expression}
\label{sec:json-ld-expression}
%\begin{itemize}
%\item content
%\item resultType
%\end{itemize}
\desc{Wraps the textual form of an arbitrarily complex \iql expression, which can be a formula, literal, method invocation, a combination of those or a great many other types of expressions. For more details see \cref{sec:expressions}.}
\begin{attributes}{\iqlType{Expression}}
	\attribute{content}{string}{yes}{}
	\attribute{resultType}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{content}] The textual form of the expression. Must be valid according to the specifications in \cref{sec:expressions}.
	\item[\iqlType{resultType}] An optional specification regarding the return type of the expression. Redundant when the expression is used as a constraint, as those are required to always evaluate to a Boolean result value anyway.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     GROUP
\subsection{Group}
\label{sec:json-ld-group}
%\begin{itemize}
%\item id
%\item groupBy
%\item filterOn
%\item label
%\item defaultValue
%\end{itemize}
\desc{Provides a mechanism to collect successful matches into dedicated groups, either for result visualization or use in further result processing.}
\begin{attributes}{\iqlType{Group}}
	\attribute{id}{string}{yes}{}
	\attribute{label}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the group declaration within the entire query.
	\item[\iqlType{label}] Label (ideally human readable) to be used for referencing this group in subsequent result processing or for generating textual result reports.
\end{description}
\begin{elements}{\iqlType{Group}}
	\element{groupBy}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
	\element{filterOn}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{no}
	\element{defaultValue}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{groupBy}] The mandatory expression used to extract the value from matches based on which the actual grouping occurs.
	\item[\iqlType{filterOn}] Optional mechanism to exclude certain matches from being used for grouping.
	\item[\iqlType{defaultValue}] If matches cannot produce a valid value for grouping but should still be included in the process, this optional field provides the means of declaring a kind of ``fall back'' group. Be aware of potential overlap in groups when using default values that are not distinct from the regular grouping results.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     IMPORT
\subsection{Import}
\label{sec:json-ld-import}
%\begin{itemize}
%\item id
%\item name
%\item optional
%\end{itemize}
\desc{To allow for flexible integration of macro definitions or bigger language extensions, \iql provides an optional section in the query that lets users specify exactly what additional modules besides the bare \iql core are required for evaluating the query. Each import target is specified by providing it's unique name and telling the engine whether or not the import is to be considered optional.}
\begin{attributes}{\iqlType{Import}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{optional}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the import within the entire query.
	\item[\iqlType{name}] The original name of the extension to be added.
	\item[\iqlType{optional}] Defines whether or not the referenced extension is optional. 	Non-optional imports that cannot be resolved to an actual extension during the query evaluation phase will cause the entire process to fail.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     LANE
\subsection{Lane}
\label{sec:json-ld-lane}
%\begin{itemize}
%\item id
%\item name
%\item alias %stores the member name used to reference the entire structure/sentence
%\item laneType
%\item elements
%\end{itemize}
\desc{Lanes serve as a means of splitting queries for a single corpus stream into multiple logical subqueries that target different structural and/or logical layers, e.g. multiple syntactic analyses for the same source text.}
\begin{attributes}{\iqlType{Lane}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{alias}{string}{no}{}
	\attribute{laneType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the lane within the entire query.
	\item[\iqlType{name}] The unique identifier of the \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} or \repoLink{\modelsUrl layer/StructureLayer.java}{structure layer} that serves as target for this lane.
	\item[\iqlType{alias}] If items of this lane in their entirety are meant to be used as part of query expressions inside this field holds the label used for the respective member variable. It is recommended to keep the chosen \texttt{alias} close to the original \texttt{name} to avoid confusion.
	\item[\iqlType{laneType}] The type of structure this lane is meant to match, effectively defining the basic complexity class for evaluation. legal values are \texttt{sequence}, \texttt{tree} and \texttt{graph}. Note that the initial evaluation engine for \iql does not support the \texttt{graph} type! %TODO adjust once we extend the engine
\end{description}
\begin{elements}{\iqlType{Lane}}
	\element{elements}{\iqlBaseType{Element} (\ref{sec:json-ld-element})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{elements}] The structural constraints to be used for evaluation of this lane.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     LAYER
\subsection{Layer}
\label{sec:json-ld-layer}
%\begin{itemize}
%\item id
%\item name
%\item alias
%\item primary
%\item allMembers
%\end{itemize}
\desc{Every layer selector either references an entire subgraph of the corpus' member-graph directly or constructs a partial selection as part of a \iqlType{Scope} (\ref{sec:json-ld-scope}). 
When using the first approach, an \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} is referenced and all its dependencies and associated annotation layers will be made available implicitly. 
This is an easy way of accessing simple corpora, but can lead to costly I/O overhead when loading vast parts of a complex corpus that aren't actually needed to evaluate the query. 
For a more fine-grained alternative, scopes allow to create a scope that spans an exactly specified collection of layers. 
If multiple layer selectors are defined, up to one can be declared as ``primary'' to represent the granularity of returned items for the search or scope.
In case no layer is explicitly marked as ``primary'', the one specified by the corpus or context will be used for that role by default.}
\begin{attributes}{\iqlType{Layer}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{alias}{string}{no}{}
	\attribute{primary}{Boolean}{no}{false}
	\attribute{allMembers}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the layer within the entire query.
	\item[\iqlType{name}] Identifier used to reference the layer within its host corpus.
	\item[\iqlType{alias}] Optional identifier to rename the layer for referencing within the query.
	\item[\iqlType{primary}] Signals that the layer is intended to act as the primary layer in the query or scope and as such defines the level of granularity for obtaining chunks in the corpus.
	\item[\iqlType{allMembers}] When this layer definition is used inside a \iqlType{Scope} (\ref{sec:json-ld-scope}), effectively adds the entire member-subgraph of this layer to the scope. This property is redundant when the layer is part of the regular \iqlType{layers} declaration in a \iqlType{Stream} (\ref{sec:json-ld-stream}), as in that case all member subgraphs for each layer are already being added to the global scope!.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PAYLOAD
\subsection{Payload}
\label{sec:json-ld-payload}
%\begin{itemize}
%\item id
%\item name
%\item queryType
%\item bindings
%\item lanes
%\item constraint
%\end{itemize}
\desc{Every payload encapsulates all the (processed) query constraints to be evaluated against a single stream of corpus data.}
\begin{attributes}{\iqlType{Payload}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{no}{}
	\attribute{queryType}{enum}{yes}{}
	\attribute{queryModifier}{enum}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Automatically generated identifier to uniquely identify the payload within the entire query.
	\item[\iqlType{name}] Custom identifier to uniquely identify the payload within the entire query. This attribute is deprecated but currently being kept to shift its use case.
	\item[\iqlType{queryType}] The overall type of query strategy to be applied for this query payload. Legal values are \texttt{all} (returns the entire corpus and disallows any kind of constraint, leaving only the \iqlType{Result} (\ref{sec:json-ld-result}) declaration as option to modify the result volume), \texttt{plain} (disabling any kind of structural constraints/lanes), \texttt{singleLane} and \texttt{multiLane}. The last two values dictate the minimal/maximal number of \iqlType{Lane} definitions in this payload.
	\item[\iqlType{queryModifier}] Allows to limit the number of times an individual \acp{uoi} will be returned in the result. Supported values are \texttt{first}, \texttt{last} and \texttt{any}. The specific semantics of this modifier are described in more details in \cref{sec:constraints}.
\end{description}
\begin{elements}{\iqlType{Payload}}
	\element{bindings}{array of \iqlType{Binding} (\ref{sec:json-ld-binding})}{no}
	\element{lanes}{array of \iqlType{Lane} (\ref{sec:json-ld-lane})}{no}
	\element{filter}{\iqlType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{constraint}{\iqlType{Constraint} (\ref{sec:json-ld-constraint})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{bindings}] Optional collection of bindings used within this payload. Note that member variables inside constraints or structural query elements will not resolve unless previously bound to corpus members.
	\item[\iqlType{lanes}] If \iqlType{queryType} is set to \texttt{singleLane} or \texttt{multiLane}, this array is expected to hold either exactly 1 or at least 2 \iqlType{Lane} declarations that define structural constraint for the evaluation.
	\item[\iqlType{filter}] If \iqlType{queryType} is set to anything other than \texttt{plain}, this constraint expression allows to filter contextual \acp{uoi} prior to the actual structural matching.
	\item[\iqlType{constraint}] If \iqlType{queryType} is set to \texttt{plain}, this is expected to contain the basic constraints for matching candidates. In any version involving \iqlType{Lane} declarations, global constraints can be defined here as a means of implementing complex query features that are tested once the lanes have produced preliminary result candidates.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PROPERTY
\subsection{Property}
\label{sec:json-ld-property}
%\begin{itemize}
%	\item key
%	\item value
%\end{itemize}
\desc{Allows customization of the evaluation process by changing parameters or switching certain features on/off.}
\begin{attributes}{\iqlType{Property}}
	\attribute{key}{string}{yes}{}
	\attribute{value}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{key}] The identifier of the targeted parameter or switch. The evaluation engine might report unknown keys as errors.
	\item[\iqlType{value}] The actual value to apply to the specified property in case it is not a switch.
\end{description}

\subsubsection{Switches}
\label{sec:json-ld-switches}
For increased flexibility, \iql supports a collection of switches to turn certain optional features on or off when needed. Switches are static and cannot be changed for the active query evaluation once set. All the native \iql switches use the prefix \texttt{iql:} for their name. Any extensions that offer additional switches should declare and use their own namespace for those switches! Currently supported switches are shown in \cref{tab:switches}.

\begin{table}[h]
\noindent\begin{tabular}{|p{0.35\textwidth}|p{0.58\textwidth}|}
\hline 
\textbf{Name}	& \textbf{Description} \\ 
\hline 
\hline
iql.string.case.off         & Turns of case sensitivity when performing string operations such as equality checks.  \\ 
\hline
iql.string.case.lower       & Another approach to case insensitivity, this switch turns all strings into lower case.  \\ 
\hline
iql.expansion.off           & Effectively shuts down value expansion \cref{sec:value-expansion}.  \\ 
\hline
iql.string2bool.off         & Deactivates the interpretation of strings as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.int2bool.off            & Deactivates the interpretation of integers as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.float2bool.off          & Deactivates the interpretation of floating point numbers as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.obj2bool.off            & Deactivates the interpretation of arbitrary objects as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.any2bool.off            & Deactivates the interpretation of anything non-Boolean as Boolean value. This is a combination of ``iql.string2bool.off'', ``iql.int2bool.off'', ``iql.float2bool.off'' and  ``iql.obj2bool.off''.  \\ 
\hline
iql.direction.reverse       & Reverses the direction used to traverse corpus data for a search.  \\ 
\hline
iql.array.zero              & Change array access (\ref{sec:list-access}) to be 0-based.  \\ 
\hline
iql.markers.position.relative & Allow position markers (\ref{sec:position-markers}) to use relative (percentage) arguments.  \\ 
\hline
iql.warnings.off            & Deactivates all warnings, potentially resulting in confusing results if there are mistakes in the query.  \\ 
\hline
iql.parall.off			  & Forces the query evaluation engine to run single-threaded. This does however only affect the actual matcher, not additional. modules such as monitoring or item caches  \\ 
\hline
\end{tabular}
\caption{Currently supported switches in \iql and their explanations.}
\label{tab:switches}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     QUANTIFIER
\subsection{Quantifier}
\label{sec:json-ld-quantifier}
%\begin{itemize}
%\item quantifierType
%\item value
%\item lowerBound
%\item upperBound
%\end{itemize}
\desc{Specifies the multiplicity of an associated \iqlBaseType{Element} (\ref{sec:json-ld-element}).}
\begin{attributes}{\iqlType{Quantifier}}
	\attribute{quantifierType}{enum}{yes}{}
	\attribute{value}{integer}{no}{}
	\attribute{lowerBound}{integer}{no}{}
	\attribute{upperBound}{integer}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{quantifierType}] Defines how to interpret the other attributes. Legal values are \texttt{all} (universal quantification), \texttt{exact}, \texttt{atMost} (0..n), \texttt{atLeast} (n+), \texttt{range} (n..m).
	\item[\iqlType{value}] Target or limit value when \iqlType{quantifierType} is set to \texttt{exact}, \texttt{atMost} or \texttt{atLeast}.
	\item[\iqlType{lowerBound}] Used for \texttt{range} quantification to define the minimum multiplicity.
	\item[\iqlType{upperBound}] Used for \texttt{range} quantification to define the maximum multiplicity.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     QUERY
\subsection{Query}
\label{sec:json-ld-query}
%\begin{itemize}
%\item id
%\item dialect
%\item imports
%\item setup
%\item embeddeData
%\item streams
%\end{itemize}
\desc{Encapsulates all the global configuration and extension of the query engine, as well as shared embedded data. Each query contains at least one \iqlType{Stream} declaration that in turn holds the actual query payload with constraints for the matching process.}
\begin{attributes}{\iqlType{Query}}
	\attribute{id}{string}{yes}{}
	\attribute{dialect}{string}{no}{1.0}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier for the query, chosen by the client. In more complex (asynchronous) query workflows this id is used to map answers and results to the correct query.
	\item[\iqlType{dialect}] Specifies which basic version of \iql to use. The initial version of \iql is ``1.0`` and by leaving the dialect part of a query blank the engine will default to this initial version.
\end{description}
\begin{elements}{\iqlType{Query}}
	\element{imports}{array of \iqlType{Import} (\ref{sec:json-ld-import})}{no}
	\element{setup}{array of \iqlType{Property} (\ref{sec:json-ld-property})}{no}
	\element{embeddeData}{array of \iqlType{Data} (\ref{sec:json-ld-data})}{no}
	\element{streams}{array of \iqlType{Stream} (\ref{sec:json-ld-stream})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{imports}] Defines extensions to be applied to the evaluation engine prior to actual query evaluation.
	\item[\iqlType{setup}] Allows to configure the core evaluation engine or already defined extensions in a simple manner.
	\item[\iqlType{embeddeData}] Binary data to be used in the evaluation process, such as audio or video fragments.
	\item[\iqlType{streams}] Corpus data streams to be queried. In the initial version, the engine only supports single-stream querying!
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     REFERENCE
\subsection{Reference}
\label{sec:json-ld-reference}
%\begin{itemize}
%\item id
%\item name
%\item referenceType
%\end{itemize}
\desc{Models references usable from within query expressions for accessing corpus members or variables.}
\begin{attributes}{\iqlType{Reference}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{referenceType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the reference within the entire query.
	\item[\iqlType{name}] The local identifier to be used for addressing this reference. Note that this is the bare name without any type-specific prefixes (such as '\textdollar' for members, cf. \cref{sec:variables-references}).
	\item[\iqlType{referenceType}] Specifies the nature of this reference. Legal values are \texttt{reference}, \texttt{member} or \texttt{variable}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     RESULT
\subsection{Result}
\label{sec:json-ld-result}
%\begin{itemize}
%\item resultTypes
%\item resultInstructions
%\item limit
%\item percent
%\item sortings
%\end{itemize}
\desc{Encapsulates all the information on result processing and preparation.}
\begin{attributes}{\iqlType{Result}}
	\attribute{limit}{integer}{no}{}
	\attribute{percent}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{limit}] Optional limitation on the total size of the result to be returned. If the \iqlType{percent} flag is not set to \texttt{true}, this number is in reference to the units provided by the query's primary \repoLink{\modelsUrl layer/ItemLayer.java}{item layer}.
	\item[\iqlType{percent}] If set to \texttt{true} the value defined in \iqlType{limit} is treated as a integer percentage value in the interval 1 to 99, with boundaries included.
\end{description}
\begin{elements}{\iqlType{Result}}
	\element{resultTypes}{array of enum}{yes}
	\element{resultInstructions}{array of \iqlType{ResultInstruction} (\ref{sec:json-ld-result-instruction})}{no}
	\element{sortings}{array of \iqlType{Sorting} (\ref{sec:json-ld-sorting})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{resultTypes}] Defines the result format or type the engine should return data in. At least one result type must be declared and the engine can also be instructed to return the results in multiple formats simultaneously. In the first iteration only \texttt{kwic} (keyword-in-context) and \texttt{custom} (as a placeholder for the raw corpus members) are supported.
	\item[\iqlType{resultInstructions}] Optional collection of additional processing instructions to generate (textual) result reports.
	\item[\iqlType{sortings}] Allows to sort matches before generating result reports.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     RESULT INSTRUCTION
\subsection{Result Instruction}
\label{sec:json-ld-result-instruction}
%\begin{itemize}
%\item TODO
%\end{itemize}
%TODO fill once the specification is fleshed out
\desc{Currently unused dummy for declaring post-processing instructions on the query result to perform conversions and/or tabular calculations.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     SCOPE
\subsection{Scope}
\label{sec:json-ld-scope}
%\begin{itemize}
%\item id
%\item layers
%\end{itemize}
\desc{Very detailed vertical filtering of the layers available in a query.}
\begin{attributes}{\iqlType{Scope}}
	\attribute{id}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the scope within the entire query.
\end{description}
\begin{elements}{\iqlType{Scope}}
	\element{layers}{array of \iqlType{Layer} (\ref{sec:json-ld-layer})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{layers}] The layer members of this scope.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     SORTING
\subsection{Sorting}
\label{sec:json-ld-sorting}
%\begin{itemize}
%\item expression
%\item order
%\end{itemize}
\desc{Defines a single rule for sorting query results based on an arbitrarily complex expression.}
\begin{attributes}{\iqlType{Sorting}}
	\attribute{order}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{order}] Hint on sorting direction, legal values are \texttt{asc} or \texttt{desc} for ascending or descending order, respectively.
\end{description}
\begin{elements}{\iqlType{Sorting}}
	\element{expression}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{expression}] The actual sorting expression. It can use any (member) reference or variable available in the query to compute its result and must return a type that is comparable to allow stable sorting. Per default any of the primitive numerical types (\texttt{int} or \texttt{float}), the text type \texttt{string} and any member of the \icarus framework implementing the \texttt{java.lang.Comparable} interface can be used as return type.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STREAM
\subsection{Stream}
\label{sec:json-ld-stream}
%\begin{itemize}
%	\item id
%	\item primary
%	\item corpus
%	\item layers
%	\item scope
%	\item rawPayload
%	\item payload
%	\item rawGrouping
%	\item grouping
%	\item rawResult
%	\item result
%\end{itemize}
\desc{A stream encapsulates all the information and query constraints to extract, evaluate and prepare data from a single corpus. Note that many of the attributes and/or elements below are marked as optional, but the following restrictions are in effect:}
\vspace{-\medskipamount}
\begin{itemize}[leftmargin=*,topsep=0pt]\compresslist
	\item Either \iqlType{rawPayload} or \iqlType{payload} must be provided by the client.
	\item Either \iqlType{layers} or \iqlType{scope} must be provided to define the granularity of data being loaded for evaluation.
\end{itemize}
\begin{attributes}{\iqlType{Stream}}
	\attribute{id}{string}{yes}{}
	\attribute{primary}{Boolean}{no}{false}
	\attribute{rawPayload}{string}{no}{}
	\attribute{rawGrouping}{string}{no}{}
	\attribute{rawResult}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the stream within the entire query.
	\item[\iqlType{primary}] Flag to indicate that the primary layer of this stream is meant to be used as primary layer of the entire search result. Only one stream can declare this property and it primarily dictates the order of result elements in a multi-stream query or which stream is allowed to dictate sorting.
	\item[\iqlType{rawPayload}] The textual (raw) form of the payload for this stream, i.e. all the constraints and structural query content.
	\item[\iqlType{rawGrouping}] The textual (raw) grouping definitions to be applied for results of this stream.
	\item[\iqlType{rawResult}] The textual (raw) result configuration and post-processing instructions for this stream.
\end{description}
\begin{elements}{\iqlType{Stream}}
	\element{corpus}{\iqlType{Corpus} (\ref{sec:json-ld-corpus})}{yes}
	\element{layers}{array of \iqlType{Layer} (\ref{sec:json-ld-layer})}{no}
	\element{scope}{\iqlType{Scope} (\ref{sec:json-ld-scope})}{no}
	\element{payload}{\iqlType{Payload} (\ref{sec:json-ld-payload})}{no}
	\element{grouping}{array of \iqlType{Grouping} (\ref{sec:json-ld-group})}{no}
	\element{result}{\iqlType{Result} (\ref{sec:json-ld-result})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{corpus}] The corpus to extract data from.
	\item[\iqlType{layers}] Vertical filtering to be applied to the corpus prior to actual query evaluation.
	\item[\iqlType{scope}] Another and more fine-grained form of vertical filtering that allows for more precise selection of layers to be part of this stream's data.
	\item[\iqlType{payload}] The processed form of \iqlType{rawPayload}.
	\item[\iqlType{grouping}] The processed form of \iqlType{rawGrouping}.
	\item[\iqlType{result}] The processed form of \iqlType{rawResult}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Inner \iql ELements}
\label{sec:inner-iql-elements}

Certain parts of an \iql query can be defined in \textit{raw} form, that is, in a keyword-driven formal language.
During the first phase of query evaluation they get (partly) translated into their respective JSON-LD counterparts described in \cref{sec:elements} (unless of course the query or query fragments are provided fully processed).
This section defines the syntax and additional rules for those raw statements.
Note that the textual form of all following \iql elements is expected to be encoded in UTF-8, so no special escape mechanisms are needed for unicode content.


%TODO from here on restructure!


\subsection{Reserved Words}
\label{sec:reserved-words}

The following list of keywords is reserved and any of the words may not be used as direct identifier strings in a query. They are reserved in both all lowercase and all uppercase variants, and while camel-cased versions are technically permitted, it is highly discouraged to use them:

\vbox{%
\begin{multicols}{4}
\parindent=0pt
\texttt{%
\begingroup
\obeylines
\input{keywords.txt}
\endgroup
}
\end{multicols}
}

\noindent In addition the following strictly lowercase words are reserved as type identifiers and may not be used otherwise:

\vbox{%
\begin{multicols}{4}
\parindent=0pt
\texttt{%
\begingroup
\obeylines
\input{types.txt}
\endgroup
}
\end{multicols}
}

\subsection{Comments}
\label{sec:comments}

\iql supports single-line comments, indicated by ``//''. All remaining content in a line after the comment indicator will be ignored when parsing and evaluating a query. 

\subsection{Literals}
\label{sec:literals}

Literals are statically-typed fixed-value expressions in \iql.
They are parsed only once during the initial processing part of a query.

\subsubsection{String Literals}
\label{sec:string-literals}

\iql uses simple double quotes (\lit{"} or U+0022) to define string literals. 
String literals may not contain any of the following symbols directly:

\begin{Verbatim}[samepage=true]
\n line break
\r carriage return
\t tab
\ backslash
" nested quotation mark
\end{Verbatim}

\noindent Any of those symbols listed above can be embedded into a string literal as part of an escape sequence with a preceding backslash.
At the current time there is no planned mechanism to provide additional escape support for unicode symbols, since the default encoding scheme for \iql is UTF-8.

\paragraph{Examples for valid string literals:}

\begin{Verbatim}[samepage=true]
"string"
"123"
"some fancy number (123.456e-789) and special symbol â£"
"a more complex string!"
"a\n multiline\n string..."
\end{Verbatim}

\subsubsection{Boolean Literals}
\label{sec:boolean-literals}

Boolean literals are limited to either all lowercase or all uppercase versions of the literals \keyword{true} and \keyword{false}.

\subsubsection{Integer Literals}
\label{sec:integer-literals}

\paragraph{Signed Integer Literals}
Literals representing regular \keyword{int} (32bit) or \keyword{long} (64bit) integers consist of an optional initial sign (\lit{+} or \lit{-}) and the body consisting of digits (\lit{0} to \lit{9}) or underscore (\lit{\_}) characters.
Underscore characters may only appear inside the integer literal, never at the beginning or end (not counting the sign symbol).

\begin{gram}
	\label{gram:integer}
	\begin{rrdiag*}{integerLiteral}
		\sst \\ `+' \\ `\textminus' \est
			<digit> \sst \\ \sst \\ \srp \sst <digit> \\ `\_' \est \\ \erp \est <digit> \est
	\end{rrdiag*}
\end{gram}

\paragraph{Examples for valid (signed) integer literals:}

\begin{Verbatim}[samepage=true]
1
+123
-123
1_000_000
-99_000000_0
\end{Verbatim}

\paragraph{Pure Integer Literals}
Some parts of the \iql syntax only allow unsigned "pure" integers and will explicitly state this fact. In those special cases integer literals may neither contain the initial sign symbol nor intermediate underscores.

\subsubsection{Floating Point Literals}
\label{sec:floating-point-literals}

Floating point literals are constructed by using a (signed) integer literal for the pre-decimal part, a dot \lit{.} as delimiter and a decimal part made up by a unsigned integer literal. They represent either single-precision \keyword{float} (32bit) or double-precision \keyword{double} (64bit) values.

\begin{gram}
	\label{gram:floating-point}
	\begin{rrdiag*}{floatingPointLiteral}
		<signedInteger> `.' <unsignedInteger>
	\end{rrdiag*}
\end{gram}

\paragraph{Examples for valid (signed) floating point literals:}

\begin{Verbatim}[samepage=true]
1.0
+123.456
-123.456
1_000_000.999
-99_000000_0.000_000_001
\end{Verbatim}

\noindent While many languages offer to express floating point literals in the scientific notation with explicit exponent declaration, we do not include this in the initial draft of \iql.

\subsection{Identifiers}
\label{sec:identifiers}

\noindent Identifiers in \iql are combinations of lowercase or uppercase alphabetic \texttt{[a-zA-Z]} characters that may contain underscore symbols \texttt{\_} between the first and last position and may also contain digits \texttt{[0-9]} on any position except as initial symbol (cf. \cref{gram:identifier}).

\begin{gram}
	\label{gram:identifier}
	\begin{rrdiag*}{identifier}
		<character> \sst \\ 
			\sst \\ \srp \sst <character> \\ <digit> \\ `\_' \est \\ \erp \est
				\sst <character> \\ <digit> \est
		\est
	\end{rrdiag*}
\end{gram}

\paragraph{Examples for valid identifiers:}

\begin{Verbatim}[samepage=true]
x
myIdentifier
x1
x_1
x__1
x321
some_random_id
someRandomId002
random_2_4
notTheBest______________example
\end{Verbatim}

\noindent Identifiers are limited in length by the engine to a total of 255 characters. This is a purely arbitrary choice to keep queries readable and not subject to any technical limitations.

\subsection{Variables and References}
\label{sec:variables-references}

In \iql all top-level (i.e. not part of the tail expression in a hierarchical path) identifiers are expected to reference 'something' from the global namespace available to the query. This namespace is populated with all the globally available constants, methods and helper objects from the \iql core and any imported extensions, as well as all the corpus members defined in the scoping part of the query. Outside this global namespace any dynamically created identifiers from within a query reside in the variable namespace and are marked with a preceding \lit{@} (e.g. \texttt{@myVariable}). They can be used the same way as any regular identifier, with the exception of additionally allowing assignment expressions when inside script blocks. In addition any corpus members bound within a constraint section are prefixed with a \lit{\$} sign, such as \texttt{\$token1}. \cref{tab:identifiers} provides a compact overview of the available identifiers and their capabilities/features.

\begin{table}[ht]
	\centering\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline 
		Type	& Prefix & Example & Scope & Fixed\footnotemark & Final & Re-Assign \\ 
		\hline 
		Reference	&  & \texttt{max()} & global & X & X &  \\ 
		\hline 
		Variable	& \texttt{@} & \texttt{@myVar} & limited & (X) &  & X \\ 
		\hline 
		Member	& \texttt{\$} & \texttt{\$token} & limited & X & (X) &  \\ 
		\hline 
	\end{tabular}
	\footnotetext{Fixed as in ``fixed type'', i.e. the type of value stored is pre-determined and cannot be changed during query evaluation.} %TODO doesn't work properly
	\caption{Identifier types available in \iql and their properties.}
	\label{tab:identifiers}
\end{table}

\paragraph{Special remarks:}
\noindent Variables are more or less general-purpose storage objects for arbitrary values and without a fixed type. Their first assignment however hints at the implied type to be used and as such they can cause cast errors when used for situations where an incompatible type would be needed.

Member identifiers are final in the sense that they cannot be re-assigned explicitly but will be implicitly for every iteration of the query on a new part of the corpus. For example, above \texttt{\$token} member will point to a new token object every time the inner constraint parts of the query are evaluated. Therefore member identifiers could be viewed as a sort of loop variable. 

\subsection{Expressions}
\label{sec:expressions}

Expressions are the foundation of every query.
Each expression has a (usually fixed) result type and evaluates to a value of that type.
They can take any of the following forms and a overview diagram is available in the appendix as \cref{gram:expression}.

\subsubsection{Primary Expressions}
\label{sec:primary-expressions}

Any literal of types \keyword{boolean}, \keyword{string}, \keyword{int} or \keyword{float} can serve as a primary expression of that type.
See \cref{sec:literals} for examples and a more detailed specification of the various types of literals in \iql.

\paragraph{References}
\noindent Any reference or variable as described in \cref{sec:variables-references} is also a valid primary expression.
Note that the process for resolving references strongly relies on the context the reference is being used in, for instance to allow simple references to be used as aliases for method calls.

Additionally a special construct is available as primary expression to more easily access annotation values from within a node definitions (\ref{sec:structural-constraints}).
Normally the evaluation engine tries to resolve any otherwise unknown identifier inside a node as the key (aliased or original) of an annotation that should be fetched for the item matched to this node.
But since this is not always possible in an unambiguous way or there exists a name clash between an annotation key and another identifier available in the current environment, a \synt{qualifiedIdentifier} (\cref{gram:qualified-identifier}) can be used instead.

\begin{gram}[\synt{qualifiedIdentifier}]
	\label{gram:qualified-identifier}
	\begin{grammar}	
		<qualifiedIdentifier> ::= <identifier> `::' <identifier> 	
	\end{grammar}
\end{gram}

A qualified identifier consists of two identifiers that are joined by a double colon \lit{::}.
The first (or left) identifier is expected to unambiguously resolve to a annotation layer available for the current context.
The second (or right) identifier in turn acts as specification of an annotation key (or its alias) available from the previously defined annotation layer.

\paragraph{List Expression}
Arrays (or more generally ``lists'') in \iql can be defined by enclosing a sequence of expressions within curly brackets (\lit{\{} and \lit{\}}), using the comma symbol (\lit{,}) as separator.
Optionally the desired type for elements in the list can be made explicit with a special type marker in front of the opening bracket as illustrated by \cref{gram:list-expression}.
If no type is provided, the overall element type will be determined by checking the types of all elements and choosing the least restrictive one.
Note that for empty lists (no elements are given inside the curly brackets) it is mandatory to specify the element type!

\begin{gram}[\synt{listExpression}]
	\label{gram:list-expression}
	\begin{grammar}	
		<listExpression> ::= (<type> `[]')? `{' (<expression> (`,' <expression>)* )? `}'	
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{listExpression}
		\sst \\ <type> `[]' \est `{' \sst \\ \srp <expression> \\ `,'\erp  \est `}' \\	
	\end{rrdiag*}
\end{gram}

\subsubsection{Path Expressions}
\label{sec:path-expressions}

For navigating hierarchically structured object graphs or namespaces, expressions can take the form of paths, consisting of a original expression, a dot as separator and finally an identifier that denotes the path element or ``field'' within the context of whatever the original expression returned.

\begin{gram}[\synt{path}]
	\label{gram:path-expression}
	\begin{grammar}	
		<path> ::= <expression> `.' <identifier> 	
	\end{grammar}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
someObejct.someProperty
some.really.long.winded.path
\end{Verbatim}

\noindent Note that for a lot of native classes of the ICARUS2 framework, \iql provides convenient path-based alternatives to method invocations. For example in  the context of navigating a structure, ``someStructure.getParent(someItem)`` can be replaced by ``someItem.parent`` as long as ``someStructure`` is unambiguous in the current context and already bound.

\subsubsection{Method Invocation}
\label{sec:method-invocations}

Method invocations consist of an expression that points to the actual method (such as an identifier in the global namespace or a path expression) and round brackets for the invocation with an optional argument list:

\begin{gram}[\synt{method}]
	\label{gram:method-invocation}
	\begin{grammar}	
		<method> ::= <expression> `(' <arguments>? `)'
		
		<arguments> ::= <expression> (`,' <expression>)*	
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{method}
		<expression> `(' \sst \\ \srp <expression> \\ `,' \erp \est `)'
	\end{rrdiag*}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
myFunction()
myNamespace.someFunction(someArgument, anotherArgument)
min(123, 456, dynamicContent())
some().chained().methods()
\end{Verbatim}

\subsubsection{List Access}
\label{sec:list-access}

Lists or arrays are accessed by an expression pointing to the list or array object itself and an index expression in square brackets indicating the position(s) of the desired element(s) within the array. Note that the index or indices expression must evaluate to values within 32bit signed integer space. Positive values indicate the position beginning from the start of the 0-based array, whereas negative values allow backwards referencing of elements with \lit{-1} pointing to the last array element and \lit{-2} to the second to last one. For multidimensional arrays several index statements can be chained or even combined in a single comma-separated list.

\begin{gram}[\synt{array}]
	\label{gram:list-access}
	\begin{grammar}	
		<array> ::= <expression> `[' <indices> `]'
		
		<indices> ::= <expression> (`,' <expression>)*	
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{method}
		<expression> `[' \srp <expression> \\ `,' \erp `]'
	\end{rrdiag*}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
myArray[1]
myArray[-1]
myArray[-myArray.length] // same as myArray[0]
complexArray[1][2][3]
complexArray[-1][2][-3]
complexArray[1, 2][3]
complexArray[1, 2, 3]
\end{Verbatim}

\noindent Note that \iql provides convenient ways of using array access patterns to access list-like data structures and/or classes of the framework:
Every \repoLink{\modelsUrl /members/item/manager/ItemLookup.java}{ItemLookup} implementation, such as \repoLink{\modelsUrl /members/container/Container.java}{Container} or \repoLink{/members/structure/Structure.java}{Structure} that would traditionally access its content via ``myContainer.getItemAt(someIndex)`` can be used the same as any regular array with the expression ``myContainer[someIndex]``.

\subsubsection{Annotation Access}
\label{sec:annotation-access}

The \ac{icmf} models segmentation, structure and content of a corpus resource as different aspects. As such the information about any annotation attached to a given Item is stored apart from it and therefore is not easily accessible from the item alone. To simplify the usage of annotations within a query, \iql provides the following expression as syntactic sugar for accessing (multiple) annotations directly from an item:

\begin{gram}[\synt{annotation}]
	\label{gram:annotation-access}
	\begin{grammar}	
		<annotation> ::= <expression> `{' <keys> `}'
		
		<keys> ::= <expression> (`,' <expression>)*
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{method}
		<expression> `{' \srp <expression> \\ `,' \erp `}'
	\end{rrdiag*}
\end{gram}

\noindent The first expression must evaluate to an item reference and the annotation pointers inside curly brackets must evaluate to strings (if only a single expression is given, it can evaluate to a list or array and be expanded, cf. \cref{sec:value-expansion}) that uniquely denote annotation layers in the current context of the query. Typically users will use string literals in double quotes to explicitly state the annotations to be accessed, but the \iql syntax allows for very flexible extraction statement. If the evaluation of those annotation pointers yields more than one string, the result will be an array-like object containing the resolved values for each of the annotation keys in the same order as those were specified.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
myItem{"pos"}
myItem{"form", "pos", "lemma"} 

// extract values from multiple concurrent annotation layers
// and pick the first one present
firstSetValue(myItem{"parser1.head", "parser2.head"})  
\end{Verbatim}

\subsubsection{Type Cast}
\label{sec:type-cast}

Expressions in \iql are automatically cast to matching types according to the actual consumer's needs (unless this feature gets deactivated via the corresponding switch, cf. \cref{sec:json-ld-switches}). Explicit casts can be performed by preceding an expression with one of the type keywords listed above (\ref{sec:reserved-words}) in round brackets.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
(int) myValue
(int) 12345.678
(float) average(myVector)
(string) 123.456
\end{Verbatim}

\subsubsection{Wrapping}
\label{sec:wrapping}

Expression hierarchy and evaluation order follows the order the different types of expressions are listed here. To dictate another order, expressions can be wrapped into round brackets. This will cause the inner expression to be evaluated independent of potential hierarchical rules from the outside context.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
6 + 4 * 2   // multiplication evaluated first -> result 14
(6 + 4) * 2 // addition is evaluated first -> result 20
\end{Verbatim}

\subsubsection{Unary Operation}
\label{sec:unary-operation}

\iql only allows four unary operators to be used directly in front of an expression, the exclamation mark \lit{!} and the \keyword{NOT} keyword for Boolean negation, the minus sign \lit{\textminus} for negating numerical expressions and the \lit{\texttildelow} symbol of bitwise negation of integer numbers.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
!someBooleanFunction()
NOT someBooleanValue
-123
-myNumericalFunction()
~123
~myIntegerFunction()
\end{Verbatim}

\subsubsection{Binary Operation}
\label{sec:binary-operation}

Binary operations between two expressions take the following simple form:

\begin{gram}[\synt{binary_op}]
	\label{gram:binary-operations}
	\begin{grammar}	
		<binary_op> ::= <expression> <operator> <expression>
	\end{grammar}
\end{gram}

\noindent Binary operators follow an explicit hierarchy, listed in \cref{tab:binary-operators} in the order of priority, from highest to lowest.

\begin{table}[ht]
	\centering
	\begin{tabular}{|p{0.25\textwidth}|p{0.6\textwidth}|}
		\hline 
		\textbf{Operators}	& \textbf{Explanation} \\ 
		\hline 
		\hline
		\verb|*  /  %|& multiplication, division and modulo \\ 
		\hline 
		\verb|+  -|& addition and subtraction \\ 
		\hline 
		\verb#<<  >>  &  |  ^#& shift left, shift right, bitwise and, bitwise or, bitwise xor \\ 
		\hline 
		\verb|<  <=  >  >=|& less, less or equal, greater, greater or equal \\ 
		\hline 
		\verb|=~  !~  =#  !#|& string operators: matches (regex), matches not (regex), contains, contains not \\ 
		\hline 
		\verb|==  !=|& equals, equals not \\ 
		\hline 
		\verb|&&  AND|& logical and \\ 
		\hline 
		\verb#||  OR#& logical or \\ 
		\hline 
	\end{tabular} 
	\caption{Binary operators available in \iql and their hierarchical order.}
	\label{tab:binary-operators}
\end{table}

\paragraph{Basic Numerical Operations}
\label{sec:basic-numerical-operations}

Basic numerical operations follow the standard mathematical rules for priorities.
While the basic numerical types (\keyword{int}, \keyword{float}) can be arbitrarily mixed inside those expressions, the type used during the expression and as result will be determined by the least restrictive type of any operand involved.

\paragraph{Bit Operations}
\label{sec:bit-operations}

Bitwise operations (\lit{\&}, \lit{|} and \lit{\textasciicircum}) take integer expressions (or any other form of \textit{bitset}) as inputs and generate a result of the corresponding type. If different types are used (e.g. \texttt{int} and \texttt{long}), one must be cast~\ref{sec:type-cast} to match the other. If value expansion~\ref{sec:value-expansion} is active, any array-like data can also be used and will be subject to element-wise bit operations.

The two shift operations (\lit{\textless{}\textless} and \lit{\textgreater{}\textgreater}) take arbitrary integer types as left operand and an \keyword{int} value as right operand.

\paragraph{Ordered Comparisons}
\label{sec:ordered-comparisons}

Comparisons are special binary operators that take two expressions of equal or compatible result type and produce a Boolean value. Note that their exact semantics are type specific, e.g. when comparing strings, the operation is performed lexicographically and may be subject to case conversions (\ref{sec:json-ld-switches}).

\paragraph{String Operations}
\label{sec:string-operations}

To account for the ubiquity of textual annotations in corpora, \iql provides a set of dedicated string operators to perform substring matching (with the \textit{contains} operator \lit{=\#} or its negated form \lit{!\#}) and regular expression matching (via \lit{=\textasciitilde} and \lit{!\textasciitilde}). Per default \iql uses the Java regex syntax, but for the future, additional switches (\ref{sec:json-ld-switches}) are planned to allow finer control over regex details.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
// find verbal forms
somePosAnnotation # "V"       
// alternative to the set predicate with more flexibility
somePosAnnotation !~ "NN|NS"   
\end{Verbatim}

\paragraph{Equality}
\label{sec:equality}

Equality checks follow the same basic conditions as ordered comparisons (\ref{sec:ordered-comparisons}), but with the following rules for comparable values ``a`` and ``b``:

\begin{Verbatim}[samepage=true]
a == b iff !(a<b) && !(a>b)
a != b iff a<b || a>b
\end{Verbatim}

\noindent More generally, equality between expressions in \iql is based on content equality and therefore type specific.
Note that trying to check two expressions of incompatible types (such as \keyword{int} and \keyword{string}) for equality will always evaluate to \keyword{false} and also emit a warning. 
%TODO is this part actually implemented?

\paragraph{Logical Composition}
\label{sec:logical-composition}

All Boolean expressions can be combined via disjunction (either double pipes \lit{||} or the \keyword{OR} keyword) or conjunction (double ampersand \lit{\&\&} or the \keyword{AND} keyword), with conjunction having higher priority. While not strictly mandatory, evaluation of \iql expressions is recommended to employ optimized interpretation such that only the first operand is evaluated if possible. When the first operand of a disjunction evaluates to \keyword{true}, the entire expression is already determined, same for a conjunction's first operand yielding \keyword{false}. 

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
a>1 && b<2
x==1 or x==3
\end{Verbatim}

\subsubsection{Assignment}
\label{sec:assignment}

\iql offers a special construct to assign (member) variables and at the same time verify the successful assignment with a Boolean result value. 
\Cref{gram:assignment} illustrates the basic syntax for assignment operations inside a constraint, allowing the result of an arbitrary expression to be assigned to any previously defined member variable (or dynamically allocated variable).

\begin{gram}[\synt{assignment}]
	\label{gram:assignment}
	\begin{grammar}	
		<assignment> ::= <expression> `AS' (<member> | <variable>)
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{setPredicate}
		<expression> `AS' \sst <member> \\ <variable> \est
	\end{rrdiag*}
\end{gram}

If a member variable is used for the assignment or the variable has already been used previously and thereby has been type-bound, the result type of the \synt{expression} has to be compatible!
Assignment operations provide a Boolean return value that is \keyword{true} iff the assignment was successful and the (member) variable holds a non-null value.
\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
// global constraint over two tree nodes to fetch their first 
// ancestor, failing if $x and $y do not have a common ancestor
... HAVING ancestor($x, $y) AS $a
\end{Verbatim}


\subsubsection{Set Predicate}
\label{sec:set-predicate}

Also called 'containment predicate', this expression allows to check if a given value is a member of a specified set (or generally speaking 'collection') as shown in \cref{gram:set-predicate}. 
The entire expression evaluates to a Boolean value and will be \keyword{true} iff the input expression (left-most one) evaluates to the same value as any of the elements inside the set definition to the right (typically a list expression, cf. \cref{sec:primary-expressions} or \cref{gram:list-expression}). 
See about equality operators in \cref{sec:binary-operation} on how elements are compared. 
Note that methods or collections used inside the set definition are subject to the expansion rules described in \cref{sec:value-expansion}.
The primary use case for set expressions is to greatly simplify the declaration of constraints for multiple alternative target values. 

Set predicates can be directly negated (apart from wrapping~\ref{sec:wrapping} them and negating~\ref{sec:unary-operation} the entire expression) with an exclamation mark \lit{!} or the keyword \keyword{NOT} in front of the \keyword{IN} keyword. 
If the input expression evaluates to an array-like object, the set predicate will expand its content and evaluate to \keyword{true} if at least \textit{one} of its elements is found to be contained in the set. 
The set predicate can be universally quantified with a star \lit{*} or the \keyword{ALL} keyword in front to change the overall behavior such that the result will be \keyword{true} iff \textit{all} of the elements are contained in the set (or none of them are, if the set predicate is directly negated).

\begin{gram}[\synt{setPredicate}]
	\label{gram:set-predicate}
	\begin{grammar}	
		<setPredicate> ::= <expression> <all>? <not>? `IN' <expression>
		
		<all> ::=  `ALL' | `*'
		
		<not> ::=  `NOT' | `!'
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{setPredicate}
		<expression> \sst \\ `ALL' \\ `*' \est \sst \\ `NOT' \\ `!' \est `IN' <expression>
	\end{rrdiag*}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
someAnnotationValue IN {"NP","VP","-"}
someAnnotationValue NOT IN {"NN","DET"}
someAnnotationValue NOT IN {"NN","DET", STTS.getVerbTags()}
"John" IN getLegalNames()
fetchCharacterNamesInChapterOne() IN getOrcishNames()
\end{Verbatim}

\subsubsection{Ternary Operation}
\label{sec:ternary-operation}

A single ternary operation is supported in \iql, which is the popular if-then-else replacement with the following syntax:

\begin{gram}[\synt{ternary}]
	\label{gram:ternary-operations}
	\begin{grammar}	
		<ternary> ::= <expression> `?' <expression> `:' <expression>
	\end{grammar}
\end{gram}

\noindent The first expression must evaluate to a \keyword{boolean} value and determines which of the following two alternatives will be evaluated for the final value of the expression. Note that the second and third expressions must have compatible result types.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
x<2 ? "text for smaller value" : "some other text"
\end{Verbatim}

\subsubsection{Value Expansion}
\label{sec:value-expansion}

\iql supports expansion of arrays, lists and array-like method return values for situations where an immediate consumer supports lists of values as input. Assuming the method ``randomPoint()'' returns an array of 3 integer values or a \textit{array-like} data type (such as a 3D point) and another method ``invertPoint(int, int, int)'' takes 3 integer arguments, then the invocation of ``invertPoint(randomPoint())'' is legal and the array or object from the inner method call will be automatically expanded into the separate 3 values. This is especially handy when dealing with multidimensional arrays, as regular indexing would require manual extraction of method return values into variables to then be used in accessing the different array dimensions. With automatic expansion, a three-dimensional array could directly be accessed with aforementioned method via ``array[randomPoint()]''.

\subsection{Constraints}
\label{sec:constraints}

Simply put, constraints are expressions that evaluate to a Boolean result. 
Apart from native Boolean expressions (such as comparisons, Boolean literals or Boolean functions), \iql allows certain evaluations as syntactic sugar, listed in \cref{tab:constraints-translation}.
Note that those conversions are only active if the respective switches to disable them (\ref{sec:json-ld-switches}) have not been set.

\begin{table}
	\centering
	\begin{tabular}{|l|c|c|}
		\hline 
		\textbf{Type} & \textbf{Condition} & \textbf{Value} \\ 
		\hline 
		\keyword{string} & empty or null & \keyword{false}  \\ 
		\hline 
		\keyword{int} & \texttt{0} & \keyword{false} \\ 
		\hline 
		\keyword{float} & \texttt{0.0} & \keyword{false} \\ 
		\hline
		any object & \keyword{null} & \keyword{false} \\ 
		\hline 
	\end{tabular}
	\caption{Rules for converting arbitrary values or objects in a query to Boolean values.}
	\label{tab:constraints-translation}
\end{table}

\subsection{Payload Structure}
\label{sec:payload-structure}

The Payload section in \iql consists of either the sole \keyword{ALL} keyword or a selection statement (\ref{sec:selection}) with optional binding (\ref{sec:bindings}) definition and filter constraints (\ref{sec:filter-constraints}) preceding it.
If the \keyword{ALL} keyword is used, no constraints whatsoever can be defined and the engine is instructed to return the entire target corpus.
In this case the only way of restricting results is by using the \iqlType{Result} section (\ref{sec:json-ld-result}) of a query.

\begin{gram}[\synt{payload}]
	\label{gram:payload}
	\begin{grammar}	
		<payload> ::= `ALL' 
		\alt <bindingsList>? (`FILTER' `BY' <constraint>)? `FIND' <modifier>? <selection>
		
		<modifier> ::= `FIRST' | `LAST' | `ANY'	
	\end{grammar}
	\diagsep
	\begin{samepage} %TODO need alternative to prevent pagebreak between multiple rrfrag instances
	\rrhead{payload with content}
	\begin{rrfrag}{>-}{...}
		\sst \\ <bindingsList> \est \sst \\ `FILTER' `BY' <constraint> \est 
	\end{rrfrag}
	\newline
	\begin{rrfrag}{...}{->}
		`FIND' \sst \\ `FIRST' \\ `LAST' \\ `ANY' \est <selection>
	\end{rrfrag}
	\end{samepage}
\end{gram}

\subsubsection{Filter Constraints}
\label{sec:filter-constraints}
\noindent For complex (i.e. structural) queries, \iql offers a way of filtering the \acp{uoi} before they are processed by the matchers for sequence, tree or graph structures (cf. \cref{sec:sequence-constraints,sec:tree-constraints,sec:graph-constraints}).
A dedicated \keyword{FILTER BY} section in the query payload preceding the actual structural constraints is available to define filtering rules that have to evaluate to \keyword{true} for a \ac{uoi} to be considered for actual matching.
Constraints within a filtering rules have only access to general properties of the \acp{uoi}, such as sentence length, tree height or similar information.
The do \textbf{not} have access to bound member variables, apart from those defined for the top-level members of lanes (\ref{sec:lanes})!
Note that filter constraints are \textbf{not} compatible with flat constraints (\ref{sec:flat-constraints}) as they both essentially fill the same function and flat constraints take precedence.

\subsubsection{Match Modifiers}
\label{sec:match-modifiers}
Per default, the search in \iql is expected to be exhaustive, i.e. the evaluation engine will attempt to find all of the instances in a target corpus that match the query constraints, potentially reporting individual \acp{uoi} (such as sentences) multiple times  if they contain several occurrences.
For instance, the sentence ``The dog chased the rabbit down the hill.'' will be treated as tree entries in the result if the query was only meant to find instances of the lemma ``the''.
This default behavior can be adjusted to only return each \ac{uoi} no more than once by using one of the modifiers (\keyword{FIRST}, \keyword{LAST}, \keyword{ANY}) listed in \cref{gram:payload}.
The semantics of the \keyword{ANY} modifier are such that the engine may freely pick any one match within a \ac{uoi}.
Note however, that to support reproducible search results, repeated evaluations of the same query on a corpus are still required to yield the same instances here.
The exact semantics of \keyword{FIRST} and \keyword{LAST} are depending on the type of structural constraints used in the payload, but generally are based on the natural order of items within the corpus (typically this is the flow of words in a text).
The evaluation behavior for them is subsequently covered in \cref{sec:sequence-constraints,sec:tree-constraints,sec:graph-constraints}.

\subsubsection{Bindings}
\label{sec:bindings}
A binding is a collection of member references (\ref{sec:variables-references}) that get declared to belong to a certain member type or part of the corpus. 
The \keyword{DISTINCT} keyword enforces that multiple bound member references in this binding do \textbf{not} match the same target. 
Depending on the local constraints used in the query, this might be redundant (e.g. when using the member references as identifiers for tree nodes who already are structurally distinct), but can still be used to make that fact explicit. 
Additionally the \keyword{EDGES} keyword signals that the bound members of a structure are actually edges.
In this case using \keyword{DISTINCT} is redundant, as bound edges are implicitly assumed to be distinct when matching.

\begin{gram}[Bindings]
	\label{gram:bindings}
	\begin{grammar}	
		<bindingsList> ::= `WITH' <binding> (`AND' <binding>)* 
		
		<binding> := <option>? <member> (`,' <member>)* `FROM' <layer>
		
		<option> := `DISTINCT' | `EDGES'	
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{bindingsList}
		`WITH' \srp
			\sst \\ `DISTINCT' \\ `EDGES' \est \srp <member> \\ `,' \erp `FROM' <layer>
			\\ `AND'
		\erp 
	\end{rrdiag*}
\end{gram}

\noindent Raw binding definitions in the payload are parsed and stored in their JSON counterpart (\iqlType{Binding},~\ref{sec:json-ld-binding}) during query processing.

\subsubsection{Selection Statement}
\label{sec:selection}

Constraints are further divided into local constraints as part of node or edge definitions and global ones (with the \keyword{HAVING} keyword). 
Local constraints are obligatory and define the basic complexity of the query (flat, tree or graph). 
They also introduce certain limitations on what can be expressed or searched (e.g. a ``flat'' local constraints declaration will not provide implicit access to tree information). 
However, global constraints can introduce arbitrary constraints or relations and thereby increase the evaluation complexity, potentially without limits. 
Since there is no way for an evaluation engine to assess the complexity of user macros or extensions, extensive use of global constraints could in fact lead to extremely slow searches or even create situations where an evaluation will never terminate at all.

\begin{gram}[\synt{selectionStatement}]
	\label{gram:selection}
	\begin{grammar}	
		<selectionStatement> ::= <constraint>
		\alt (<nodeStatement> | <laneStatementsList>) (`HAVING' <constraint>)?	
		
		<laneStatementsList> ::= <laneStatement> (`AND' <laneStatement>)*
		
		<laneStatement> ::= `LANE' <identifier> (`AS' <member>)? <nodeStatement>
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{selectionStatement}
		\sst
			\sst <nodeStatement> \\ \srp <laneStatement> \\ `AND' \erp \est
				\sst \\ `HAVING' <constraint> \est \\ 
			<constraint> 
		\est
	\end{rrdiag*}

	\begin{rrdiag*}{laneStatement}
		`LANE' <identifier> \sst \\ `AS' <member> \est <nodeStatement>
	\end{rrdiag*}
\end{gram}

%TODO a few words about nodeStatement and link to section about structural constraints?

\subsubsection{Lanes}
\label{sec:lanes}
\noindent Lane statements can be used to extract information from concurrent structures that exist for the \ac{uoi} of the payload.
Each lane statement is introduced by the \keyword{LANE} keyword and an identifier that matches the name or alias of a layer in the outer query definition (cf. \cref{gram:selection}).
Optionally the source layer of a lane can also be assigned a member variable (\ref{sec:variables-references}) so that it can be explicitly referenced in the payload.\footnote{This is particularly useful when using the global constraints to compare content of different lanes. Imagine for instance a query that searches for a certain syntactic construct \texttt{C} to be present in two concurrent parse trees \texttt{A} and \texttt{B}, but will only consider sentences where \texttt{C} is embedded deeper inside \texttt{A} compared to its embedding depth in \texttt{B}.}
During query processing raw lane statements will be parsed into \iqlType{Lane} objects (\ref{sec:json-ld-lane}).

%TODO from here rework

Constraints are further divided into local constraints as part of node or edge definitions and global ones (with the \keyword{HAVING} keyword). 
Local constraints are obligatory and define the basic complexity of the query (flat, tree or graph). 
They also introduce certain limitations on what can be expressed or searched (e.g. a ``flat'' local constraints declaration will not provide implicit access to tree information). 
However, global constraints can introduce arbitrary constraints or relations and thereby increase the evaluation complexity, potentially without limits. 
Since there is no way for an evaluation engine to assess the complexity of user macros or extensions, extensive use of global constraints could in fact lead to extremely slow searches or even create situations where an evaluation will never terminate at all.

\subsubsection{Flat Constraints}
\label{sec:flat-constraints}

Flat constraints provide no extra helpers to declare structural properties of the query. 
They consist of arbitrary basic constraints \cref{sec:constraints} and disallow both global constraints (\ref{sec:global-constraints}) and filter constraints (\ref{sec:filter-constraints}). 
Note that flat constraints rely on the availability of member references from the binding or lane sections in the query payload to have access to any content at all.
In this regard they behave very similar to global constraints.

\subsubsection{Structural Constraints}
\label{sec:structural-constraints}

\iql provides several classes of structural constraints that each feature distinctive syntax features to express structures of increasing complexity.
Those structures are sequences (\ref{sec:sequence-constraints}), trees (\ref{sec:tree-constraints}) and graphs (\ref{sec:graph-constraints}).
They all get explained in more detail in their respective sections, but the syntactic basics for all of them will be defined here.
To simplify the overall \iql grammar, a general syntax exists for the declaration of nodes (and edges).
This general form honors the aspects specific to each of those structure types, but generally over-generates and only some of its features are actually applicable in concrete use cases.
\Cref{gram:node-statement} shows the basic for defining structural constraints in \iql.
More detailed illustrations of the various components (\synt{node}, \synt{quantifier} and \synt{edge}) follow below.

\begin{gram}[\synt{nodeStatement}]
	\label{gram:node-statement}
	\begin{grammar}			
		<nodeStatement> ::= `\{' <nodeStatement> `\}'
		\alt <nodeArrangement>? <node>+
		\alt <element> (`,' <element>)*
		\alt <nodeStatement> `or' <nodeStatement>
		
		<nodeArrangement> ::= `ORDERED' | `ADJACENT'
		
		<memberLabel> ::= <member> `:'
		
		<element> ::= <node> | <node> <edge> <node>
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{nodeStatement}
		\sst
			`\{' <nodeStatement> `\}' \\
			<nodeStatement> `or' <nodeStatement> \\
			\sst \\ `ORDERED' \\ `ADJACENT' \est \srp <node> \\ \erp \\
			<element> \srp \\ `,' <element> \erp
		\est
	\end{rrdiag*}

	\begin{rrdiag*}{element}
		\sst <node> \\ <node> <edge> <node> \est
	\end{rrdiag*}
\end{gram}

\noindent There are four (partly recursive) approaches to express node statements, i.e. grouping, node sequence, element sequence and disjunction. 
The distinction between node and element sequences exists to easily distinguish sequence or tree queries from graph definitions.
Sequence queries do not include hierarchical structural information and as such have no use for edges.
In the syntax used for tree nodes in \iql information about the incoming edge is implicitly available from every nested node and constraints related to outgoing edges are to be attached to the respective child terminals of those edges.
For graphs where no simple association between nodes and edges exists, there is a necessity to have explicit edge declarations available for querying.
As such the \synt{element} rule in \cref{gram:node-statement} is a placeholder that can be filled with either node or edge declarations.

\paragraph{Nodes}
\noindent \iql uses square brackets (\lit{[} and \lit{]}) to mark individual nodes.
\cref{gram:node} gives an overview of the syntax used for defining nodes with all the optional content elements.
\begin{gram}[\synt{node}]
	\label{gram:node}
	\begin{grammar}			
		<node> ::= <quantifier>? `[' <memberLabel>? <constraint>? <nodeStatement>? `]'
		
		<memberLabel> ::= <member> `:'
	\end{grammar}
	\diagsep
	\rrhead{node}
	\noindent\begin{rrfrag}{>-}{...}
		\sst \\ <quantifier> \est `[' 
		\sst \\ <memberLabel> \est
		\sst \\ <constraint> \est
	\end{rrfrag}\\
	\begin{rrfrag}{...}{->}
		\sst \\ <nodeStatement> \est `]'
	\end{rrfrag}\\
\end{gram}
Declaring a node in a structural constraint implicitly marks it as existentially quantified.
Additionally, nodes can be \textbf{explicitly quantified} with an arbitrary combination of universal quantification, negation, explicit quantification, \textit{at-most} (0 to n), \textit{at-least} (n to inf) or bounded range quantification. 
The \cref{gram:quantifier} simplifies the overall rules for \synt{quantifier} to keep it compact.
Albeit being shown here as unrelated to each other, the appearance of the angle brackets (\lit{\textless} and \lit{\textgreater}) before or after the actual quantifier content is restricted to either \textit{both} of them being used (for a proper wrapping, such as \lit{\textless 3..10 \textgreater}) or \textit{none} of them (for plain quantifiers, such as \lit{1|4|ALL}).
\iql allows multiple quantifiers to be separated by the pipe symbol \lit{|} to express disjunction between quantifiers.
This way complex constraints can be defined very neatly, such as the ``all or nothing'' quantification \lit{\keyword{all}|\keyword{not}}.
This quantifier combination ensures that either all targets in a certain context match the node in question, or none does.\footnote{Example: find all sentences that either have no word with more than five characters or all of their words have five or more characters.}

\begin{gram}[\synt{quantifier}]
	\label{gram:quantifier}
	\begin{grammar}			
		<quantifier> ::= <simpleQuantifier> (`|' <simpleQuantifier>)*
		\alt `\textless' <simpleQuantifier> (`|' <simpleQuantifier>)* `\textgreater'
		
		<simpleQuantifier> ::=  (`ALL' | `*')
		\alt (`NOT' | `!')
		\alt <digits> (`+' | `-')?
		\alt <digits> `..' <digits>
	\end{grammar}
	\diagsep	
	\begin{rrdiag*}{quantifier}
		\sst \\ `\textless' \est \srp
		\sst `ALL' \\ `*' \\ `NOT' \\ `!' \\ <digits> `..' <digits> \\ 
		<digits> \sst \\ `+' \\ `-' \est 
		\est
		\\ `|' \erp \sst \\ `\textgreater' \est
	\end{rrdiag*}
\end{gram}

A node's inner content can optionally have an initial \textbf{member label} (identifier with a colon \lit{:} afterwards) to link this node to a previously defined member binding (\ref{sec:bindings}).
Such as binding restricts the type of corpus member that the node can be matched against.
It also provides a point of reference that subsequent constraints (e.g. in the global constraints section, cf. \cref{sec:global-constraints}) can use to access information of the target the node has been matched against.
Note that cross-referencing between nodes from within local constraints (such as in \verb|[$x:][$y: pos!=$x.pos]|) is discouraged\footnote{The reason behind this is that the \ac{iqp} per default is not required to honor the order of nodes defined in a query or the linking relations between them when planning the automaton for evaluation. As such there is no guarantee that node \member{x} will have already been matched against a valid target when the cross-reference constraint inside \member{y} is evaluated. This would cause an error during evaluation time to occur, which in turn will abort the entire search.} and global constraints should be used for this.
This approach guarantees that by the time such cross-reference constraints (or ``joins'', to use database terminology) are evaluated all involved member variables will be assigned preliminary candidates.

Nodes can also optionally define \textbf{local constraints} that must evaluate to \keyword{true} for target item to be considered as result candidate.
Local constraints have full access to properties and annotations of the target item currently being inspected and can take any form described in \cref{sec:constraints}.
Note that it is up to the evaluation engine how to optimize and potentially prune the evaluation process of constraint expressions.
Correct evaluation of a conjunctive local constraints with external function calls \query{[\$x:~func1(\$x) \&\&~func2(\$x) \&\&~func3(\$x)]} must not rely on the premise of any particular function (\texttt{func1}, \texttt{func2} or \texttt{func3}) actually being called at all.
The evaluation semantics of conjunctive Boolean concatenation allow an early determination of the final result as soon as the stable predicate of one of the inner terms evaluating to \keyword{false} is met.
Therefore it is perfectly legal (and in parts expected from an efficient evaluation engine) to not evaluate the calls to \texttt{func2} and \texttt{func3} after \texttt{func1} has already caused the result to remain \keyword{false}.

If a \synt{node} is used within a tree environment, it can also contain a \textbf{nested} \synt{nodeStatement} declaration to define structural constraints on child nodes.
The target item a node is matched against during query evaluation defines the structural context that is then in turn being used for matching the nested \synt{node} instances.
Note that this opens up the entire spectrum of node grouping, disjunctions and arrangement modifiers to define constraints on (sub-)trees.

\paragraph{Edges}
\noindent Edges are a structural element that is available exclusively to \textbf{graph} constraints (\ref{sec:graph-constraints}).
Each edge minimally consists of a source and target node and a type indicator\footnote{Type indicators for empty edges (i.e. edges without an inner constraint or label definition) always consist of three symbols, cf. \cref{gram:edge}} to signal whether the edge is meant to be undirected, uni- or bidirectional and in the case of unidirectional edges which direction between source and target node it takes.

\begin{gram}[\synt{edge}]
	\label{gram:edge}
	\begin{grammar}	
		<edge> ::= `\textless\textminus\textminus' | `\textminus\textminus\textgreater' | `\textless\textminus\textgreater' | `\textminus\textminus\textminus'
		\alt (`\textless\textminus' | `\textminus\textminus') `[' <memberLabel>? <constraint>? `]' (`\textminus\textminus' | `\textminus\textgreater')
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{edge}
		\sst 
		\sst \lit{\textless\textminus} \\ \lit{\textminus\textminus} \est `[' 
		\sst \\ <memberLabel> \est
		\sst \\ <constraint> \est `]' 
		\sst \lit{\textminus\textminus} \\ \lit{\textminus\textgreater} \est \\
		\lit{\textless\textminus\textminus} \\
		\lit{\textminus\textminus\textgreater} \\ 
		\lit{\textless\textminus\textgreater} \\
		\lit{\textminus\textminus\textminus}
		\est
	\end{rrdiag*}
\end{gram}

Optionally, an edge can also be assigned its own member label and/or local constraints.
In that case the type indicator gets split into two separate parts\footnote{When split, each part of a type indicator uses two symbols, which are the respective 2/3 of the original three-symbol indicator.} with a node-like part in the middle to host the edge's label and/or constraints.
Note that the same guidelines for cross-referencing from within local constraints that were mentioned above in the section about nodes, also apply to local edge constraints: 
Correct evaluation of an edge's local constraints must not rely on the availability of cross-referenced external nodes (including the edge's own source and target nodes) or edges.
As usual global constraints should be used to define constraints that link individual elements such as edges to other (external) parts of the payload.
The section about global constraints (\ref{sec:global-constraints}) contains further hints on the optimization the \ac{iqp} implements in order to prevent unnecessary exploration of the search space.

The \textbf{quantification} of edges follows slightly different rules as compared to regular nodes.
Every edge can have \textbf{up to one} explicit quantifier declaration attached to it, either on the source or target node.
If no quantifier is present, the entire edge is by default existentially quantified, otherwise the following rules apply:
The node not bearing any quantifier is existentially quantified (or ``fixed'') and the quantifier on the other node acts as an indicator for the multiplicity of the edge itself.
The following examples illustrate some use cases for quantification on edges:

\begin{Verbatim}
// a node x linked to 3 nodes that match y
[$x:]--> <3>[$y:]
// 3 nodes matching x that are linked to the same node y   
<3>[$x:]-->[$y:]
// node x with no direct link to a node that would match y
[$x:]-->![$y:]
\end{Verbatim}

\noindent Note that edge definitions cannot be chained, so the query ``find x linked to y, linked to z'' must be expressed in two separate edge definitions, one linking \member{x} to \member{y} and one linking \member{y} to \member{z}.
This means that graph constraints (\ref{sec:graph-constraints}) require some redundancy, but the linked section also explains some easy strategies to minimize overhead.

\paragraph{Node Grouping}
\noindent Nodes (or elements) can be grouped together within curly brackets (\lit{\{}~and~\lit{\}}) as defined by the first \synt{nodeStatement} rule in \cref{gram:node-statement}.
This is useful for either restricting the scope of modifiers or directives such as the \keyword{ADJACENT} keyword to only a selected few nodes or when expressing a disjunction.
Note that a group counts as an individual node statement inside the outer scope and as such is subject to order directives defined there.
However, those directives are \textbf{not} automatically \textbf{inherited} to the inner collection of nodes in the group, allowing for expressions such as the following node sequence:
\begin{Verbatim}[samepage=true]
ADJACENT [$x:] {[$a:][$b:]} {[$c:][$d:]} [$y:]
\end{Verbatim}
\noindent This would read as ``Find x immediately followed by a, later followed by b+c, later followed by d+y''.
Note that the adjacency modifier does not apply to the inner sequences a+b and c+d, which are only subject to the implicit order of the sequence declaration.\footnote{An additional \keyword{ORDERED} in each of the groups would make that explicit, but is redundant.}
The concept of node grouping is especially important for the tree (\ref{sec:tree-constraints}) and graph (\ref{sec:graph-constraints}) constraints introduced below, as by default those do not impose an a priori order of nodes.

\paragraph{Node Sequence}
\noindent Nodes usable for sequences (\ref{sec:sequence-constraints}) and trees (\ref{sec:tree-constraints}) are defined in a simple sequence style (second \synt{nodeStatement} rule in \cref{gram:node-statement}).
Instances of \synt{node} in a sequence are defined one after another without special separator symbols.
They may optionally be preceded by a \synt{nodeArrangement} directive to guide the matching progress.
Currently there are only two directives available to specify the node arrangement (\keyword{ORDERED} and \keyword{ADJACENT}), but this might increase in the future, making node grouping a very important tool for defining complex structural compositions.

\paragraph{Element Sequence}
\noindent Similar to node sequences, \synt{element} instances can also be used in a list-style collection (third rule of \synt{nodeStatement} in \cref{gram:node-statement}), but with noticeable differences: 
Element sequences do use a separator symbol (a simple comma \lit{,}) between \synt{element} definitions.
Since \iql does not use keywords to signal the structural type to be expected in a query payload\footnote{An earlier draft made use of \keyword{TREE} and \keyword{GRAPH} keywords to distinguish those types from the basic node sequence, but in an effort to reduce the overall number of keywords (that users had to learn) this approach was dropped.} this approach was necessary to easily detect the type of structure.
It also hints at the second difference, that is, element sequences do not support arrangement modifiers (as \synt{element} instances can be either nodes or edges, with the latter not being suitable for this kind of ordering) and as such can be more intuitively be understood as sets of \synt{element} instances.

\paragraph{Structural Disjunction}
\noindent As the forth option of \synt{nodeStatement} in \cref{gram:node-statement}, the disjunction of entire node statements provides a very powerful tool to express complex queries.
Two node statements are linked with the \keyword{OR} keyword to mark them as ``either or'' cases.
Since this opens up recursion, a complex disjunction may contain more than two node statements in total.
Note that the order of node statements in a disjunction does not imply a specific priority the evaluation engine has to follow.
For illustration, the second example below might match an instance of \verb|[$y:]| first:
\begin{Verbatim}
[$x:] or [$y:]          // x or y
[$x:] or [$y:] or [$z]  // x or y or z
[$x:] or {[$y:][$z]}    // either x alone or a sequence y+z
[$x: {[$y:] or [$z]}]   // tree node x with either y or z as child
// complex nested disjunctions
[$x: [$y: [$z: [$a:] or [$b:]]] or [$z]]
\end{Verbatim}

\subsubsection{Sequence Constraints}
\label{sec:sequence-constraints}

As the most basic form of structural constraints this type is used to match sequences of nodes to \repoLink{\modelsUrl members/item/Item.java}{items} in the target corpus.
Multiple nodes in a sequence declaration are required to match to items in exactly the order they are defined in (but not necessarily adjacent to each other, use the \keyword{ADJACENT} directive in front of a node sequence for that).

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
[]                  // empty node
[pos=="NN"]         // node with local constraint
<2>[$x:]            // node x exactly 2 times       
[$x:]<2-5>[][$y:]   // nodes x & y with 2-5 nodes in between
[$x:] ![$y:]        // node x without any node y following
ADJACENT [$x:][$y:] // node y directly following node x
[$x:] or [$y:]      // disjunction: either x OR y
{[$x:][$y:]} or [$z:] // disjunction: either group x+y OR z
\end{Verbatim}

\paragraph{Sequence Matching}
\noindent Sequence constraints only provide a single dimension for \textit{moving} the query sequence through the search space of the target corpus.
Matching is performed greedily in order of node appearance in the query, following the direction specified by the corpus itself.
If the switch to reverse direction (cf.~\ref{sec:json-ld-switches}) is set, then matching attempts will start from the very end of each matching context (such as a container or structure), but the order of nodes to match will remain the same.
That is, in a node sequence \verb|[$x:][$y:]| the node matched by \member{x} will \textbf{always} be before the node matched by \member{y} according to the original direction of items in the corpus.
Only the direction from which the overall matching attempt will start changes with the respective switch.
This also leads to a very simple and intuitive semantic for the \keyword{FIRST} and \keyword{LAST} modifier keywords: They stay true to their names and limit the returned match to either the first or last, with respect to the current direction.

\paragraph{Special Note:}
\noindent Evaluation of quantified nodes in \iql is done greedily, i.e. the engine will try to match as many instances as possible.
However, since an empty node does only provide the constraint of existential quantification, the above example will find the first occurrence of pair c+d after the initial hit on pair a-b.
An extension of the quantifier syntax or a change in the ``at most'' semantics is on the drawing board, but currently not considered to be implemented (a new keyword \keyword{inf} could potentially be used with the ``at most'' quantifier to create a hint to greedily expand empty nodes to the total limit instead of a ``first hit'' eager strategy, such as \lit{<inf->}).

Empty nodes with quantifiers can be used as proxies to model distance constraints, as seen in above examples.
Since the \keyword{ADJACENT} directive changes the behavior of an entire node sequence, some creativity can be necessary to achieve mixed cases, such as \textit{``find an adjacent pair a+b that is later followed by another adjacent pair c+d''}.
Possible (and simple) solutions for this query could be the following:
\begin{Verbatim}[samepage=true]
ADJACENT [$a:][$b:] <0+>[] [$c:][$d:]
{ADJACENT [$a:][$b:]} {ADJACENT [$c:][$d:]}
\end{Verbatim}

\subsubsection{Tree Constraints}
\label{sec:tree-constraints}

Located between mere sequences (\ref{sec:sequence-constraints}) and graphs (\ref{sec:graph-constraints}) this type of structural constraints is meant to target tree structures, such as (but not limited to) syntax trees, coreference structures, discourse, etc.
To simplify query syntax, \iql uses a similar approach as the original ICARUS project, which in turn took inspiration from PML-TQ:
To signal parent-child relations, child nodes are nested within their respective parent, effectively making each node yet another scope for a sequence of child nodes.
Contrary to bare sequence constraints (\ref{sec:sequence-constraints}) the order of (child) nodes to be matched in the corpus is \textbf{not} implicitly defined by the order of constraint nodes!
Instead, the \keyword{ORDERED} or \keyword{ADJACENT} keywords need to be used explicitly to signal that a specific kind of order should be honored.
Apart from this little addendum tree constraints behave basically the same as nested sequence constraints:
They can be individually quantified or existentially negated, as well as grouped and linked via the \keyword{OR} keyword to expression disjunctions.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
[[]]              // anonymous nesting of nodes
[$x: [$y:]]       // nesting of node y inside x
[[$x:] [$y:]]     // nesting of siblings x and y
[$x: [$y: [$z:]]] // deep nesting chain 
[$x: <2->[$y:]]   // at most 2 y nested inside x
[$x: ![$y:]]      // node x without any child matching y

// internal disjunction
[[$x:] or [$y:] or {[$z: <4+>[]]}]
\end{Verbatim}

\paragraph{Tree Matching}

\noindent As opposed to sequences (\ref{sec:sequence-constraints}), trees (and subsequently also graphs, cf.~\ref{sec:graph-constraints}) offer an additional dimension of matching freedom over the bare iteration of items in a container or structure to be matched.
This requires further specification of the matching process to guarantee consistent results and define basic expectations.
Below explanations are primarily intended to specify the behavior in the presence of limiting modifiers (\keyword{FIRST}, \keyword{LAST}, \keyword{ANY}) in the payload, but are also of interest for the expected order of returned matches if no limiting modifiers are defined.

\begin{wrapfigure}[12]{L}{0pt} %not sure what produced the 
	\centering
\begin{forest}
	for tree={
		if n children=0{
			tier=terminal
		}{},
	}
	[Root 
		[A\textsubscript{1} [1]] 
		[A\textsubscript{2} 
			[\textcolor{darkgreen}{X\textsubscript{1}} 
				[A\textsubscript{3} [2]]  
				[\textcolor{darkgreen}{Y\textsubscript{1}}
					[A\textsubscript{4} [3]]
					[A\textsubscript{5} [4]] 
				] 
				[\textcolor{darkred}{Y\textsubscript{2}} [5]] 
			]
		]		
		[\textcolor{darkred}{X\textsubscript{2}} 
			[A\textsubscript{6} [6]]  
			[\textcolor{darkred}{Y\textsubscript{3}} [7]] 
		] 
	]
\end{forest}
\caption{\label{fig:tree-matching} Example tree with highlighted hits for the simple tree query \query{[\$x:~[\$y:]]}.}
\end{wrapfigure}

Consider a simple tree query \query{[\$x:~[\$y:]]} where x and y are bound nodes with individual constraints.
The nodes X\textsubscript{n} or Y\textsubscript{n} in the example tree (\cref{fig:tree-matching}) then denote the n-th node that match the constraints of query nodes x and y, respectively.
The nodes A\textsubscript{1} to A\textsubscript{6} are placeholders for nodes that match neither \texttt{x} nor \texttt{y}.

The tree contains 3 possible matches for the query, specifically the pairs \texttt{\{X\textsubscript{1},Y\textsubscript{1}\}}, \texttt{\{X\textsubscript{1},Y\textsubscript{2}\}} and \texttt{\{X\textsubscript{2},Y\textsubscript{2}\}}.
\todo{expand on the order of matches}

\noindent\query{[Root 
	[A\textsubscript{1}] 
	[A\textsubscript{2} 
	[\textcolor{darkgreen}{X\textsubscript{1}} 
	[A\textsubscript{3}]  
	[\textcolor{darkgreen}{Y\textsubscript{1}}
	[A\textsubscript{4}]
	[A\textsubscript{5}]] 
	[\textcolor{darkred}{Y\textsubscript{2}}]]]		
	[\textcolor{darkred}{X\textsubscript{2}} 
	[A\textsubscript{6}]  
	[\textcolor{darkred}{Y\textsubscript{3}}]]]
}

\subsubsection{Graph Constraints}
\label{sec:graph-constraints}

\todo[inline]{content, explain node and edge composition, mention referencing as a strategy to minimize edge declaration overhead, etc...}

\subsubsection{Global Constraints}
\label{sec:global-constraints}

Global constraints can be any basic constraint \cref{sec:constraints} and follow after the main section of structural constraints, indicated by the \keyword{HAVING} keyword (cf. \cref{gram:selection}).

\paragraph{Evaluation Priorities}
\noindent If global constraints are present, the evaluation process changes to a two-stage strategy:
Matchers for the associated structural constraints produce preliminary result candidates and the global constraints are then evaluated for each such candidate.
This makes global constraints both very powerful as they have access to more information compared to regular (internal or local) constraints (e.g. they already \textit{know} that all local constraints evaluated to \keyword{true} and the exact candidates produced for structural constraints) and also very critical when it comes to performance.
It can be very tempting to construct queries such as the following one (bindings section omitted) that only matches when \member{y} is the last child of \member{x}:
\begin{Verbatim}[samepage=true]
FIND [$x: [$y:]] HAVING $x.indexOf($y) == $x.size-1
\end{Verbatim}
This will cause the structural matcher to potentially propose \textbf{all} children of \member{x} as candidates to be processed by the global constraints section.
Subsequently, for a node of size $N$ this will produce $N-1$ candidates that are bound to fail the global constraint check.
\cref{sec:utility} lists several families of utility markers and functions that can be used to signal the evaluation engine that certain local constraints are to be treated as special filters.
With the use of those utility markers, above query looks like the following and will be vastly more efficient to evaluate:
\begin{Verbatim}[samepage=true]
FIND [$x: [$y: isLast]]
\end{Verbatim}
Similarly global constraints are not the place to perform filtering on general properties of the current \ac{uoi}, such as sentence length (use the \keyword{FILTER BY} expression for that, cf. \cref{sec:filter-constraints}).

\paragraph{Constraint Hoisting}
Per default, global constraints are second-class constraints, that are only consulted, once the structural and local constraints in the other sections of a query payload have been evaluated.
This provides them with a lot more decision power and available information, but also can lead to rather inefficient evaluation scenarios.
Consider a query \query{FIND~[\$x:~[\$y:~[\$z]]] HAVING \$x.pos!=\$y.pos} that looks for nested nodes \member{x}, \member{y} and \member{z} where in addition to local constraints the nodes \member{x} and \member{y} are required to have different part-pf-speech tags.
With the default two-stage evaluation process described above this would result in a serious overhead when evaluating a target tree: 
For every successful match of \query{[\$x:~[\$y:]]} the engine would continue to look for children of \member{y} matching \member{z}, regardless of \member{x} and \member{y} satisfying the global constraint.

Through a optimization technique dubbed \textit{constraint hoisting} the \ac{iqp} will try to work around this performance issue and attach global constraints to the nodes in the (tree) automaton that matches a certain part of the query.
In the example above the matcher would evaluate the global constraint \query{\$x.pos!=\$y.pos} as soon as it successfully identified candidates for \member{x} and \member{y}, thereby reducing the overhead of searching for potential candidates for \member{z} that would ultimately fail due to \member{x} and \member{y} not satisfying the global constraint.

Note that only very specific global constraints can successfully be hoisted! 
\todo{list properties required for hoisting and mention hoisting of constraint fragments, since IQL splits boolean expressions into fragments}

\subsection{Result Processing}
\label{sec:result-processing}

There be dragons\dots

(Content of the result section will be added as \iql evolves)

\section{Utility Markers \& Functions}
\label{sec:utility}

The following utility features are provided by the \ac{iqp} but are \textbf{not} part of the core specification. 
As such it is possible for engine extensions to override them, change their behavior or completely remove them if desired.
They are listed here as per default they all are available and provide valuable improvements for performance and usability.

\subsection{Position Markers}
\label{sec:position-markers}

Every node (\ref{sec:structural-constraints}) in a query has an implicit \repoLink{\modelsUrl /members/container/Container.java}{Container} or \repoLink{/members/structure/Structure.java}{Structure} context that it is hosted  or contained in.\footnote{The \ac{icmf} specifies that each item can only be hosted (or more accurately \textit{owned}) by a single container or derived object, but be contained within an arbitrary number of additional containers or structures.}
\iql offers a variety of predefined helper functions  to exploit this fact and to optimize queries.
\cref{tab:position-markers} lists the functions currently available, their arguments and matching conditions.
Note that legal arguments for a node that occurs in a container of size $N$ reside in the closed integer interval $[1..N]$ for regular index values and $[-N..-1]$ for reverse indices (see below).\footnote{This is in contrast to the 0-based access of array or list elements in \iql.}
The syntax for providing arguments follows the normal rules for method invocations in \iql \ref{sec:method-invocations}, e.g. \query{isOutside(4, 12)}.
Arguments can be provided as literals, which is is the preferred way, or as any other kind of expression that evaluates to the necessary type (or can be converted, depending on the query configuration).
It is not possible to access properties from the node itself for which the marker is defined, as position markers are evaluated \textbf{before} the corresponding nodes are matched and subsequently any such attempts will result in an error during query evaluation.
However, globally accessible information or any data provided by surrounding containers or structures can be used to specify marker arguments.\footnote{For example, a node could be defined to be in first position for short sentences and in last position for long ones.}

\begin{table}[ht]\centering
\begin{tabular}{|p{0.17\textwidth}|p{0.14\textwidth}|p{0.60\textwidth}|}
	\hline 
	\textbf{Label} & \textbf{Arguments} & \textbf{Matching Condition} \\ 
	\hline 
	\hline  
	isFirst & - & Node is the first in its context ($index = 1$). \\ 
	\hline 
	isLast & - & Node is the last in its context ($index = N$). \\  
	\hline 
	isAfter & int & Node occurs after designated position ($index > arg$). Legal values are: $1 \leq arg < N$. \\  
	\hline 
	isBefore & int & Node occurs before designated position ($index < arg$). Legal values are: $1 < arg \leq N$. \\  
	\hline 
	isInside & int, int & Node occurs inside designated interval ($arg_1 \leq index \leq arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$. \\  
	\hline 
	isOutside & int, int & Node occurs outside designated interval ($index < arg_1$ and $index>arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$. \\  
	\hline 
	isAt & int & Node occurs at specific position ($index = arg$). Legal values are: $1 \leq arg \leq N$. \\  
	\hline 
	isNotAt & int & Node occurs at any position except the designated one ($index \neq arg$). Legal values are: $1 \leq arg \leq N$. \\  
	\hline 
\end{tabular}
\caption{Position markers provided by the default evaluation engine for \iql. The conditions in the last column assume a container of size \textit{N} as context. If a marker function takes arguments, they appear in the conditions as $arg$ for the sole argument or $arg_i$ for the $i$-th argument list, with $arg_1$ being the first argument.}
\label{tab:position-markers}
\end{table} 

\paragraph{Direction}
\noindent Position markers follow the direction specified for the whole query, same as all structural constraints (\ref{sec:structural-constraints}).
This means they are also subject to reversing via switch (\ref{sec:json-ld-switches}) the order in which \acp{uoi} are traversed.
Note that this effectively reverses the semantics of all the markers listed in \cref{tab:position-markers} (see below section about negation for examples on how construct markers that cover the inverse index interval).
For instance \query{isFirst} will target the last item when traversing a container in the original direction.
Users need to keep this in mind when mixing position markers with switches that influence the order of traversal during node matching.

\paragraph{Negation}
\noindent Position markers cannot be negated when used in a constraint expression.\footnote{Depending on the query configuration doing so would either fail the evaluation process with an error or silently ignore the issue, potentially producing invalid results.}
For every function/marker in \cref{tab:position-markers} there exists a complement that can be used to easily express the negated condition.
For instance \query{isBefore(n)} can be negated into \query{isAfter(n-1)}, but the engine will not perform this conversion and it up to the user to properly provide the intended negated form.
Trying to negate a position marker inside structural constraints will result in an error during the preprocessing of the query payload.

\paragraph{Reverse Indices}
\noindent Any position marker that takes at least one argument also supports negative values that are treated as reverse indices, starting from the end of the surrounding container's size.
This follows the same semantics as the index scheme for arrays or lists (\ref{sec:list-access}).
Note that certain position markers with interval arguments (such as \query{inBetween($arg_1$,~$arg_2$)}) still require actual interval boundaries to be in the proper order (generally $arg_1 \leq arg_2$).

\paragraph{Relative Indices}
\noindent Per default all the position markers that take argument expect them to be integer values for explicit designation of the desired index or index range.
This means that any other type of argument will be automatically converted to an integer value if the query configuration permits it.
However, if the associated switch (\ref{sec:json-ld-switches}) is active\footnote{This switch is off by default as it interferes with the automatic type conversion of arguments. If it is active, arguments must explicitly be cast if not already an integer or floating-point number. If the switch is not active, any floating-point argument will be cast to an integer (typically 0 if any of the arguments are intended to be reverse indices).}, position markers can use relative arguments in the form of floating-point numbers.
Relative indices are expected to be in the open interval $(0..1)$ (or $(-1..0)$ for negative reverse indices) and are treated as percentages of the total size of the surrounding container.
The following examples illustrate this approach (assume the markers are used inside a token node that is directly hosted within a sentence):
\begin{Verbatim}
// the token can only occur in the first half of the sentence
isBefore(0.5)

// the token must occur after the first 20% and before the last 80%
isBetween(0.2, 0.8)
\end{Verbatim}
The actual index values to be used for determining the legal position of the node are calculated by multiplying the context's size attribute (e.g. the length of the surrounding sentence) with the marker's relative argument and then rounding down the result to the nearest integer.
It is easily possible to define the same position marker with relative indices in both normal and reverse form.
For instance, \query{isBefore(0.8)} and \query{isBefore(-0.2)} both describe the same 80\% interval.
As a general rule, relative indices should only be used with regular (positive) arguments.

\paragraph{Marker Stacking}
\noindent Position markers generally may \textbf{only} be used as top-level terms in a constraint expression.
\iql allows multiple position markers to occur in the same constraint expression, with the following condition:
When the expression is viewed in conjunctive normal form, positional markers may not be mixed with non-marker terms inside a single clause.
Multiple marker-only clauses are allowed however.
\begin{Verbatim}
// legal use cases
[isLast]
[pos!="NN" && isBefore(10)]
[pos!="NN" && (isBefore(10) || isAfter(24))]
[pos!="NN" && isNotAt(5) && (isBefore(10) || isAfter(24))]

// illegal use of position markers (see rules above)
[pos!="NN" || isLast]
// above constraint must be expressed via node disjunction
{[pos!="NN"] or [isLast]}
\end{Verbatim}
The reasons for this limitation in stacking position markers stems from the underlying interval arithmetic.
Each positional marker effectively describes a non-empty interval of possible index values for the node.
Conjunction of markers results in the intersection of their intervals, possibly creating an empty set, which will render the node constraint impossible to satisfy.
Disjunction of markers on the other hand creates a union of their intervals, either joining them if they overlap or creating a set of disjoint intervals that denotes a discontinuous collection of legal values.
The final result is a fixed\footnote{Fixed in the sense that it only depends on the overall size of the surrounding container.} collection of index values that can be iterated to check for potential result candidates.
In the absence of any kind of positional marker this default index set to be traversed is the complete interval $[1..N]$ for a host container of size $N$.
In case of disjunction between a positional marker and a non-marker term, this would render the marker's filter function useless.\footnote{Joining the complete interval $[1..N]$ with any sub-interval does not reduce the number of indices to be traversed}

\paragraph{Markers in Global Constraints}
\noindent Global constraints (\ref{sec:global-constraints}) have access to an extended version of the ``local'' position markers that acts as a general predicate for items (and additional index arguments, depending on the marker).
So for example \query{isLast(\$x)} is the method-equivalent to the local marker \query{[\$x: isLast]}.
Note that there is no performance benefit by using those methods in global constraints, as actual position markers are only recognized within structural constraints.
The version for global constraints merely serves as syntactic sugar.
However, since those methods are not subject to the same limitations as mentioned int the section about stacking above, they can be used freely inside local constraints (both in nested and disjunctive expressions).

\subsection{Tree Markers}
\label{sec:tree-markers}

While the basic positional markers described in \cref{sec:position-markers} limit a node's overall position in the surrounding container, tree markers work on the hierarchical properties of tree structures.
As such they define legal positions of a node within its parent's list of children.
All tree markers are subject to the same rules as position markers regarding negation, direction, relative and reverse indices, as well as stacking.
Note however, that the default order for traversing child nodes in a tree does not necessarily\footnote{The \ac{icmf} does however strongly encourage tree structures to order children according to their begin-offsets if it does not interfere with their intended semantics.} reflect the actual order of the child nodes position when projected onto the underlying foundation layer.
It can therefore make sense to define additional precedence constraints via global constraints if needed.

\begin{table}[ht]\centering
	\begin{tabular}{|p{0.17\textwidth}|p{0.14\textwidth}|p{0.60\textwidth}|}
		\hline 
		\textbf{Label} & \textbf{Arguments} & \textbf{Matching Condition} \\ 
		\hline 
		\hline  
		isFirstChild & - & Node is the first child of its parent ($childIndex = 1$). \\ 
		\hline 
		isLastChild & - & Node is the last child of its parent ($childIndex = N-1$). \\  
		\hline 
		isChildAfter & int & Node occurs as child after designated position ($childIndex > arg$). Legal values are: $1 \leq arg < N$. \\  
		\hline 
		isChildBefore & int & Node occurs as child before designated position ($childIndex < arg$). Legal values are: $1 < arg \leq N$. \\  
		\hline 
		isChildInside & int, int & Node occurs as child inside designated interval ($arg_1 \leq childIndex \leq arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$. \\  
		\hline 
		isChildOutside & int, int & Node occurs as child outside designated interval ($childIndex < arg_1$ and $childIndex>arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$. \\  
		\hline 
		isChildAt & int & Node occurs as child at specific position ($childIndex = arg$). Legal values are: $1 \leq arg \leq N$. \\  
		\hline 
		isChildNotAt & int & Node occurs as child at any position except the designated one ($childIndex \neq arg$). Legal values are: $1 \leq arg \leq N$. \\  
		\hline 
	\end{tabular}
	\caption{Positional markers for trees provided by the default evaluation engine for \iql. The conditions in the last column assume a parent node with \textit{N} children as context and $childIndex$ being the desired position of the node within its parent's list of children. If a marker function takes arguments, they appear in the conditions as $arg$ for the sole argument or $arg_i$ for the $i$-th argument list, with $arg_1$ being the first argument.}
	\label{tab:tree-position-markers}
\end{table}

\paragraph{Hierarchy Markers}
Apart from the horizontal domain described above, tree markers also cover the hierarchical aspect of tree structures.
A series of additional markers is available to specify a node's vertical location in the tree, as shown in \cref{tab:tree-hierarchy-markers}.
These markers inherit all the rules of general tree markers, except that they cannot be used with relative indices.%\footnote{The reason is that all the hierarchy-related methods in \ac{icmf} are optional and as such a tree object cannot be expected to provide ready-to-use information about its depths or the heights of individual subtrees. Subsequently the \ac{iqp} would have to analyze a tree first before being able to construct an efficient matcher for it, which defeats the purpose of}

\begin{table}[ht]\centering
\begin{tabular}{|p{0.21\textwidth}|p{0.14\textwidth}|p{0.56\textwidth}|}
	\hline 
	\textbf{Label} & \textbf{Arguments} & \textbf{Matching Condition} \\ 
	\hline 
	\hline  
	isRoot & - & Node is a designated root in the structure. \\ 
	\hline 
	isLeaf & - & Node is a leaf, i.e. it has no children. \\  
	\hline 
	isNoLeaf & - & Node is not a leaf, i.e. it has at least one child. \\  
	\hline 
	isIntermediate & - & Node is neither a designated root nor a leaf. \\  
	\hline 
	isGeneration & int & Node is a member of the $arg$-th generation of the parent node. Note that only values of $arg \geq 2$ make any sense, as per default parent-child nesting in tree constraints implies membership in the 1\textsuperscript{st} generation. \\  
	\hline
	isNotGeneration & int & Node is nested arbitrarily deep in its parent, but not in the designated generation. \\  
	\hline  
	isGenerationAfter & int & Node is nested at least $arg+1$ generations deep in its parent. \\  
	\hline 
	isGenerationBefore & int & Node is nested no more than $arg-1$ generations deep in its parent. \\  
	\hline 
	isAnyGeneration & - & Node is nested arbitrarily deep in its parent. This is the equivalent of a full transitive closure over the tree dominance relation between parent and child nodes. \\  
	\hline 
\end{tabular}
\caption{Additional markers for hierarchical properties in tree structures. Note that ``parent'' in the matching conditions refers to the node in a target tree that has been matched by the original node's parent.}
\label{tab:tree-hierarchy-markers}
\end{table}

All the additional hierarchical markers in \cref{tab:tree-hierarchy-markers} operate purely on the vertical axis within a tree structure.
Four of them (\query{isRoot}, \query{isLeaf}, \query{isNoLeaf} and \query{isIntermediate}) are based on the presence or absence of child nodes and/or a parent.
The remaining markers use the concept of \textit{generations}\footnote{Also often called ``levels'' in tree structures.} in the tree.
Given a tree structure $T$ and the root node $R$, the set of nodes in $T$ are partitioned into disjoint sets of generations $G_0$ to $G_n$ where $n$ is the height of $T$ and $G_i$ is the set of nodes belonging to the $i$-th generation, that is all the nodes with a depth of $i$ (i.e. path distance $i$ to $R$). 
Note that $R$ is the only member in $G_0$ and $G_n$ can only contain leaf nodes.

If no generation markers are used within a node constraint and the node is nested, a direct parent-child relation is assumed, which is equivalent ti \query{isGeneration(1)}.
Nodes that represent the root of a tree query can also use generation-based markers to indicate where in a prospective target tree the associated item should be located.
Regular tree hierarchy markers can also be combined with generation-based markers to  further specify the location within a tree.
For instance, \query{[\$x: [isGenerationAfter(2) \&\& isNoLeaf]]} will match any node that is nested at least 3 steps deep within \member{x} but ignores leaves.
The \query{isRoot} marker however cannot be combined with any other hierarchy-related markers, as only designated roots in the target structure can match it and the only sensible combinations would be with normal (horizontal) position markers (\ref{sec:position-markers}).

\paragraph{Evaluation Performance}
\noindent Tree-related methods for fetching hierarchical information (such as height and depth of a node) are optional in \ac{icmf}.
As a result the \ac{iqp} 

\todo{generation concept, explain that some tree methods in ICMF are optional, as such reverse indices can be inefficient}

\subsection{Tree Functions}
\label{sec:tree-functions}

\begin{table}[ht]\centering
	\begin{tabular}{|p{0.20\textwidth}|p{0.25\textwidth}|p{0.46\textwidth}|}
		\hline 
		\textbf{Label} & \textbf{Argument Types} & \textbf{Result Type} \\ 
		\hline 
		\hline  
		ancestor & array of nodes & node \\ 
		\hline 
	\end{tabular}
	\caption{Utility functions for advanced tree matching. Primarily these functions are intended to complement the top-down tree matching strategy employed by the \ac{iqp} with bottom-up evaluation.}
	\label{tab:tree-functions}
\end{table}

\subsection{Graph Functions}
\label{sec:graph-functions}

\begin{appendices}
\section{Extended Grammar Diagrams}


\begin{gram*}
	\label{gram:expression}
	\begin{rrdiag*}{expression}
		\sst
		`NULL' \\
		`TRUE' \\
		`FALSE' \\
		<floatingPointLiteral> \\
		<integerLiteral> \\
		<stringLiteral> \\
		\sst \\ <type> `[]' \est `{' \sst \\ \srp <expression> \\ `,'\erp \est `}' \\
		\sst \\ <identifier> `::' \\ `@' \\ `\$' \est <identifier> \\
		<expression> `.' <identifier> \\ %path
		<expression> `(' \srp <expression> \\ `,' \erp `)' \\ %method invocation
		<expression> `[' \srp <index> \\ `,' \erp `]' \\ %list access
		<expression> `{' \srp <expression> \\  `,' \erp `}' \\ %annotation access
		`(' <type> `)' <expression> \\ %cast
		`(' <expression> `)' \\ %wrapping
		\sst `NOT' \\ `!' \\ `\textminus' \\ `\texttildelow' \est <expression> \\ %unary op
		<expression> \sst 
		\tok{`*' | `/' | `\%' } \\ 
		\tok{`+' | `\textminus'} \\ 
		\tok{`\verb|<<|' | `\verb|>>|' | `|' | `\&' | `\textasciicircum'} \\ 
		\tok{`\textless' | `\textless=' | `\textgreater' | `\textgreater='} \\ 
		\tok{`=\texttildelow' | `!\texttildelow' | `=\#' | `!\#'} \\ 
		\tok{`==' | `!='} \\ 
		\tok{`AND' | `\&\&' | `OR' | `||'} 
		\est <expression> \\ %binary op
		<expression> `AS' (<member> | <variable>) \\ %assignment op for later
		<expression> \sst \\ `ALL' \\ `*' \est \sst \\ `NOT' \\ `!' \est `IN' <expression> \\ %set predicate
		<expression> `?' <expression> `:' <expression> \\ %ternary op
		<loopExpression> % loop
		\est
	\end{rrdiag*}
\end{gram*}

\end{appendices}
\end{document}