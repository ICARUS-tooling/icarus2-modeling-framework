%
% File specification.tex
%

\documentclass[11pt,a4paper,portrait]{article}

\usepackage[hscale=0.75,vscale=0.8]{geometry}

\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage{fontspec}
\usepackage{latexsym}
\usepackage{url}
\usepackage{natbib}
\usepackage{multicol}
\usepackage{xstring}
\usepackage{xspace}
\usepackage{todonotes}
\usepackage{bera}% optional: just to have a nice mono-spaced font
\usepackage{listings}
\usepackage{enumitem}
\usepackage{cprotect}
\usepackage{xcolor}
\usepackage{syntax}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage[capitalise]{cleveref} % must be loaded after hyperref!
\usepackage{forest}

\usepackage{acro}

\DeclareAcronym{cql}{short = CQL, long = corpus query language}
\DeclareAcronym{cqs}{short = CQS, long = corpus query system}
\DeclareAcronym{rdbms}{short = RDBMS, long = relational database management system}
\DeclareAcronym{rdb}{short = RDB, long = relational database}
\DeclareAcronym{iql}{short = IQL, long = ICARUS2 Query Language}
\DeclareAcronym{icmf}{short = ICMF, long = ICARUS2 Corpus Modeling Framework}
\DeclareAcronym{iqp}{short = IQP, long = ICARUS2 Query Processor}
\DeclareAcronym{kwic}{short = KWIC, long = keyword-in-context}
\DeclareAcronym{uoi}{short = UoI, long = unit-of-interest, long-plural-form = units-of-interest}

\newfontfamily\DejaSans{DejaVu Sans}

\definecolor{eclipseStrings}{RGB}{42,0.0,255}
\definecolor{eclipseKeywords}{RGB}{127,0,85}
\colorlet{numb}{magenta!60!black}

\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{darkred}{rgb}{0.8, 0.0, 0.0}

\newcommand{\compresslist}{ % Define a command to reduce spacing within itemize/enumerate environments, this is used right after \begin{itemize} or \begin{enumerate}
	\setlength{\topsep}{0pt}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
}

\newcommand{\icarus}{ICARUS2\xspace}
\newcommand{\iql}{IQL\xspace}

\newcommand{\keyword}[1]{\textcolor{purple}{\texttt{#1}}}

\newcommand{\member}[1]{\texttt{#1}}

% constants
\newcommand{\iqlns}{iql:}
\newcommand{\repoUrl}{https://github.com/ICARUS-tooling/icarus2-modeling-framework/blob/dev/}
\newcommand{\manifestsUrl}{\repoUrl icarus2-manifest-api/src/main/java/de/ims/icarus2/model/manifest/api/}
\newcommand{\modelsUrl}{\repoUrl icarus2-model-api/src/main/java/de/ims/icarus2/model/api/}

\newcommand{\repoLink}[2]{\href{#1}{#2}}

\newcommand{\iqlType}[1]{\texttt{\iqlns#1}}
\newcommand{\iqlBaseType}[1]{\texttt{\textless#1\textgreater}}

\newcommand{\desc}[1]{\noindent#1\newline\medskip}
\newcommand{\extends}[2]{\noindent\textbf{Extends #1(#2).}\newline\medskip}

\newenvironment{attributes}[1]{
\noindent\textbf{Attributes of #1:}\newline\medskip
\begin{tabular}{|p{0.3\textwidth}|p{0.20\textwidth}|p{0.20\textwidth}|p{0.17\textwidth}|}
	\hline
	\textbf{Attribute} & \textbf{Type} & \textbf{Required} & \textbf{Default} \\ 
	\hline
	\hline
}{
\end{tabular}
}

\newcommand{\attribute}[4]{
	#1 & #2 & #3 & #4 \\
	\hline
}

\newenvironment{elements}[1]{
\noindent\textbf{Nested Elements of #1:}\newline\medskip
\begin{tabular}{|p{0.3\textwidth}|p{0.42\textwidth}|p{0.17\textwidth}|}
	\hline
	\textbf{Element} & \textbf{Type} & \textbf{Required} \\ 
	\hline
	\hline
}{
\end{tabular}
}

\newcommand{\element}[3]{
#1 & #2 & #3 \\
\hline
}

%\counterwithin{paragraph}{subsubsection}

\lstdefinelanguage{json}{
	basicstyle=\normalfont\ttfamily,
	commentstyle=\color{eclipseStrings}, % style of comment
	stringstyle=\color{eclipseKeywords}, % style of strings
	numbers=left,
	numberstyle=\scriptsize,
	stepnumber=1,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
%	backgroundcolor=\color{gray}, %only if you like
	string=[s]{"}{"},
	comment=[l]{:\ "},
	morecomment=[l]{:"},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
}

\title{ICARUS2 Query Language Specification}

\author{Markus Gärtner}

\date{2020}

\begin{document}

\maketitle

\tableofcontents

\section{Query Structure}
\label{sec:query-structure}

Queries in \iql are designed to be self-contained with logical sections for specifying all the information required to determine the target of a query and its granularity, resolve additional dependencies such as extensions or scripts, link and validate constraints to parts of the target corpus or corpora and finally optional pre- and post-processing steps.
To achieve this complex task \iql embeds a keyword-based syntax for the query payload within a JSON-LD structure to drive declaration of all the aforementioned information. 
As a side effect queries can become quite verbose and potentially cumbersome to define manually. 
As a countermeasure the overall structure of a query is composed of blocks that can be glued together incrementally and that make it very easy for an application built on top of it to provision boilerplate query code based on settings or a GUI so that the user only needs to type the actual constraints used in the query (the so called \textit{query payload}). 
This document lists the basic building blocks of queries and their compositions.

\begin{lstlisting}[language=json]
{
  "@context" : "http://www.ims.uni-stuttgart.de/icarus/jsonld/iql/query" 
}
\end{lstlisting}


\section{JSON-LD Elements}
\label{sec:elements}

\todo{say something about the namespace and general iql: prefixing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     BINDING
\subsection{Binding}
\label{sec:json-ld-binding}
%\begin{itemize}
%	\item distinct
%	\item target
%	\item edges
%	\item members
%\end{itemize}
\desc{A binding associates a collection of member variables (\ref{sec:variables-references}) with the content of a specific \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} or derived layer type.}
\begin{attributes}{\iqlType{Binding}}
	\attribute{distinct}{Boolean}{no}{false}
	\attribute{edges}{Boolean}{no}{false}
	\attribute{target}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{distinct}] Enforces that the bound member references in this binding do \textbf{not} match the same target items during evaluation. Depending on the structural constraints used in the query, this setting might be redundant (e.g. when using the member references as identifiers for tree nodes who already are structurally distinct), but can still be used to make that fact explicit. 
	\item[\iqlType{edges}] Signals that the member labels are to be used for \repoLink{\modelsUrl members/item/Edge.java}{edges} within a \repoLink{\modelsUrl members/structure/Structure.java}{structure}.
	\item[\iqlType{target}] The name or alias of the layer to whose content the member variables should be bound.
\end{description}
\begin{elements}{\iqlType{Binding}}
	\element{members}{array of \iqlType{Reference} (\ref{sec:json-ld-reference})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{members}] Non-empty collection of member references that are bound to the target layer's content. Every such instance of \iqlType{Reference} (\ref{sec:json-ld-reference}) must be unique within the surrounding \iqlType{Payload} (\ref{sec:json-ld-payload}).
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     CONSTRAINT
\subsection{Constraint}
\label{sec:json-ld-constraint}
%\begin{itemize}
%	\item id
%	\item solved
%	\item solvedAs
%\end{itemize}
\desc{Constraints represent the actual content filtering of every query.}
\begin{attributes}{\iqlBaseType{Constraint}}
	\attribute{id}{string}{yes}{}
	\attribute{solved}{Boolean}{no}{false}
	\attribute{solvedAs}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the constraint within the entire query.
	\item[\iqlType{solved}] Hint for the evaluation engine that this constraint has already been solved, either by a back-end implementation or as a result of (partial) query evaluation by the engine itself.
	\item[\iqlType{solvedAs}] Specifies to what Boolean value (\texttt{true} or \texttt{false}) the constraint has been evaluated.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PREDICATE
\subsubsection{Predicate}
\label{sec:json-ld-predicate}
%\begin{itemize}
%	\item expression
%\end{itemize}
\desc{Wraps a Boolean \iqlType{Expression} into an atomic constraint element that represents the smallest unit of evaluation for the top-level evaluation engine.}
\extends{\iqlBaseType{Constraint}}{\ref{sec:json-ld-constraint}}
\begin{elements}{\iqlType{Predicate}}
	\element{expression}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{expression}] The actual expression to be evaluated to a Boolean result. Note that typically this expression \textbf{cannot} be composed of directly nested Boolean conjunctions or disjunctions, as the engine will have parsed those into \iqlType{Term} (\ref{sec:json-ld-term}) objects already during the first processing phase.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     TERM
\subsubsection{Term}
\label{sec:json-ld-term}
%\begin{itemize}
%	\item items
%	\item operation
%\end{itemize}
\desc{A collection of constraints with a logical connective.}
\extends{\iqlBaseType{Constraint}}{\ref{sec:json-ld-constraint}}
\begin{attributes}{\iqlType{Term}}
	\attribute{operation}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{operation}] The Boolean connective to be applied to all the constraint items. Legal values are the strings ``conjunction'' or ``disjunction''.
\end{description}
\begin{elements}{\iqlType{Term}}
\element{items}{array of \iqlType{Constraint} (\ref{sec:json-ld-constraint})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{items}] The constraints which are to be combined by the specified \iqlType{operation}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Corpus}
\label{sec:json-ld-corpus}
%\begin{itemize}
%\item id
%\item name
%\end{itemize}
\desc{Top-level entry point for querying a single stream.}
\begin{attributes}{\iqlType{Corpus}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the corpus within the entire query.
	\item[\iqlType{name}] The identifier used by the query engine's \repoLink{\manifestsUrl ManifestRegistry.java}{manifest registry} for the corpus.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     DATA
\subsection{Data}
\label{sec:json-ld-data}
%\begin{itemize}
%\item id
%\item name
%\item content
%\item codec
%\item checksum
%\item checksumType
%\end{itemize}
\desc{Allows to embed binary data in the query and make it usable from within constraint expressions via a designated reference.}
\begin{attributes}{\iqlType{Data}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{content}{string}{yes}{}
	\attribute{codec}{string}{no}{hex}
	\attribute{checksum}{string}{no}{}
	\attribute{checksumType}{enum}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the corpus within the entire query.
	\item[\iqlType{name}] The identifier used for the expression (\ref{sec:expressions}) which can be used to reference the binary payload from within query constraints.
	\item[\iqlType{content}] The actual content of the payload in textual form. How to properly convert the textual form to a binary stream is defined by the \iqlType{codec} attribute.
	\item[\iqlType{codec}] Specifies the mechanism of converting the \iqlType{content} data into an actual binary stream. If left empty, defaults to \texttt{hex}.
	\item[\iqlType{checksum}] Optional hex-string of the checksum to check the \iqlType{content} against.
	\item[\iqlType{checksumType}] Defines the algorithm for computing the checksum. Currently only \texttt{MD5} is supported as legal value.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     ELEMENT
\subsection{Element}
\label{sec:json-ld-element}
%\begin{itemize}
%\item id
%\item consumed
%\end{itemize}
\desc{Abstract base type for all logical and/or structural units that can be matched against content of a target corpus.}
\begin{attributes}{\iqlBaseType{Element}}
	\attribute{id}{string}{yes}{}
	\attribute{consumed}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the element within the entire query.
	\item[\iqlType{consumed}] Signals that the element has already been \textit{used up} in the context of a partial query evaluation. An element that has been consumed can safely be ignored in the further evaluation of the query. Note that this state can be propagated according to the following rules:
	\begin{itemize}[leftmargin=*,topsep=0pt]\compresslist
		\item A \iqlType{Node}(\ref{sec:json-ld-node}) can be marked as \texttt{consumed} if its \iqlType{constraint} is marked as \texttt{solved} and its match count satisfies the \iqlType{quantifiers} requirement. Note that cross-referencing constraints can only be considered solved when all other aspects of the involved elements support the \texttt{consumed} state.
		\item A \iqlType{TreeNode}(\ref{sec:json-ld-tree-node}) can be marked as \texttt{consumed} if above conditions are met and all nested \iqlType{children} are marked \texttt{consumed}.
		\item An \iqlType{Edge}(\ref{sec:json-ld-edge}) is considered \texttt{consumed} when both its terminals are \texttt{consumed} and the same conditions regarding its \iqlType{constraint} are fulfilled as mentioned above.
		\item A \iqlType{ElementDisjunction}(\ref{sec:json-ld-element-disjunction}) is considered \texttt{consumed} if at least one of its \iqlType{alternatives} has been marked \texttt{consumed}.
	\end{itemize}
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     NODE SET
\subsubsection{Node Set}
\label{sec:json-ld-node-set}
%\begin{itemize}
%\item nodes
%\item nodeArrangement
%\end{itemize}
\desc{Wrapper around a list of \iqlType{Element} (\ref{sec:json-ld-element}) instances to group them for either nesting or disjunction.}
\extends{\iqlType{Node}}{\ref{sec:json-ld-node}}
\begin{attributes}{\iqlType{NodeSet}}
	\attribute{nodeArrangement}{enum}{no}{unspecified}
\end{attributes}
\begin{description}
	\item[\iqlType{nodeArrangement}] Defines what kind of order or arrangement should be assumed between the elements in this set. Legal values are \texttt{unspecified}, \texttt{ordered} (matched elements must occur in exactly the order specified in this set but need not form a continuous span) or \texttt{adjacent} (matched elements must form a continuous span).
\end{description}
\begin{elements}{\iqlType{NodeSet}}
	\element{nodes}{array of \iqlBaseType{Element} (\ref{sec:json-ld-element})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{nodes}] List of nested \iqlBaseType{Element} instances. Legal types depend on the context in which this set is being used.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     NODE
\subsubsection{Node}
\label{sec:json-ld-node}
%\begin{itemize}
%\item label
%\item constraint
%\item quantifiers
%\end{itemize}
\desc{Logical unit for sequence or graph matching in a target corpus. May contain local constraints and can also be quantified.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{attributes}{\iqlType{Node}}
	\attribute{label}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{label}] Identifier to bind the node through a previously defined \iqlType{Binding} (\ref{sec:json-ld-binding}) declaration.
\end{description}
\begin{elements}{\iqlType{Node}}
	\element{constraint}{\iqlBaseType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{quantifiers}{array of \iqlType{Quantifier} (\ref{sec:json-ld-quantifier})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{constraint}] Optional local constraint to be matched against the content of potential target candidates during query evaluation.
	\item[\iqlType{quantifiers}] Optional quantifiers to define the multiplicity of matches of this node required for a positive evaluation. Multiple quantifiers behave disjunctively. Note that \iql defines some restrictions on the legal combinations of quantifiers: The all-quantifier (\texttt{*} or \texttt{all}) and not-quantifier (\texttt{!} or \texttt{not}) can only be used in isolation, all other quantifiers can be combined in disjunctive fashion.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     TREE NODE
\subsubsection{Tree Node}
\label{sec:json-ld-tree-node}
%\begin{itemize}
%\item children
%\end{itemize}
\desc{Extension of the simple \iqlType{Node} type (\ref{sec:json-ld-node}) to add implicit hierarchical constraints related to dominance within tree structures.}
\extends{\iqlType{Node}}{\ref{sec:json-ld-node}}
\begin{elements}{\iqlType{TreeNode}}
	\element{children}{instance of \iqlBaseType{Element} (\ref{sec:json-ld-element})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{children}] Optional nested nodes or node alternatives.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     EDGE
\subsubsection{Edge}
\label{sec:json-ld-edge}
%\begin{itemize}
%\item label
%\item constraint
%\item source
%\item target
%\item edgeType
%\end{itemize}
\desc{Specialized element extension to query structural information in graphs.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{attributes}{\iqlType{Edge}}
	\attribute{label}{string}{no}{}
	\attribute{edgeType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{label}] Identifier to bind the edge through a previously defined \iqlType{Binding} (\ref{sec:json-ld-binding}) declaration.
	\item[\iqlType{edgeType}] The type specification for this edge, primarily a directionality information. Legal values are \texttt{simple}, \texttt{one-way} or \texttt{two-way}.
\end{description}
\begin{elements}{\iqlType{Edge}}
	\element{constraint}{\iqlBaseType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{source}{\iqlType{Node} (\ref{sec:json-ld-node})}{yes}
	\element{target}{\iqlType{Node} (\ref{sec:json-ld-node})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{constraint}] Optional local constraint to be matched against the content of potential target candidates during query evaluation.
	\item[\iqlType{source}] Source node declaration. 
	\item[\iqlType{target}] Target node declaration. 
\end{description}
For complex graph declarations multiple nodes can be defined having the same \iqlType{label}. The evaluation engine will treat them as being the same node. Note however, that at most \textbf{one} node per label is allowed to declare a local \iqlType{constraint} attribute!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     ELEMENT DISJUNCTION
\subsubsection{Element Disjunction}
\label{sec:json-ld-element-disjunction}
%\begin{itemize}
%	\item alternatives
%\end{itemize}
\desc{Allows declaration of multiple alternative element definitions. When evaluating the query, each such alternative that is matched successfully will cause this element declaration to evaluate positively.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{elements}{\iqlType{ElementDisjunction}}
	\element{alternatives}{array of \iqlType{Element} (\ref{sec:json-ld-element})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{alternatives}] The alternative element declarations, each of which constitutes a legal match for this element declaration. Must not contain less than 2 elements!
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     EXPRESSION
\subsection{Expression}
\label{sec:json-ld-expression}
%\begin{itemize}
%\item content
%\item resultType
%\end{itemize}
\desc{Wraps the textual form of an arbitrarily complex \iql expression, which can be a formula, literal, method invocation, a combination of those or a great many other types of expressions. For more details see \cref{sec:expressions}.}
\begin{attributes}{\iqlType{Expression}}
	\attribute{content}{string}{yes}{}
	\attribute{resultType}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{content}] The textual form of the expression. Must be valid according to the specifications in \cref{sec:expressions}.
	\item[\iqlType{resultType}] An optional specification regarding the return type of the expression. Redundant when the expression is used as a constraint, as those are required to always evaluate to a Boolean result value anyway.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     GROUP
\subsection{Group}
\label{sec:json-ld-group}
%\begin{itemize}
%\item id
%\item groupBy
%\item filterOn
%\item label
%\item defaultValue
%\end{itemize}
\desc{Provides a mechanism to collect successful matches into dedicated groups, either for result visualization or use in further result processing.}
\begin{attributes}{\iqlType{Group}}
	\attribute{id}{string}{yes}{}
	\attribute{label}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the group declaration within the entire query.
	\item[\iqlType{label}] Label (ideally human readable) to be used for referencing this group in subsequent result processing or for generating textual result reports.
\end{description}
\begin{elements}{\iqlType{Group}}
	\element{groupBy}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
	\element{filterOn}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{no}
	\element{defaultValue}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{groupBy}] The mandatory expression used to extract the value from matches based on which the actual grouping occurs.
	\item[\iqlType{filterOn}] Optional mechanism to exclude certain matches from being used for grouping.
	\item[\iqlType{defaultValue}] If matches cannot produce a valid value for grouping but should still be included in the process, this optional field provides the means of declaring a kind of ``fall back'' group. Be aware of potential overlap in groups when using default values that are not distinct from the regular grouping results.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     IMPORT
\subsection{Import}
\label{sec:json-ld-import}
%\begin{itemize}
%\item id
%\item name
%\item optional
%\end{itemize}
\desc{To allow for flexible integration of macro definitions or bigger language extensions, \iql provides an optional section in the query that lets users specify exactly what additional modules besides the bare \iql core are required for evaluating the query. Each import target is specified by providing it's unique name and telling the engine whether or not the import is to be considered optional.}
\begin{attributes}{\iqlType{Import}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{optional}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the import within the entire query.
	\item[\iqlType{name}] The original name of the extension to be added.
	\item[\iqlType{optional}] Defines whether or not the referenced extension is optional. 	Non-optional imports that cannot be resolved to an actual extension during the query evaluation phase will cause the entire process to fail.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     LANE
\subsection{Lane}
\label{sec:json-ld-lane}
%\begin{itemize}
%\item id
%\item name
%\item alias %stores the member name used to reference the entire structure/sentence
%\item laneType
%\item elements
%\end{itemize}
\desc{Lanes serve as a means of splitting queries for a single corpus stream into multiple logical subqueries that target different structural and/or logical layers, e.g. multiple syntactic analyses for the same source text.}
\begin{attributes}{\iqlType{Lane}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{alias}{string}{no}{}
	\attribute{laneType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the lane within the entire query.
	\item[\iqlType{name}] The unique identifier of the \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} or \repoLink{\modelsUrl layer/StructureLayer.java}{structure layer} that serves as target for this lane.
	\item[\iqlType{alias}] If items of this lane in their entirety are meant to be used as part of query expressions inside this field holds the label used for the respective member variable. It is recommended to keep the chosen \texttt{alias} close to the original \texttt{name} to avoid confusion.
	\item[\iqlType{laneType}] The type of structure this lane is meant to match, effectively defining the basic complexity class for evaluation. legal values are \texttt{sequence}, \texttt{tree} and \texttt{graph}. Note that the initial evaluation engine for \iql does not support the \texttt{graph} type! %TODO adjust once we extend the engine
\end{description}
\begin{elements}{\iqlType{Lane}}
	\element{elements}{\iqlBaseType{Element} (\ref{sec:json-ld-element})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{elements}] The structural constraints to be used for evaluation of this lane.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     LAYER
\subsection{Layer}
\label{sec:json-ld-layer}
%\begin{itemize}
%\item id
%\item name
%\item alias
%\item primary
%\item allMembers
%\end{itemize}
\desc{Every layer selector either references an entire subgraph of the corpus' member-graph directly or constructs a partial selection as part of a \iqlType{Scope} (\ref{sec:json-ld-scope}). 
When using the first approach, an \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} is referenced and all its dependencies and associated annotation layers will be made available implicitly. 
This is an easy way of accessing simple corpora, but can lead to costly I/O overhead when loading vast parts of a complex corpus that aren't actually needed to evaluate the query. 
For a more fine-grained alternative, scopes allow to create a scope that spans an exactly specified collection of layers. 
If multiple layer selectors are defined, up to one can be declared as ``primary'' to represent the granularity of returned items for the search or scope.
In case no layer is explicitly marked as ``primary'', the one specified by the corpus or context will be used for that role by default.}
\begin{attributes}{\iqlType{Layer}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{alias}{string}{no}{}
	\attribute{primary}{Boolean}{no}{false}
	\attribute{allMembers}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the layer within the entire query.
	\item[\iqlType{name}] Identifier used to reference the layer within its host corpus.
	\item[\iqlType{alias}] Optional identifier to rename the layer for referencing within the query.
	\item[\iqlType{primary}] Signals that the layer is intended to act as the primary layer in the query or scope and as such defines the level of granularity for obtaining chunks in the corpus.
	\item[\iqlType{allMembers}] When this layer definition is used inside a \iqlType{Scope} (\ref{sec:json-ld-scope}), effectively adds the entire member-subgraph of this layer to the scope. This property is redundant when the layer is part of the regular \iqlType{layers} declaration in a \iqlType{Stream} (\ref{sec:json-ld-stream}), as in that case all member subgraphs for each layer are already being added to the global scope!.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PAYLOAD
\subsection{Payload}
\label{sec:json-ld-payload}
%\begin{itemize}
%\item id
%\item name
%\item queryType
%\item bindings
%\item lanes
%\item constraint
%\end{itemize}
\desc{Every payload encapsulates all the (processed) query constraints to be evaluated against a single stream of corpus data.}
\begin{attributes}{\iqlType{Payload}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{no}{}
	\attribute{queryType}{enum}{yes}{}
	\attribute{queryModifier}{enum}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Automatically generated identifier to uniquely identify the payload within the entire query.
	\item[\iqlType{name}] Custom identifier to uniquely identify the payload within the entire query. This attribute is deprecated but currently being kept to shift its use case.
	\item[\iqlType{queryType}] The overall type of query strategy to be applied for this query payload. Legal values are \texttt{all} (returns the entire corpus and disallows any kind of constraint, leaving only the \iqlType{Result} (\ref{sec:json-ld-result}) declaration as option to modify the result volume), \texttt{plain} (disabling any kind of structural constraints/lanes), \texttt{singleLane} and \texttt{multiLane}. The last two values dictate the minimal/maximal number of \iqlType{Lane} definitions in this payload.
	\item[\iqlType{queryModifier}] Allows to limit the number of times an individual \acp{uoi} will be returned in the result. Supported values are \texttt{first}, \texttt{last} and \texttt{any}. The specific semantics of this modifier are described in more details in \cref{sec:constraints}.
\end{description}
\begin{elements}{\iqlType{Payload}}
	\element{bindings}{array of \iqlType{Binding} (\ref{sec:json-ld-binding})}{no}
	\element{lanes}{array of \iqlType{Lane} (\ref{sec:json-ld-lane})}{no}
	\element{filter}{\iqlType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{constraint}{\iqlType{Constraint} (\ref{sec:json-ld-constraint})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{bindings}] Optional collection of bindings used within this payload. Note that member variables inside constraints or structural query elements will not resolve unless previously bound to corpus members.
	\item[\iqlType{lanes}] If \iqlType{queryType} is set to \texttt{singleLane} or \texttt{multiLane}, this array is expected to hold either exactly 1 or at least 2 \iqlType{Lane} declarations that define structural constraint for the evaluation.
	\item[\iqlType{filter}] If \iqlType{queryType} is set to anything other than \texttt{plain}, this constraint expression allows to filter contextual \acp{uoi} prior to the actual structural matching.
	\item[\iqlType{constraint}] If \iqlType{queryType} is set to \texttt{plain}, this is expected to contain the basic constraints for matching candidates. In any version involving \iqlType{Lane} declarations, global constraints can be defined here as a means of implementing complex query features that are tested once the lanes have produced preliminary result candidates.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PROPERTY
\subsection{Property}
\label{sec:json-ld-property}
%\begin{itemize}
%	\item key
%	\item value
%\end{itemize}
\desc{Allows customization of the evaluation process by changing parameters or switching certain features on/off.}
\begin{attributes}{\iqlType{Property}}
	\attribute{key}{string}{yes}{}
	\attribute{value}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{key}] The identifier of the targeted parameter or switch. The evaluation engine might report unknown keys as errors.
	\item[\iqlType{value}] The actual value to apply to the specified property in case it is not a switch.
\end{description}

\subsubsection{Switches}
\label{sec:json-ld-switches}
For increased flexibility, \iql supports a collection of switches to turn certain optional features on or off when needed. Switches are static and cannot be changed for the active query evaluation once set. All the native \iql switches use the prefix \texttt{iql:} for their name. Any extensions that offer additional switches should declare and use their own namespace for those switches! Currently supported switches are shown in \cref{tab:switches}.

\begin{table}[h]
\noindent\begin{tabular}{|p{0.28\textwidth}|p{0.65\textwidth}|}
\hline 
Name	& Description \\ 
\hline 
\hline
iql.string.case.off         & Turns of case sensitivity when performing string operations such as equality checks.  \\ 
\hline
iql.string.case.lower       & Another approach to case insensitivity, this switch turns all strings into lower case.  \\ 
\hline
iql.expansion.off           & Effectively shuts down value expansion \cref{sec:value-expansion}.  \\ 
\hline
iql.string2bool.off         & Deactivates the interpretation of strings as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.int2bool.off            & Deactivates the interpretation of integers as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.float2bool.off          & Deactivates the interpretation of floating point numbers as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.obj2bool.off            & Deactivates the interpretation of arbitrary objects as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.any2bool.off            & Deactivates the interpretation of anything non-Boolean as Boolean value. This is a combination of ``iql.string2bool.off'', ``iql.int2bool.off'', ``iql.float2bool.off'' and  ``iql.obj2bool.off''.  \\ 
\hline
iql.direction.reverse       & Reverses the direction used to traverse corpus data for a search.  \\ 
\hline
iql.array.zero              & Change array access \cref{sec:list-access} to be 0-based.  \\ 
\hline
iql.warnings.off            & Deactivates all warnings, potentially resulting in confusing results if there are mistakes in the query.  \\ 
\hline
iql.parall.off			  & Forces the query evaluation engine to run single-threaded. This does however only affect the actual matcher, not additional. modules such as monitoring or item caches  \\ 
\hline
\end{tabular}
\caption{Currently supported switches in \iql and their explanations.}
\label{tab:switches}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     QUANTIFIER
\subsection{Quantifier}
\label{sec:json-ld-quantifier}
%\begin{itemize}
%\item quantifierType
%\item value
%\item lowerBound
%\item upperBound
%\end{itemize}
\desc{Specifies the multiplicity of an associated \iqlBaseType{Element} (\ref{sec:json-ld-element}).}
\begin{attributes}{\iqlType{Quantifier}}
	\attribute{quantifierType}{enum}{yes}{}
	\attribute{value}{integer}{no}{}
	\attribute{lowerBound}{integer}{no}{}
	\attribute{upperBound}{integer}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{quantifierType}] Defines how to interpret the other attributes. Legal values are \texttt{all} (universal quantification), \texttt{exact}, \texttt{atMost} (0..n), \texttt{atLeast} (n+), \texttt{range} (n..m).
	\item[\iqlType{value}] Target or limit value when \iqlType{quantifierType} is set to \texttt{exact}, \texttt{atMost} or \texttt{atLeast}.
	\item[\iqlType{lowerBound}] Used for \texttt{range} quantification to define the minimum multiplicity.
	\item[\iqlType{upperBound}] Used for \texttt{range} quantification to define the maximum multiplicity.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     QUERY
\subsection{Query}
\label{sec:json-ld-query}
%\begin{itemize}
%\item id
%\item dialect
%\item imports
%\item setup
%\item embeddeData
%\item streams
%\end{itemize}
\desc{Encapsulates all the global configuration and extension of the query engine, as well as shared embedded data. Each query contains at least one \iqlType{Stream} declaration that in turn holds the actual query payload with constraints for the matching process.}
\begin{attributes}{\iqlType{Query}}
	\attribute{id}{string}{yes}{}
	\attribute{dialect}{string}{no}{1.0}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier for the query, chosen by the client. In more complex (asynchronous) query workflows this id is used to map answers and results to the correct query.
	\item[\iqlType{dialect}] Specifies which basic version of \iql to use. The initial version of \iql is ``1.0`` and by leaving the dialect part of a query blank the engine will default to this initial version.
\end{description}
\begin{elements}{\iqlType{Query}}
	\element{imports}{array of \iqlType{Import} (\ref{sec:json-ld-import})}{no}
	\element{setup}{array of \iqlType{Property} (\ref{sec:json-ld-property})}{no}
	\element{embeddeData}{array of \iqlType{Data} (\ref{sec:json-ld-data})}{no}
	\element{streams}{array of \iqlType{Stream} (\ref{sec:json-ld-stream})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{imports}] Defines extensions to be applied to the evaluation engine prior to actual query evaluation.
	\item[\iqlType{setup}] Allows to configure the core evaluation engine or already defined extensions in a simple manner.
	\item[\iqlType{embeddeData}] Binary data to be used in the evaluation process, such as audio or video fragments.
	\item[\iqlType{streams}] Corpus data streams to be queried. In the initial version, the engine only supports single-stream querying!
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     REFERENCE
\subsection{Reference}
\label{sec:json-ld-reference}
%\begin{itemize}
%\item id
%\item name
%\item referenceType
%\end{itemize}
\desc{Models references usable from within query expressions for accessing corpus members or variables.}
\begin{attributes}{\iqlType{Reference}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{referenceType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the reference within the entire query.
	\item[\iqlType{name}] The local identifier to be used for addressing this reference. Note that this is the bare name without any type-specific prefixes (such as '\textdollar' for members, cf. \cref{sec:variables-references}).
	\item[\iqlType{referenceType}] Specifies the nature of this reference. Legal values are \texttt{reference}, \texttt{member} or \texttt{variable}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     RESULT
\subsection{Result}
\label{sec:json-ld-result}
%\begin{itemize}
%\item resultTypes
%\item resultInstructions
%\item limit
%\item percent
%\item sortings
%\end{itemize}
\desc{Encapsulates all the information on result processing and preparation.}
\begin{attributes}{\iqlType{Result}}
	\attribute{limit}{integer}{no}{}
	\attribute{percent}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{limit}] Optional limitation on the total size of the result to be returned. If the \iqlType{percent} flag is not set to \texttt{true}, this number is in reference to the units provided by the query's primary \repoLink{\modelsUrl layer/ItemLayer.java}{item layer}.
	\item[\iqlType{percent}] If set to \texttt{true} the value defined in \iqlType{limit} is treated as a integer percentage value in the interval 1 to 99, with boundaries included.
\end{description}
\begin{elements}{\iqlType{Result}}
	\element{resultTypes}{array of enum}{yes}
	\element{resultInstructions}{array of \iqlType{ResultInstruction} (\ref{sec:json-ld-result-instruction})}{no}
	\element{sortings}{array of \iqlType{Sorting} (\ref{sec:json-ld-sorting})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{resultTypes}] Defines the result format or type the engine should return data in. At least one result type must be declared and the engine can also be instructed to return the results in multiple formats simultaneously. In the first iteration only \texttt{kwic} (keyword-in-context) and \texttt{custom} (as a placeholder for the raw corpus members) are supported.
	\item[\iqlType{resultInstructions}] Optional collection of additional processing instructions to generate (textual) result reports.
	\item[\iqlType{sortings}] Allows to sort matches before generating result reports.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     RESULT INSTRUCTION
\subsection{Result Instruction}
\label{sec:json-ld-result-instruction}
%\begin{itemize}
%\item TODO
%\end{itemize}
%TODO fill once the specification is fleshed out
\desc{Currently unused dummy for declaring post-processing instructions on the query result to perform conversions and/or tabular calculations.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     SCOPE
\subsection{Scope}
\label{sec:json-ld-scope}
%\begin{itemize}
%\item id
%\item layers
%\end{itemize}
\desc{Very detailed vertical filtering of the layers available in a query.}
\begin{attributes}{\iqlType{Scope}}
	\attribute{id}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the scope within the entire query.
\end{description}
\begin{elements}{\iqlType{Scope}}
	\element{layers}{array of \iqlType{Layer} (\ref{sec:json-ld-layer})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{layers}] The layer members of this scope.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     SORTING
\subsection{Sorting}
\label{sec:json-ld-sorting}
%\begin{itemize}
%\item expression
%\item order
%\end{itemize}
\desc{Defines a single rule for sorting query results based on an arbitrarily complex expression.}
\begin{attributes}{\iqlType{Sorting}}
	\attribute{order}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{order}] Hint on sorting direction, legal values are \texttt{asc} or \texttt{desc} for ascending or descending order, respectively.
\end{description}
\begin{elements}{\iqlType{Sorting}}
	\element{expression}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{expression}] The actual sorting expression. It can use any (member) reference or variable available in the query to compute its result and must return a type that is comparable to allow stable sorting. Per default any of the primitive numerical types (\texttt{int} or \texttt{float}), the text type \texttt{string} and any member of the \icarus framework implementing the \texttt{java.lang.Comparable} interface can be used as return type.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STREAM
\subsection{Stream}
\label{sec:json-ld-stream}
%\begin{itemize}
%	\item id
%	\item primary
%	\item corpus
%	\item layers
%	\item scope
%	\item rawPayload
%	\item payload
%	\item rawGrouping
%	\item grouping
%	\item rawResult
%	\item result
%\end{itemize}
\desc{A stream encapsulates all the information and query constraints to extract, evaluate and prepare data from a single corpus. Note that many of the attributes and/or elements below are marked as optional, but the following restrictions are in effect:}
\vspace{-\medskipamount}
\begin{itemize}[leftmargin=*,topsep=0pt]\compresslist
	\item Either \iqlType{rawPayload} or \iqlType{payload} must be provided by the client.
	\item Either \iqlType{layers} or \iqlType{scope} must be provided to define the granularity of data being loaded for evaluation.
\end{itemize}
\begin{attributes}{\iqlType{Stream}}
	\attribute{id}{string}{yes}{}
	\attribute{primary}{Boolean}{no}{false}
	\attribute{rawPayload}{string}{no}{}
	\attribute{rawGrouping}{string}{no}{}
	\attribute{rawResult}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the stream within the entire query.
	\item[\iqlType{primary}] Flag to indicate that the primary layer of this stream is meant to be used as primary layer of the entire search result. Only one stream can declare this property and it primarily dictates the order of result elements in a multi-stream query or which stream is allowed to dictate sorting.
	\item[\iqlType{rawPayload}] The textual (raw) form of the payload for this stream, i.e. all the constraints and structural query content.
	\item[\iqlType{rawGrouping}] The textual (raw) grouping definitions to be applied for results of this stream.
	\item[\iqlType{rawResult}] The textual (raw) result configuration and post-processing instructions for this stream.
\end{description}
\begin{elements}{\iqlType{Stream}}
	\element{corpus}{\iqlType{Corpus} (\ref{sec:json-ld-corpus})}{yes}
	\element{layers}{array of \iqlType{Layer} (\ref{sec:json-ld-layer})}{no}
	\element{scope}{\iqlType{Scope} (\ref{sec:json-ld-scope})}{no}
	\element{payload}{\iqlType{Payload} (\ref{sec:json-ld-payload})}{no}
	\element{grouping}{array of \iqlType{Grouping} (\ref{sec:json-ld-group})}{no}
	\element{result}{\iqlType{Result} (\ref{sec:json-ld-result})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{corpus}] The corpus to extract data from.
	\item[\iqlType{layers}] Vertical filtering to be applied to the corpus prior to actual query evaluation.
	\item[\iqlType{scope}] Another and more fine-grained form of vertical filtering that allows for more precise selection of layers to be part of this stream's data.
	\item[\iqlType{payload}] The processed form of \iqlType{rawPayload}.
	\item[\iqlType{grouping}] The processed form of \iqlType{rawGrouping}.
	\item[\iqlType{result}] The processed form of \iqlType{rawResult}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Inner \iql ELements}
\label{sec:inner-iql-elements}

Certain parts of an \iql query can be defined in \textit{raw} form, that is, in a keyword-driven formal language.
During the first phase of query evaluation they get (partly) translated into their respective JSON-LD counterparts described in \cref{sec:elements} (unless of course the query or query fragments are provided fully processed).
This section defines the syntax and additional rules for those raw statements.
Note that the textual form of all following \iql elements is expected to be encoded in UTF-8, so no special escape mechanisms are needed for unicode content.


%TODO from here on restructure!


\subsection{Reserved Words}
\label{sec:reserved-words}

The following list of keywords is reserved and any of the words may not be used as direct identifier strings in a query. They are reserved in both all lowercase and all uppercase variants, and while camel-cased versions are technically permitted, it is highly discouraged to use them:

\vbox{%
\begin{multicols}{4}
\parindent=0pt
\texttt{%
\begingroup
\obeylines
\input{keywords.txt}
\endgroup
}
\end{multicols}
}

\noindent In addition the following strictly lowercase words are reserved as type identifiers and may not be used otherwise:

\vbox{%
\begin{multicols}{4}
\parindent=0pt
\texttt{%
\begingroup
\obeylines
\input{types.txt}
\endgroup
}
\end{multicols}
}

\subsection{Comments}
\label{sec:comments}

\iql supports single-line comments, indicated by ``//''. All remaining content in a line after the comment indicator will be ignored when parsing and evaluating a query. 

\subsection{Literals}
\label{sec:literals}

Literals are statically-typed fixed-value expressions in \iql.
They are parsed only once during the initial processing part of a query.

\subsubsection{String Literals}
\label{sec:string-literals}

\iql uses simple double quotes (" or U+0022) to define string literals. 
String literals may not contain any of the following symbols directly:

\begin{verbatim}
\n line break
\r carriage return
\t tab
\ backslash
" nested quotation mark
\end{verbatim}

\noindent Any of those symbols listed above can be embedded into a string literal as part of an escape sequence with a preceding backslash.
At the current time there is no planned mechanism to provide additional escape support for unicode symbols, since the default encoding scheme for \iql is UTF-8.

\paragraph{Examples for valid string literals:}

\begin{verbatim}
"string"
"123"
"some fancy number (123.456e-789) and emoji ☹ <emoji not showing>"
"a more complex string!"
"a\n multiline\n string..."
\end{verbatim}
%TODO emoji not showing!!

\subsubsection{Boolean Literals}
\label{sec:boolean-literals}

Boolean literals are limited to either all lowercase or all uppercase versions of the literals \keyword{true} and \keyword{false}.

\subsubsection{Integer Literals}
\label{sec:integer-literals}

\paragraph{Signed Integer Literals}
Literals representing regular \keyword{int} (32bit) or \keyword{long} (64bit) integers consist of an optional initial sign (\texttt{+} or \texttt{-}) and the body consisting of digits or underscore (\texttt{\_}) characters.
Underscore characters may only appear inside the integer literal, never at the beginning or end (not counting the sign symbol).

\paragraph{Examples for valid (signed) integer literals:}

\begin{verbatim}
1
+123
-123
1_000_000
-99_000000_0
\end{verbatim}

\paragraph{Pure Integer Literals}
Some parts of the \iql syntax only allow unsigned "pure" integers and will explicitly state this fact. In those special cases integer literals may neither contain the initial sign symbol nor intermediate underscores.

\subsubsection{Floating Point Literals}
\label{sec:floating-point-literals}

Floating point literals are constructed by using a (signed) integer literal for the pre-decimal part, a dot '\texttt{.}' as delimiter and a decimal part made up by a unsigned integer literal. They represent either single-precision \keyword{float} (32bit) or double-precision \keyword{double} (64bit) values.

\paragraph{Examples for valid (signed) floating point literals:}

\begin{verbatim}
1.0
+123.456
-123.456
1_000_000.999
-99_000000_0.000_000_001
\end{verbatim}

\noindent While many languages offer to express floating point literals in the scientific notation with explicit exponent declaration, we do not include this in the initial draft of \iql.

\subsection{Identifiers}
\label{sec:identifiers}

\noindent Identifiers in \iql are combinations of lowercase or uppercase alphabetic \texttt{[a-zA-Z]} characters that may contain underscore symbols \texttt{\_} between the first and last position and may also contain digits \texttt{[0-9]} on any position except as initial symbol.

\paragraph{Examples for valid identifiers:}

\begin{verbatim}
x
myIdentifier
x1
x_1
x__1
x321
some_random_id
someRandomId002
random_2_4
notTheBest______________example
\end{verbatim}

\noindent Identifiers are limited in length by the engine to a total of 255 characters. This is a purely arbitrary choice to keep queries readable and not subject to any technical limitations.

\subsection{Variables and References}
\label{sec:variables-references}

In \iql all top-level (i.e. not part of the tail expression in a hierarchical path) identifiers are expected to reference 'something' from the global namespace available to the query. This namespace is populated with all the globally available constants, methods and helper objects from the \iql core and any imported extensions, as well as all the corpus members defined in the scoping part of the query. Outside this global namespace any dynamically created identifiers from within a query reside in the variable namespace and are marked with a preceding \texttt{@} (e.g. \texttt{@myVariable}). They can be used the same way as any regular identifier, with the exception of additionally allowing assignment expressions when inside script blocks. In addition any corpus members bound within a constraint section are prefixed with a \texttt{\$} sign, such as \texttt{\$token1}. \cref{tab:identifiers} provides a compact overview of the available identifiers and their capabilities/features.

\begin{table}[ht]
	\centering\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline 
		Type	& Prefix & Example & Scope & Fixed\footnotemark & Final & Re-Assign \\ 
		\hline 
		Reference	& none & \texttt{max()} & global & X & X &  \\ 
		\hline 
		Variable	& \texttt{@} & \texttt{@myVar} & limited & (X) &  & X \\ 
		\hline 
		Member	& \texttt{\$} & \texttt{\$token} & limited & X & (X) &  \\ 
		\hline 
	\end{tabular}
	\footnotetext{Fixed as in ``fixed type'', i.e. the type of value stored is pre-determined and cannot be changed during query evaluation.} %TODO doesn't work properly
	\caption{Identifier types available in \iql and their properties.}
	\label{tab:identifiers}
\end{table}

\paragraph{Special remarks:}
\noindent Variables are more or less general-purpose storage objects for arbitrary values and without a fixed type. Their first assignment however hints at the implied type to be used and as such they can cause cast errors when used for situations where an incompatible type would be needed.

Member identifiers are final in the sense that they cannot be re-assigned explicitly but will be implicitly for every iteration of the query on a new part of the corpus. For example, above \texttt{\$token} member will point to a new token object every time the inner constraint parts of the query are evaluated. Therefore member identifiers could be viewed as a sort of loop variable. 

\subsection{Expressions}
\label{sec:expressions}

Expressions are the foundation of every query.
Each expression has a (usually fixed) result type and evaluates to a value of that type.
They can take any of the following forms:

\subsubsection{Primary Expressions}
\label{sec:primary-expressions}

Any literal (\keyword{boolean}, \keyword{string}, \keyword{int} or \keyword{float}) can serve as a primary expression of that type.
See \cref{sec:literals} for examples and a more detailed specification of the various types of literals in \iql.

\subsubsection{Path Expressions}
\label{sec:path-expressions}

For navigating hierarchically structured object graphs or namespaces, expressions can take the form of paths:
\begin{grammar}	
<path> ::= <expression> `.' <identifier> 	
\end{grammar}

\paragraph{Examples:}

\begin{verbatim}
someObejct.someProperty
some.really.long.winded.path
\end{verbatim}

\noindent Note that for a lot of native classes of the ICARUS2 framework, \iql provides convenient path-based alternatives to method invocations. For example in  the context of navigating a structure, ``someStructure.getParent(someItem)`` can be replaced by ``someItem.parent`` as long as ``someStructure`` is unambiguous in the current context and already bound.

\subsubsection{Method Invocation}
\label{sec:method-invocations}

Method invocations consist of an expression that points to the actual method (such as an identifier in the global namespace or a path expression) and round brackets for the invocation with an optional argument list:
\begin{grammar}	
	<method> ::= <expression> `(' <arguments>? `)'
	
	<arguments> ::= <expression> (`,' <expression>)*
\end{grammar}

\paragraph{Examples:}

\begin{verbatim}
myFunction()
myNamespace.someFunction(someArgument, anotherArgument)
min(123, 456, dynamicContent())
some().chained().methods()
\end{verbatim}

\subsubsection{List Access}
\label{sec:list-access}

Lists or arrays are accessed by an expression pointing to the list or array object itself and an index expression in square brackets indicating the position(s) of the desired element(s) within the array. Note that the index or indices expression must evaluate to integer values within \texttt{int} space. Positive values indicate the position beginning from the start of the 0-based array, whereas negative values allow backwards referencing of elements with \texttt{-1} pointing to the last array element and \texttt{-2} to the second to last one. For multidimensional arrays several index statements can be chained or even combined in a single comma-separated list.

\begin{grammar}	
	<array> ::= <expression> `[' <indices> `]'
	
	<indices> ::= <expression> (`,' <expression>)*
\end{grammar}

\paragraph{Examples:}

\begin{verbatim}
myArray[1]
myArray[-1]
myArray[-myArray.length] // same as myArray[0]
complexArray[1][2][3]
complexArray[-1][2][-3]
complexArray[1, 2][3]
complexArray[1, 2, 3]
\end{verbatim}

\noindent Note that \iql provides convenient ways of using array access patterns to access list-like data structures and/or classes of the framework:
Every \repoLink{\modelsUrl /members/item/manager/ItemLookup.java}{ItemLookup} implementation, such as \repoLink{\modelsUrl /members/container/Container.java}{Container} or \repoLink{/members/structure/Structure.java}{Structure} that would traditionally access its content via ``myContainer.getItemAt(someIndex)`` can be used the same as any regular array with the expression ``myContainer[someIndex]``.

\subsubsection{Annotation Access}
\label{sec:annotation-access}

The ICARUS2 framework models segmentation, structure and content of a corpus resource as different aspects. As such the information about any annotation attached to a given Item is stored apart from it and therefore is not easily accessible from the item alone. To simplify the usage of annotations within a query, \iql provides the following expression as syntactic sugar for accessing (multiple) annotations directly from an item:

\begin{grammar}	
	<annotation> ::= <expression> `{' <keys> `}'
	
	<keys> ::= <expression> (`,' <expression>)*
\end{grammar}

\noindent The first expression must evaluate to an item reference and the annotation pointers inside curly brackets must evaluate to strings (if only a single expression is given, it can evaluate to a list or array and be expanded, cf. \cref{sec:value-expansion}) that uniquely denote annotation layers in the current context of the query. Typically users will use string literals in double quotes to explicitly state the annotations to be accessed, but the \iql syntax allows for very flexible extraction statement. If the evaluation of those annotation pointers yields more than one string, the result will be an array-like object containing the resolved values for each of the annotation keys in the same order as those were specified.

\paragraph{Examples:}

\begin{verbatim}
myItem{"pos"}
myItem{"form", "pos", "lemma"} 

// extract values from multiple concurrent annotation layers
// and pick the first one present
firstSetValue(myItem{"parser1.head", "parser2.head"})  
\end{verbatim}

\subsubsection{Type Cast}
\label{sec:type-cast}

Expressions in \iql are automatically cast to matching types according to the actual consumer's needs (unless this feature gets deactivated via the corresponding switch, cf. \cref{sec:json-ld-switches}). Explicit casts can be performed by preceding an expression with one of the type keywords listed above (\ref{sec:reserved-words}) in round brackets.

\paragraph{Examples:}

\begin{verbatim}
(int) myValue
(int) 12345.678
(float) average(myVector)
(string) 123.456
\end{verbatim}

\subsubsection{Wrapping}
\label{sec:wrapping}

Expression hierarchy and evaluation order follows the order the different types of expressions are listed here. To dictate another order, expressions can be wrapped into round brackets. This will cause the inner expression to be evaluated independent of potential hierarchical rules from the outside context.

\paragraph{Examples:}

\begin{verbatim}
6 + 4 * 2   // multiplication evaluated first -> result 14
(6 + 4) * 2 // addition is evaluated first -> result 20
\end{verbatim}

\subsubsection{Set Predicate}
\label{sec:set-predicate}

Also called 'containment predicate', this expression allows to check if a given value is a member of a specified set (or generally speaking 'collection'). The basic form of a set predicate looks as follows:
\begin{grammar}	
	<set_predicate> ::= <expression> `IN' `{' <items> `}'
	
	<items> ::= <expression> (`,' <expression>)*
\end{grammar}

\noindent The entire expression evaluates to a Boolean value and will be \keyword{true} iff the input expression (left-most one) evaluates to the same value as any of the expressions inside the curly brackets (the set definition). See about equality operators in \cref{sec:binary-operation}. Note that methods or collections used inside the set definition are subject to the expansion rules described in \cref{sec:value-expansion}. The primary use case for set expressions is to greatly simplify the declaration of constraints for multiple alternative target values. 

Set predicates can be directly negated (apart from wrapping \ref{sec:wrapping} them and negating \ref{sec:unary-operation} the entire expression) with an exclamation mark ``!'' or the keyword \keyword{NOT} in front of the \keyword{IN} keyword. If the input expression evaluates to an array-like object, the set predicate will expand its content and evaluate to \keyword{true} if at least \textit{one} of its elements is found to be contained in the set. The set predicate can be universally quantified with a star ``*'' or the \keyword{ALL} keyword in front to change the overall behavior such that the result will be \keyword{true} iff \textit{all} of the elements are contained in the set (or none of them are, if the set predicate is directly negated).

\paragraph{The complete syntax with all options looks as follows:}
\begin{grammar}	
	<set_predicate> ::= <expression> <all>? <not>? `IN' `{' <items> `}'
	
	<all> ::=  `ALL' | `*'
	
	<not> ::=  `NOT' | `!'
	
	<items> ::= <expression> (`,' <expression>)*
\end{grammar}

\paragraph{Examples:}

\begin{verbatim}
someAnnotationValue IN {"NP","VP","-"}
someAnnotationValue NOT IN {"NN","DET"}
"John" IN {getLegalNames()}
fetchCharacterNamesInChapterOne() IN {getOrcishNames()}
\end{verbatim}

\subsubsection{Unary Operation}
\label{sec:unary-operation}

\iql only allows four unary operators to be used directly in front of an expression, the exclamation mark ``!'' and the \keyword{NOT} keyword for Boolean negation, the minus sign ``-'' for negating numerical expressions and the ``\~'' symbol of bitwise negation of integer numbers.

\paragraph{Examples:}

\begin{verbatim}
!someBooleanFunction()
NOT someBooleanValue
-123
-myNumericalFunction()
~123
~myIntegerFunction()
\end{verbatim}

\subsubsection{Binary Operation}
\label{sec:binary-operation}

Binary operations between two expressions take the following simple form:

\begin{grammar}	
	<binary_op> ::= <expression> <operator> <expression>
\end{grammar}

\noindent Binary operators follow an explicit hierarchy, listed in \cref{tab:binary-operators} in the order of priority, from highest to lowest.

\begin{table}[ht]
\centering\begin{tabular}{|p{0.25\textwidth}|p{0.6\textwidth}|}
\hline 
Operators	& Explanation \\ 
\hline 
\hline
\verb|*  /  %|& multiplication, division and modulo \\ 
\hline 
\verb|+  -|& addition and subtraction \\ 
\hline 
\verb#<<  >>  &  |  ^#& shift left, shift right, bitwise and, bitwise or, bitwise xor \\ 
\hline 
\verb|<  <=  >  >=|& less, less or equal, greater, greater or equal \\ 
\hline 
\verb|~  !~  #  !#|& string operators: matches (regex), matches not (regex), contains, contains not \\ 
\hline 
\verb|==  !=|& equals, equals not \\ 
\hline 
\verb|&&  AND|& logical and \\ 
\hline 
\verb#||  OR#& logical or \\ 
\hline 
\end{tabular} 
\caption{Binary operators available in \iql and their hierarchical order.}
\label{tab:binary-operators}
\end{table}

\paragraph{Basic Numerical Operations}
\label{sec:basic-numerical-operations}

Basic numerical operations follow the standard mathematical rules for priorities.
While the basic numerical types (\keyword{int}, \keyword{float}) can be arbitrarily mixed inside those expressions, the type used during the expression and as result will be determined by the least restrictive type of any operand involved.

\paragraph{Bit Operations}
\label{sec:bit-operations}

Bitwise operations (\texttt{\&}, \texttt{$|$} and \texttt{\textasciicircum}) take integer expressions (or any other form of \textit{bitset}) as inputs and generate a result of the corresponding type. If different types are used (e.g. \texttt{int} and \texttt{long}), one must be cast \ref{sec:type-cast} to match the other. If value expansion \ref{sec:value-expansion} is active, any array-like data can also be used and will be subject to element-wise bit operations.

The two shift operations (\texttt{\textless{}\textless} and \texttt{\textgreater{}\textgreater}) take arbitrary integer types as left operand and an \keyword{int} value as right operand.

\paragraph{Ordered Comparisons}
\label{sec:ordered-comparisons}

Comparisons are special binary operators that take two expressions of equal or compatible result type and produce a Boolean value. Note that their exact semantics are type specific, e.g. when comparing strings, the operation is performed lexicographically and may be subject to case conversions (\ref{sec:json-ld-switches}).

\paragraph{String Operations}
\label{sec:string-operations}

To account for the ubiquity of textual annotations in corpora, \iql provides a set of dedicated string operators to perform substring matching (with the \textit{contains} operator \texttt{\#} or its negated form \texttt{!\#}) and regular expression matching (via \texttt{\textasciitilde} and \texttt{!\textasciitilde}). Per default \iql uses the Java regex syntax, but for the future, additional switches (\ref{sec:json-ld-switches}) are planned to allow finer control over regex details.

\paragraph{Examples:}

\begin{verbatim}
// find verbal forms
somePosAnnotation # "V"       
// alternative to the set predicate with more flexibility
somePosAnnotation !~ "NN|NS"   
\end{verbatim}

\paragraph{Equality}
\label{sec:equality}

Equality checks follow the same basic conditions as ordered comparisons \cref{sec:ordered-comparisons}, but with the following rules for comparable values ``a`` and ``b``:

\begin{verbatim}
a == b iff !(a<b) && !(a>b)
a != b iff a<b || a>b
\end{verbatim}

\noindent More generally, equality between expressions in \iql is based on content equality and therefore type specific.
Note that trying to check two expressions of incompatible types (such as \keyword{int} and \keyword{string}) for equality will always evaluate to \keyword{false} and also emit a warning. 
%TODO is this part actually implemented?

\paragraph{Logical Composition}
\label{sec:logical-composition}

All Boolean expressions can be combined via disjunction (either double pipes \texttt{$||$} or the \keyword{OR} keyword) or conjunction (double ampersand \texttt{\&\&} or the \keyword{AND} keyword), with conjunction having higher priority. While not strictly mandatory, evaluation of \iql expressions is recommended to employ optimized interpretation such that only the first operand is evaluated if possible. When the first operand of a disjunction evaluates to \keyword{true}, the entire expression is already determined, same for a conjunction's first operand yielding \keyword{false}. 

\paragraph{Examples:}

\begin{verbatim}
a>1 && b<2
x==1 or x==3
\end{verbatim}

\subsubsection{Ternary Operation}
\label{sec:ternary-operation}

A single ternary operation is supported in \iql, the popular if-then-else replacement with the following syntax:

\begin{grammar}	
	<ternary> ::= <expression> `?' <expression> `:' <expression>
\end{grammar}

\noindent The first expression must evaluate to a \keyword{boolean} value and determines which of the following two alternatives will be evaluated for the final value of the expression. Note that the second and third expressions must have compatible result types.

\paragraph{Examples:}

\begin{verbatim}
x<2 ? "text for smaller value" : "some other text"
\end{verbatim}

\subsubsection{Value Expansion}
\label{sec:value-expansion}

\iql supports expansion of arrays, lists and array-like method return values for situations where an immediate consumer supports lists of values as input. Assuming the method ``randomPoint()'' returns an array of 3 integer values or a \textit{array-like} data type (such as a 3D point) and another method ``invertPoint(int, int, int)'' takes 3 integer arguments, then the invocation of ``invertPoint(randomPoint())'' is legal and the array or object from the inner method call will be automatically expanded into the separate 3 values. This is especially handy when dealing with multidimensional arrays, as regular indexing would require manual extraction of method return values into variables to then be used in accessing the different array dimensions. With automatic expansion, a three-dimensional array could directly be accessed with aforementioned method via ``array[randomPoint()]''.

\subsection{Constraints}
\label{sec:constraints}

Simply put, constraints are expressions that evaluate to a Boolean result. 
Apart from native Boolean expressions (such as comparisons, Boolean literals or Boolean functions), \iql allows certain evaluations as syntactic sugar, listed in \cref{tab:constraints-translation}.
Note that those evaluations are only active if the respective switches to disable them (\ref{sec:json-ld-switches}) have not been set.


\begin{table}
\centering\begin{tabular}{|l|c|c|}
	\hline 
	Type & Condition & Value \\ 
	\hline 
	\keyword{string} & empty or null & \keyword{false}  \\ 
	\hline 
	\keyword{int} & \texttt{0} & \keyword{false} \\ 
	\hline 
	\keyword{float} & \texttt{0.0} & \keyword{false} \\ 
	\hline
	any object & \keyword{null} & \keyword{false} \\ 
	\hline 
\end{tabular}
\caption{Rules for evaluating arbitrary values or objects in a query to Boolean values.}
\label{tab:constraints-translation}
\end{table}

\subsection{Basic Constraints}
\label{sec:basic-constraints}

Basic constraints can either be predicates, loop predicates, bracketed (with \keyword{(} or \keyword{)}) constraints or disjunctions (via \keyword{OR}) or conjunctions (with \keyword{AND}) of constraints.

\paragraph{Predicate}
\label{sec:predicate}

Predicates are essentially expressions (\ref{sec:expressions}) that evaluate to a Boolean value. 
See the previous sections on constraints (\ref{sec:constraints}) for information on how non-Boolean types are interpreted as Boolean values and the switches (\ref{sec:json-ld-switches}) section for ways to influence this behavior.

\paragraph{Loop Predicate}

TODO

\subsection{Filter Constraints}
\label{sec:filter-constraints}

For complex (i.e. structural) queries, \iql offers a way of filtering the \acp{uoi} before they are processed by the matchers for sequence, tree or graph structures (cf. \cref{sec:sequence-constraints,sec:tree-constraints,sec:graph-constraints}).
A dedicated \keyword{FILTER BY} section in the query payload preceding the actual structural constraints is available to define filtering rules that have to evaluate to \keyword{true} for a \ac{uoi} to be considered for actual matching.
Constraints within a filtering rules have only access to general properties of the \acp{uoi}, such as sentence length, tree height or similar information.
The do \textbf{not} have access to bound member variables, apart from those defined for the top-level members of lanes (\ref{sec:lanes})!
Note that filter constraints are \textbf{not} compatible with flat constraints (\ref{sec:flat-constraints}) as they both essentially fill the same function and flat constraints take precedence.

\subsection{Structural Constraints}
\label{sec:structural-constraints}

The constraints section in \iql (referred to as the payload) consists either of the sole \keyword{ALL} keyword or of an optional bindings definition and the actual constraints themselves. 
A binding is a collection of member references (\ref{sec:variables-references}) that get declared to belong to a certain type and/or part of the corpus. 
The \keyword{DISTINCT} keyword enforces that multiple bound member references in this binding do \textbf{not} match the same target. 
Depending on the local constraints used in the query, this might be redundant (e.g. when using the member references as identifiers for tree nodes who already are structurally distinct), but can still be used to make that fact explicit. 
Additionally the \keyword{EDGES} keyword signals that the bound members of a structure are actually edges.
In this case using \keyword{DISTINCT} is redundant, as bound edges are implicitly assumed to be distinct when matching.

\begin{grammar}	
	<payload> ::= `ALL' | <selection>
	
	<selection> ::= (`WITH' <bindingsList>)? (`FILTER' `BY' <constraints>)? `FIND' <modifier>? <constraints>
	
	<modifier> ::= `FIRST' | `LAST' | `ANY'
	
	<bindingsList> ::= <binding> (`AND' <binding>)* 
	
	<binding> := <option>? <member> (`,' <member>)* `FROM' <layer>
	
	<option> := `DISTINCT' | `EDGES'
	
\end{grammar}
\todo{expand the constraints rule to include lanes and subsequently sequence/tree/graph definitions}

Constraints are further divided into local constraints as part of node or edge definitions and global ones (with the \keyword{HAVING} keyword). 
Local constraints are obligatory and define the basic complexity of the query (flat, tree or graph). 
They also introduce certain limitations on what can be expressed or searched (e.g. a ``flat'' local constraints declaration will not provide implicit access to tree information). 
However, global constraints can introduce arbitrary constraints or relations and thereby increase the evaluation complexity, potentially without limits. 
Since there is no way for an evaluation engine to assess the complexity of user macros or extensions, extensive use of global constraints could in fact lead to extremely slow searches or even create situations where an evaluation will never terminate at all.

\paragraph{Match Modifiers}
\label{sec:mathc-modifiers}
Per default, the search in \iql is expected to be exhaustive, i.e. the evaluation engine will attempt to find all of the instances in a target corpus that match the query constraints, potentially reporting individual \acp{uoi} (such as sentences) multiple times  if they contain several occurrences.
For instance, the sentence ``The dog chased the rabbit down the hill.'' will be treated as tree entries in the result if the query was only meant to find instances of the lemma ``the''.
This default behavior can be adjusted to only return each \ac{uoi} no more than once by using one of the modifiers (\keyword{FIRST}, \keyword{LAST}, \keyword{ANY}) listed in the grammar fragment in \cref{sec:constraints}.
The semantics of the \keyword{ANY} modifier are such that the engine may freely pick any one match within a \ac{uoi}.
Note however, that to support reproducible search results, repeated evaluations of the same query on a corpus are still required to yield the same instances here.
The exact semantics of \keyword{FIRST} and \keyword{LAST} are depending on the type of structural constraints used in the payload, but generally are based on the natural order of items within the corpus (typically this is the flow of words in a text).
The evaluation behavior for them is subsequently covered in the \cref{sec:sequence-constraints,sec:tree-constraints,sec:graph-constraints}.

\paragraph{Lanes}
\label{sec:lanes}
\todo{link to the JSON part and give a brief explanation}

\subsubsection{Flat Constraints}
\label{sec:flat-constraints}

Flat constraints provide no extra helpers to declare structural properties of the query. 
They consist of arbitrary basic constraints \cref{sec:basic-constraints} and disallow global constraints (\ref{sec:global-constraints}). \todo{a word on the differences between flat and global constraints}

\subsubsection{Sequence Constraints}
\label{sec:sequence-constraints}

As the most basic form of structural constraints this type is used to match sequences of \repoLink{\modelsUrl members/item/Item.java}{items} or nodes in the target corpus.
\iql uses square brackets (\keyword{[} and \keyword{]}) to mark individual nodes.
Each node can have arbitrarily complex internal constraints (composed of basic constraints, cf. \ref{sec:basic-constraints}) that have implicit access to annotations and structural information (e.g. host container) of the item the node is matched against.
Multiple nodes in a sequence declaration are required to match to items in exactly the order they are defined in (but not necessarily adjacent to each other, use the \keyword{ADJACENT} directive in front of a node sequence for that).

\paragraph{Examples:}

\begin{verbatim}
[]                  // empty node
[pos=="NN"]         // node with local constraint
<2>[$x:]            // node x exactly 2 times       
[$x:]<2-5>[][$y:]   // nodes x & y with 2-5 nodes in between
[$x:] ![$y:]        // node x without any node y following
ADJACENT [$x:][$y:] // node y directly following node x
[$x:] or [$y:]      // disjunction: either x OR y
{[$x:][$y:]} or [$z:] // disjunction: either group x+y OR z
\end{verbatim}

\paragraph{Sequence Matching}
\noindent Sequence constraints only provide a single dimension for \textit{moving} the query sequence through the search space of the target corpus.
Matching is performed greedily in order of node appearance in the query, following the direction specified by the corpus itself.
If the switch to reverse direction (cf. \ref{sec:json-ld-switches}) is set, then matching attempts will start from the very end of each matching context (such as a container or structure), but the order of nodes to match will remain the same.
That is, in a node sequence \verb|[$x:][$y:]| the node matched by \member{x} will \textbf{always} be before the node matched by \member{y} according to the original direction of items in the corpus.
Only the direction from which the overall matching attempt will start changes with the respective switch.
This also leads to a very simple and intuitive semantic for the \keyword{FIRST} and \keyword{LAST} modifier keywords: They stay true to their names and limit the returned match to either the first or last, with respect to the current direction.

\paragraph{Special Note:}
\noindent Evaluation of quantified nodes in \iql is done greedily, i.e. the engine will try to match as many instances as possible.
However, since an empty node does only provide the constraint of existential quantification, the above example will find the first occurrence of pair c+d after the initial hit on pair a-b.
An extension of the quantifier syntax or a change in the ``at most'' semantics is on the drawing board, but currently not considered to be implemented (a new keyword \keyword{inf} could potentially be used with the ``at most'' quantifier to create a hint to greedily expand empty nodes to the total limit instead of a ``first hit'' eager strategy, such as \texttt{<inf->}).

\paragraph{Node Grouping}
\noindent Nodes can be grouped together within curly brackets (\keyword{\{} and \keyword{\}}).
This is useful for either restricting the scope of modifiers or directives such as the \keyword{ADJACENT} keyword to only a selected few nodes or when expressing a disjunction.
Note that a group counts as an individual node statement inside the outer scope and as such is subject to order directives defined there.
However, those directives are \textbf{not} automatically inherited to the inner collection of nodes in the group, allowing for expressions such as the following:
\begin{verbatim}
ADJACENT [$x:] {[$a:][$b:]} {[$c:][$d:]} [$y:]
\end{verbatim}
This would read as ``Find x immediately followed by a, later followed by b+c, later followed by d+y''.
Currently there are only two directives available to specify the node arrangement (\keyword{ORDERED} and \keyword{ADJACENT}), but this might increase in the future, making node grouping a very important tool for defining complex structural compositions.
The concept of node grouping is especially important for the tree (\ref{sec:tree-constraints}) and graph (\ref{sec:graph-constraints}) constraints introduced below, as by default those do not impose an a priori order of nodes.

Empty nodes with quantifiers can be used as proxies to model distance constraints, as seen in above examples.
Since the \keyword{ADJACENT} directive changes the behavior of an entire node sequence, some creativity can be necessary to achieve mixed cases, such as \textit{``find an adjacent pair a+b that is later followed by another adjacent pair c+d''}.
A possible (and simple) solution for this query would be the following:
\begin{verbatim}
ADJACENT [$a:][$b:] <0+>[] [$c:][$d:]
\end{verbatim}

\subsubsection{Tree Constraints}
\label{sec:tree-constraints}

Located between mere sequences (\ref{sec:sequence-constraints}) and graphs (\ref{sec:graph-constraints}) this type of structural constraints is meant to target tree structures, such as (but not limited to) syntax trees, coreference structures, discourse, etc.
To simplify query syntax, \iql uses a similar approach as the original ICARUS project, which in turn took inspiration from PML-TQ:
To signal parent-child relations, child nodes are nested within their respective parent, effectively making each node yet another scope for a sequence of child nodes.
Contrary to bare sequence constraints (\ref{sec:sequence-constraints}) the order of (child) nodes to be matched in the corpus is \textbf{not} implicitly defined by the order of constraint nodes!
Instead, the \keyword{ORDERED} or \keyword{ADJACENT} keywords need to be used explicitly to signal that a specific kind of order should be honored.
Apart from this little addendum tree constraints behave basically the same as nested sequence constraints:
They can be individually quantified or existentially negated, as well as grouped and linked via the \keyword{OR} keyword to expression disjunctions.

\paragraph{Examples:}

\begin{verbatim}
[[]]              // anonymous nesting of nodes
[$x: [$y:]]       // nesting of node y inside x
[[$x:] [$y:]]     // nesting of siblings x and y
[$x: [$y: [$z:]]] // deep nesting chain 
[$x: <2->[$y:]]   // at most 2 y nested inside x
[$x: ![$y:]]      // node x without any child matching y

// internal disjunction
[[$x:] or [$y:] or {[$z: <4+>[]]}]
\end{verbatim}

\paragraph{Tree Matching}

\noindent As opposed to sequences (\ref{sec:sequence-constraints}), trees (and subsequently also graphs, cf. \ref{sec:graph-constraints}) offer an additional dimension of matching freedom over the bare iteration of items in a container or structure to be matched.
This requires further specification of the matching process to guarantee consistent results and define basic expectations.
Below explanations are primarily intended to specify the behavior in the presence of limiting modifiers (\keyword{FIRST}, \keyword{LAST}, \keyword{ANY}) in the payload, but are also of interest for the expected order of returned matches if no limiting modifiers are defined.

\begin{wrapfigure}{R}{0.5\textwidth}
	\centering
\begin{forest}
	for tree={
		if n children=0{
			tier=terminal
		}{},
	}
	[Root 
		[A\textsubscript{1} [1]] 
		[A\textsubscript{2} 
			[\textcolor{darkgreen}{X\textsubscript{1}} 
				[A\textsubscript{3} [2]]  
				[\textcolor{darkgreen}{Y\textsubscript{1}}
					[A\textsubscript{4} [3]]
					[A\textsubscript{5} [4]] 
				] 
				[\textcolor{darkred}{Y\textsubscript{2}} [5]] 
			]
		]		
		[\textcolor{darkred}{X\textsubscript{2}} 
			[A\textsubscript{6} [6]]  
			[\textcolor{darkred}{Y\textsubscript{3}} [7]] 
		] 
	]
\end{forest}
\caption{\label{fig:tree-matching} Example tree with highlighted hits for the query \texttt{[\$x: [\$y:]]}.}
\end{wrapfigure}

Consider a simple tree query \verb|[$x: [$y:]]| where x and y are bound nodes with individual constraints.
The nodes X\textsubscript{n} or Y\textsubscript{n} in the example tree (\cref{fig:tree-matching}) then denote the n-th node that match the constraints of query nodes x and y, respectively.

The tree contains 3 possible matches for the query, specifically the pairs \texttt{\{X\textsubscript{1},Y\textsubscript{1}\}}, \texttt{\{X\textsubscript{1},Y\textsubscript{2}\}} and \texttt{\{X\textsubscript{2},Y\textsubscript{2}\}}.
\todo{expand on the order of matches}

\noindent\texttt{[Root 
	[A\textsubscript{1}] 
	[A\textsubscript{2} 
	[\textcolor{darkgreen}{X\textsubscript{1}} 
	[A\textsubscript{3}]  
	[\textcolor{darkgreen}{Y\textsubscript{1}}
	[A\textsubscript{4}]
	[A\textsubscript{5}]] 
	[\textcolor{darkred}{Y\textsubscript{2}}]]]		
	[\textcolor{darkred}{X\textsubscript{2}} 
	[A\textsubscript{6}]  
	[\textcolor{darkred}{Y\textsubscript{3}}]]]
}

\subsubsection{Graph Constraints}
\label{sec:graph-constraints}

\todo[inline]{content}

\subsubsection{Global Constraints}
\label{sec:global-constraints}

Global constraints con be any basic constraint \cref{sec:basic-constraints} and follow after the main section of structural constraints, indicated by the \keyword{HAVING} keyword.
\todo{examples and more explanation of what is available (members, etc) + complexity!!!}

\paragraph{Evaluation Priorities}
\noindent If global constraints are present, the evaluation process changes to a two-stage strategy:
Matchers for the associated structural constraints produce preliminary result candidates and the global constraints are then evaluated for each such candidate.
This makes global constraints both very powerful as they have access to more information compared to regular (internal or local) constraints (e.g. they already \textit{know} that all local constraints evaluated to \keyword{true} and the exact candidates produced for structural constraints) and also very critical when it comes to performance.
It can be very tempting to construct queries such as the following one (bindings section omitted) that only matches when \member{y} is the last child of \member{x}:
\begin{verbatim}
FIND [$x: [$y:]] HAVING $x.indexOf($y) == $x.size-1
\end{verbatim}
This will cause the structural matcher to potentially propose \textbf{all} children of \member{x} as candidates to be processed by the global constraints section.
Subsequently, for a node of size $N$ this will produce $N-1$ candidates that are bound to fail the global constraint check.
\cref{sec:utility} lists several families of utility markers and functions that can be used to signal the evaluation engine that certain local constraints are to be treated as special filters.
With the use of those utility markers, above query looks like the following and will be vastly more efficient to evaluate:
\begin{verbatim}
FIND [$x: [$y: isLast]]
\end{verbatim}
Similarly global constraints are not the place to perform filtering on general properties of the current \ac{uoi}, such as sentence length (use the \keyword{FILTER BY} expression for that, cf. \cref{sec:filter-constraints}).

\subsection{Result Processing}
\label{sec:result-processing}

There be dragons\dots

(Content of the result section will be added as \iql evolves)

\section{Utility Markers \& Functions}
\label{sec:utility}

The following utility features are provided by the \ac{iqp} but are \textbf{not} part of the core specification. 
As such it is possible for engine extensions to override them, change their behavior or completely remove them if desired.
They are listed here as per default they all are available and provide valuable improvements for performance and usability.

\subsection{Position Markers}
\label{sec:position-markers}

Every node (\ref{sec:sequence-constraints}) in a query has an implicit \repoLink{\modelsUrl /members/container/Container.java}{Container} or \repoLink{/members/structure/Structure.java}{Structure} context that it is hosted  or contained in.\footnote{The \ac{icmf} specifies that each item can only be hosted (or \textit{owned}) by a single container or derived object, but be contained within an arbitrary number of additional containers or structures.}
\todo{describe the situations possible for nodes (root, top-level, nested) with implicit/explicit parent, and then list the isFirst, isLast, etc markers}

\subsection{Tree Functions}
\label{sec:tree-functions}

\subsection{Graph Functions}
\label{sec:graph-functions}

\end{document}