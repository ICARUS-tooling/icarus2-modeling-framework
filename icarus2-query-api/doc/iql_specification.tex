%
% File iql_specification.tex
%

\documentclass[11pt,a4paper]{report}

\usepackage{../../doc/icarus2}


\newcommand{\iqlType}[1]{\texttt{\iqlns#1}}
\newcommand{\iqlBaseType}[1]{\texttt{\textless#1\textgreater}}

% Environment to wrap JSON attributes of IQL elements into tables
\newenvironment{attributes}[1]{
	\noindent\textbf{Attributes of #1:}\newline\medskip
	\begin{tabular}{|p{0.3\textwidth}|p{0.20\textwidth}|p{0.20\textwidth}|p{0.17\textwidth}|}
		\hline
		\textbf{Attribute} & \textbf{Type} & \textbf{Required} & \textbf{Default} \\ 
		\hline
		\hline
	}{
	\end{tabular}
}
% shorthand methods for filling attributes table: name, type, required, default
\newcommand{\attribute}[4]{
	#1 & #2 & #3 & #4 \\
	\hline
}

% Environment to wrap nested JSON elements of IQL elements into tables
\newenvironment{elements}[1]{
	\noindent\textbf{Nested Elements of #1:}\newline\medskip
	\begin{tabular}{|p{0.3\textwidth}|p{0.42\textwidth}|p{0.17\textwidth}|}
		\hline
		\textbf{Element} & \textbf{Type} & \textbf{Required} \\ 
		\hline
		\hline
	}{
	\end{tabular}
}
% shorthand methods for filling elements table: name, type, required
\newcommand{\element}[3]{
	#1 & #2 & #3 \\
	\hline
}

\title{ICARUS2 Query Language Specification}

\author{Markus GÃ¤rtner}

\date{2020}

\begin{document}

\maketitle

\tableofcontents

\listoffigures

\listoftables

\listoftodos

\newpage

\chapter*{Introduction}
\label{chap:intro}

Queries in the \ac{iql} are designed to be self-contained with logical sections for specifying all the information required to determine the target of a query and its granularity, resolve additional dependencies such as extensions or scripts, link and validate constraints to parts of the target corpus or corpora and finally optional pre- and post-processing steps.
To achieve this complex task \ac{iql} embeds a keyword-based syntax for the query payload within a JSON-LD structure to drive declaration of all the aforementioned information. 
As a side effect queries can become quite verbose and potentially cumbersome to define manually. 
As a countermeasure the overall structure of a query is composed of blocks that can be glued together incrementally and that make it very easy for an application built on top of it to provision boilerplate query code based on settings or a GUI so that the user only needs to type the actual constraints used in the query (the so called \textit{query payload}, cf. \cref{chap:inner-iql-elements}). 
This document lists the basic building blocks of queries and their compositions.

\Cref{chap:elements} gives an overview on the JSON-LD elements available in the ``outer'' section of the \ac{iql} protocol.
\Cref{chap:inner-iql-elements} provides the specification for the actual query language used in a query's ``inner'' payload and \cref{chap:utility} finally contains various collections of utility functions available to make queries both simpler to declare and more efficient to evaluate by the \ac{icqp}.

\chapter{JSON-LD Elements}
\label{chap:elements}

The ``outer layer'' of every serialized \ac{iql} query is a JSON-LD object with various (optional) properties to hold all the required information for proper query evaluation.

The following snippet shows the mockup of a simple query that searches the TIGER corpus for word pairs starting with an adjective and ending in a word with the surface form ``test'', ignoring case and only returning up to 100 hits in a \ac{kwic} style. 
The query also features an import statement for the STTS part-of-speech tagset, allowing more controlled expressions inside query constraints.
\medskip

\lstinputlisting[language=json,basicstyle=\small\ttfamily]{res/iql-mockup-query-no-payload.json}

\todo{say something about the namespace and general iql: prefixing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     BINDING
\section{Binding}
\label{sec:json-ld-binding}
%\begin{itemize}
%	\item distinct
%	\item target
%	\item edges
%	\item members
%\end{itemize}
\desc{A binding associates a collection of member variables (\ref{sec:variables-references}) with the content of a specific \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} or derived layer type.}
\begin{attributes}{\iqlType{Binding}}
	\attribute{distinct}{Boolean}{no}{false}
	\attribute{edges}{Boolean}{no}{false}
	\attribute{target}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{distinct}] Enforces that the bound member references in this binding do \textbf{not} match the same target items during evaluation. Depending on the structural constraints used in the query, this setting might be redundant (e.g. when using the member references as identifiers for tree nodes who already are structurally distinct), but can still be used to make that fact explicit. 
	\item[\iqlType{edges}] Signals that the member labels are to be used for \repoLink{\modelsUrl members/item/Edge.java}{edges} within a \repoLink{\modelsUrl members/structure/Structure.java}{structure}.
	\item[\iqlType{target}] The name or alias of the layer to whose content the member variables should be bound.
\end{description}
\begin{elements}{\iqlType{Binding}}
	\element{members}{array of \iqlType{Reference} (\ref{sec:json-ld-reference})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{members}] Non-empty collection of member references that are bound to the target layer's content. Every such instance of \iqlType{Reference} (\ref{sec:json-ld-reference}) must be unique within the surrounding \iqlType{Payload} (\ref{sec:json-ld-payload}).
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     CONSTRAINT
\section{Constraint}
\label{sec:json-ld-constraint}
%\begin{itemize}
%	\item id
%	\item solved
%	\item solvedAs
%\end{itemize}
\desc{Constraints represent the actual content filtering of every query.}
\begin{attributes}{\iqlBaseType{Constraint}}
	\attribute{id}{string}{yes}{}
	\attribute{solved}{Boolean}{no}{false}
	\attribute{solvedAs}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the constraint within the entire query.
	\item[\iqlType{solved}] Hint for the evaluation engine that this constraint has already been solved, either by a back-end implementation or as a result of (partial) query evaluation by the engine itself.
	\item[\iqlType{solvedAs}] Specifies to what Boolean value (\keyword{true} or \keyword{false}) the constraint has been evaluated.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PREDICATE
\subsection{Predicate}
\label{sec:json-ld-predicate}
%\begin{itemize}
%	\item expression
%\end{itemize}
\desc{Wraps a Boolean \iqlType{Expression} into an atomic constraint element that represents the smallest unit of evaluation for the top-level evaluation engine.}
\extends{\iqlBaseType{Constraint}}{\ref{sec:json-ld-constraint}}
\begin{elements}{\iqlType{Predicate}}
	\element{expression}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{expression}] The actual expression to be evaluated to a Boolean result. Note that typically this expression \textbf{cannot} be composed of directly nested Boolean conjunctions or disjunctions, as the engine will have parsed those into \iqlType{Term} (\ref{sec:json-ld-term}) objects already during the first processing phase.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     TERM
\subsection{Term}
\label{sec:json-ld-term}
%\begin{itemize}
%	\item items
%	\item operation
%\end{itemize}
\desc{A collection of constraints with a logical connective.}
\extends{\iqlBaseType{Constraint}}{\ref{sec:json-ld-constraint}}
\begin{attributes}{\iqlType{Term}}
	\attribute{operation}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{operation}] The Boolean connective to be applied to all the constraint items. Legal values are the strings ``conjunction'' or ``disjunction''.
\end{description}
\begin{elements}{\iqlType{Term}}
\element{items}{array of \iqlType{Constraint} (\ref{sec:json-ld-constraint})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{items}] The constraints which are to be combined by the specified \iqlType{operation}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Corpus}
\label{sec:json-ld-corpus}
%\begin{itemize}
%\item id
%\item name
%\item pid
%\end{itemize}
\desc{Top-level entry point for querying a single stream.}
\begin{attributes}{\iqlType{Corpus}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{pid}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the corpus within the entire query.
	\item[\iqlType{name}] The identifier used by the query engine's \repoLink{\manifestsUrl ManifestRegistry.java}{manifest registry} for the corpus.
	\item[\iqlType{pid}] Optional external identifier used for the corpus. This can be any persistent identifier such as a DOI, VLO-Handle or similar means of referencing a resource.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     DATA
\section{Data}
\label{sec:json-ld-data}
%\begin{itemize}
%\item id
%\item name
%\item content
%\item codec
%\item checksum
%\item checksumType
%\end{itemize}
\desc{Allows to embed binary data in the query and make it usable from within constraint expressions via a designated reference.}
\begin{attributes}{\iqlType{Data}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{content}{string}{yes}{}
	\attribute{codec}{string}{no}{hex}
	\attribute{checksum}{string}{no}{}
	\attribute{checksumType}{enum}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the corpus within the entire query.
	\item[\iqlType{name}] The identifier used for the expression (\ref{sec:expressions}) which can be used to reference the binary payload from within query constraints.
	\item[\iqlType{content}] The actual content of the payload in textual form. How to properly convert the textual form to a binary stream is defined by the \iqlType{codec} attribute.
	\item[\iqlType{codec}] Specifies the mechanism of converting the \iqlType{content} data into an actual binary stream. If left empty, defaults to \texttt{hex}.
	\item[\iqlType{checksum}] Optional hex-string of the checksum to check the \iqlType{content} against.
	\item[\iqlType{checksumType}] Defines the algorithm for computing the checksum. Currently only \texttt{MD5} is supported as legal value.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     ELEMENT
\section{Element}
\label{sec:json-ld-element}
%\begin{itemize}
%\item id
%\item consumed
%\end{itemize}
\desc{Abstract base type for all logical and/or structural units that can be matched against content of a target corpus.}
\begin{attributes}{\iqlBaseType{Element}}
	\attribute{id}{string}{yes}{}
	\attribute{consumed}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the element within the entire query.
	\item[\iqlType{consumed}] Signals that the element has already been \textit{used up} in the context of a partial query evaluation. An element that has been consumed can safely be ignored in the further evaluation of the query. Note that this state can be propagated according to the following rules:
	\begin{itemize}[leftmargin=*,topsep=0pt]\compresslist
		\item An \iqlType{Node}(\ref{sec:json-ld-node}) can be marked as \texttt{consumed} if its \iqlType{constraint} is marked as \texttt{solved} and its match count satisfies the \iqlType{quantifiers} requirement. Note that cross-referencing constraints can only be considered solved when all other aspects of the involved elements support the \texttt{consumed} state.
		\item An \iqlType{TreeNode}(\ref{sec:json-ld-tree-node}) can be marked as \texttt{consumed} if above conditions are met and all nested \iqlType{children} are marked \texttt{consumed}.
		\item An \iqlType{Edge}(\ref{sec:json-ld-edge}) is considered \texttt{consumed} when both its terminals are \texttt{consumed} and the same conditions regarding its \iqlType{constraint} are fulfilled as mentioned above.
		\item An \iqlType{ElementDisjunction}(\ref{sec:json-ld-element-disjunction}) is considered \texttt{consumed} if at least one of its \iqlType{alternatives} has been marked \texttt{consumed}.
	\end{itemize}
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     SEQUQNCE
\subsection{Sequence}
\label{sec:json-ld-sequence}
%\begin{itemize}
%\item nodes
%\item arrangement
%\end{itemize}
\desc{Wrapper around a list of \iqlType{Element} (\ref{sec:json-ld-element}) instances to group them for either nesting or disjunction.}
\extends{\iqlType{Element}}{\ref{sec:json-ld-element}}
\begin{attributes}{\iqlType{NodeSet}}
	\attribute{arrangement}{enum}{no}{unspecified}
\end{attributes}
\begin{description}
	\item[\iqlType{arrangement}] Defines what kind of order or arrangement should be assumed between the elements in this sequence. Legal values are \texttt{unspecified}, \texttt{ordered} (matched elements must occur in exactly the order specified in this set but need not form a continuous span) or \texttt{adjacent} (matched elements must form a continuous span).
\end{description}
\begin{elements}{\iqlType{NodeSet}}
	\element{nodes}{array of \iqlBaseType{Element} (\ref{sec:json-ld-element})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{nodes}] List of nested \iqlBaseType{Element} instances. Legal types depend on the context in which this sequqnce is being used.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     GROUPING
\subsection{Grouping}
\label{sec:json-ld-grouping}
%\begin{itemize}
%\item elements
%\item quantifiers
%\end{itemize}
\desc{Wrapper around an \iqlType{Element} (\ref{sec:json-ld-element}) instance to allow for additional grouping and/or quantification.}
\extends{\iqlType{Element}}{\ref{sec:json-ld-node}}
\begin{elements}{\iqlType{ElementGrouping}}
	\element{element}{\iqlBaseType{Element} (\ref{sec:json-ld-element})}{no}
	\element{quantifiers}{array of \iqlType{Quantifier} (\ref{sec:json-ld-quantifier})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{element}] Nested \iqlBaseType{Element} instance. Legal types depend on the context in which this grouping is being used.
	\item[\iqlType{quantifiers}] Optional quantifiers to define the multiplicity of matches of this grouping required for a positive evaluation. Multiple quantifiers behave disjunctively.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     NODE
\subsection{Node}
\label{sec:json-ld-node}
%\begin{itemize}
%\item label
%\item constraint
%\item quantifiers
%\end{itemize}
\desc{Logical unit for sequence or graph matching in a target corpus. May contain local constraints and can also be quantified.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{attributes}{\iqlType{Node}}
	\attribute{label}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{label}] Identifier to bind the node through a previously defined \iqlType{Binding} (\ref{sec:json-ld-binding}) declaration.
\end{description}
\begin{elements}{\iqlType{Node}}
	\element{constraint}{\iqlBaseType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{quantifiers}{array of \iqlType{Quantifier} (\ref{sec:json-ld-quantifier})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{constraint}] Optional local constraint to be matched against the content of potential target candidates during query evaluation.
	\item[\iqlType{quantifiers}] Optional quantifiers to define the multiplicity of matches of this node required for a positive evaluation. Multiple quantifiers behave disjunctively.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     TREE NODE
\subsection{Tree Node}
\label{sec:json-ld-tree-node}
%\begin{itemize}
%\item children
%\end{itemize}
\desc{Extension of the simple \iqlType{Node} type (\ref{sec:json-ld-node}) to add implicit hierarchical constraints related to dominance within tree structures.}
\extends{\iqlType{Node}}{\ref{sec:json-ld-node}}
\begin{elements}{\iqlType{TreeNode}}
	\element{children}{instance of \iqlBaseType{Element} (\ref{sec:json-ld-element})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{children}] Optional nested nodes or node alternatives.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     EDGE
\subsection{Edge}
\label{sec:json-ld-edge}
%\begin{itemize}
%\item label
%\item constraint
%\item source
%\item target
%\item edgeType
%\end{itemize}
\desc{Specialized element extension to query structural information in graphs.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{attributes}{\iqlType{Edge}}
	\attribute{label}{string}{no}{}
	\attribute{edgeType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{label}] Identifier to bind the edge through a previously defined \iqlType{Binding} (\ref{sec:json-ld-binding}) declaration.
	\item[\iqlType{edgeType}] The type specification for this edge, primarily a directionality information. Legal values are \texttt{simple}, \texttt{one-way} or \texttt{two-way}.
\end{description}
\begin{elements}{\iqlType{Edge}}
	\element{constraint}{\iqlBaseType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{source}{\iqlType{Node} (\ref{sec:json-ld-node})}{yes}
	\element{target}{\iqlType{Node} (\ref{sec:json-ld-node})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{constraint}] Optional local constraint to be matched against the content of potential target candidates during query evaluation.
	\item[\iqlType{source}] Source node declaration. 
	\item[\iqlType{target}] Target node declaration. 
\end{description}
For complex graph declarations multiple nodes can be defined having the same \iqlType{label}. The evaluation engine will treat them as being the same node. Note however, that at most \textbf{one} node per label is allowed to declare a local \iqlType{constraint} attribute!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     ELEMENT DISJUNCTION
\subsection{Element Disjunction}
\label{sec:json-ld-element-disjunction}
%\begin{itemize}
%	\item alternatives
%\end{itemize}
\desc{Allows declaration of multiple alternative element definitions. When evaluating the query, each such alternative that is matched successfully will cause this element declaration to evaluate positively.}
\extends{\iqlBaseType{Element}}{\ref{sec:json-ld-element}}
\begin{elements}{\iqlType{ElementDisjunction}}
	\element{alternatives}{array of \iqlType{Element} (\ref{sec:json-ld-element})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{alternatives}] The alternative element declarations, each of which constitutes a legal match for this element declaration. Must not contain less than 2 elements!
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     EXPRESSION
\section{Expression}
\label{sec:json-ld-expression}
%\begin{itemize}
%\item content
%\item resultType
%\end{itemize}
\desc{Wraps the textual form of an arbitrarily complex \ac{iql} expression, which can be a formula, literal, method invocation, a combination of those or a great many other types of expressions. For more details see \cref{sec:expressions}.}
\begin{attributes}{\iqlType{Expression}}
	\attribute{content}{string}{yes}{}
	\attribute{resultType}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{content}] The textual form of the expression. Must be valid according to the specifications in \cref{sec:expressions}.
	\item[\iqlType{resultType}] An optional specification regarding the return type of the expression. Redundant when the expression is used as a constraint, as those are required to always evaluate to a Boolean result value anyway.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     GROUP
\section{Group}
\label{sec:json-ld-group}
%\begin{itemize}
%\item id
%\item groupBy
%\item filterOn
%\item label
%\item defaultValue
%\end{itemize}
\desc{Provides a mechanism to collect successful matches into dedicated groups, either for result visualization or use in further result processing.}
\begin{attributes}{\iqlType{Group}}
	\attribute{id}{string}{yes}{}
	\attribute{label}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the group declaration within the entire query.
	\item[\iqlType{label}] Label (ideally human readable) to be used for referencing this group in subsequent result processing or for generating textual result reports.
\end{description}
\begin{elements}{\iqlType{Group}}
	\element{groupBy}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
	\element{filterOn}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{no}
	\element{defaultValue}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{groupBy}] The mandatory expression used to extract the value from matches based on which the actual grouping occurs.
	\item[\iqlType{filterOn}] Optional mechanism to exclude certain matches from being used for grouping.
	\item[\iqlType{defaultValue}] If matches cannot produce a valid value for grouping but should still be included in the process, this optional field provides the means of declaring a kind of ``fall back'' group. Be aware of potential overlap in groups when using default values that are not distinct from the regular grouping results.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     IMPORT
\section{Import}
\label{sec:json-ld-import}
%\begin{itemize}
%\item id
%\item name
%\item optional
%\end{itemize}
\desc{To allow for flexible integration of macro definitions or bigger language extensions, \ac{iql} provides an optional section in the query that lets users specify exactly what additional modules besides the bare \ac{iql} core are required for evaluating the query. Each import target is specified by providing it's unique name and telling the engine whether or not the import is to be considered optional.}
\begin{attributes}{\iqlType{Import}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{optional}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the import within the entire query.
	\item[\iqlType{name}] The original name of the extension to be added.
	\item[\iqlType{optional}] Defines whether or not the referenced extension is optional. 	Non-optional imports that cannot be resolved to an actual extension during the query evaluation phase will cause the entire process to fail.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     LANE
\section{Lane}
\label{sec:json-ld-lane}
%\begin{itemize}
%\item id
%\item name
%\item alias %stores the member name used to reference the entire structure/sentence
%\item laneType
%\item element
%\end{itemize}
\desc{Lanes serve as a means of splitting queries for a single corpus stream into multiple logical subqueries that target different structural and/or logical layers, e.g. multiple syntactic analyses for the same source text.}
\begin{attributes}{\iqlType{Lane}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{alias}{string}{no}{}
	\attribute{laneType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the lane within the entire query.
	\item[\iqlType{name}] The unique identifier of the \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} or \repoLink{\modelsUrl layer/StructureLayer.java}{structure layer} that serves as target for this lane.
	\item[\iqlType{alias}] If items of this lane in their entirety are meant to be used as part of query expressions inside this field holds the label used for the respective member variable. It is recommended to keep the chosen \texttt{alias} close to the original \texttt{name} to avoid confusion.
	\item[\iqlType{laneType}] The type of structure this lane is meant to match, effectively defining the basic complexity class for evaluation. legal values are \texttt{sequence}, \texttt{tree} and \texttt{graph}. Note that the initial evaluation engine for \ac{iql} does not support the \texttt{graph} type! %TODO adjust once we extend the engine
\end{description}
\begin{elements}{\iqlType{Lane}}
	\element{element}{\iqlBaseType{Element} (\ref{sec:json-ld-element})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{element}] The structural constraints to be used for evaluation of this lane.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     LAYER
\section{Layer}
\label{sec:json-ld-layer}
%\begin{itemize}
%\item id
%\item name
%\item alias
%\item primary
%\item allMembers
%\end{itemize}
\desc{Every layer selector either references an entire subgraph of the corpus' member-graph directly or constructs a partial selection as part of a \iqlType{Scope} (\ref{sec:json-ld-scope}). 
When using the first approach, an \repoLink{\modelsUrl layer/ItemLayer.java}{item layer} is referenced and all its dependencies and associated annotation layers will be made available implicitly. 
This is an easy way of accessing simple corpora, but can lead to costly I/O overhead when loading vast parts of a complex corpus that aren't actually needed to evaluate the query. 
For a more fine-grained alternative, scopes allow to create a scope that spans an exactly specified collection of layers. 
If multiple layer selectors are defined, up to one can be declared as ``primary'' to represent the granularity of returned items for the search or scope.
In case no layer is explicitly marked as ``primary'', the one specified by the corpus or context will be used for that role by default.}
\begin{attributes}{\iqlType{Layer}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{alias}{string}{no}{}
	\attribute{primary}{Boolean}{no}{false}
	\attribute{allMembers}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the layer within the entire query.
	\item[\iqlType{name}] Identifier used to reference the layer within its host corpus.
	\item[\iqlType{alias}] Optional identifier to rename the layer for referencing within the query.
	\item[\iqlType{primary}] Signals that the layer is intended to act as the primary layer in the query or scope and as such defines the level of granularity for obtaining chunks in the corpus.
	\item[\iqlType{allMembers}] When this layer definition is used inside a \iqlType{Scope} (\ref{sec:json-ld-scope}), effectively adds the entire member-subgraph of this layer to the scope. This property is redundant when the layer is part of the regular \iqlType{layers} declaration in a \iqlType{Stream} (\ref{sec:json-ld-stream}), as in that case all member subgraphs for each layer are already being added to the global scope!.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     MARKER
\section{Marker}
\label{sec:json-ld-marker}
\desc{Abstract base type for all positional, hierarchical or other sorts of (tree) markers available in \ac{iql}.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     MARKER CALL
\subsection{Marker Call}
\label{sec:json-ld-marker-call}
%\begin{itemize}
%\item name
%\item arguments
%\end{itemize}
\desc{Identifies a marker by name and optionally provides a set of numerical arguments for instantiating the marker.}
\extends{\iqlBaseType{Marker}}{\ref{sec:json-ld-marker}}
\begin{attributes}{\iqlType{MarkerCall}}
	\attribute{name}{string}{yes}{}
\end{attributes}
\begin{description}
\item[\iqlType{name}] The name to uniquely identify the marker. Although in their introduction chapter \ref{chap:utility} they appear camel-cased, actual resolution of markers by name is done case-insensitive.
\end{description}
\begin{elements}{\iqlType{Payload}}
\element{arguments}{array of numbers}{no}
\end{elements}
\begin{description}
\item[\iqlType{arguments}] Optional array of numerical arguments for the marker. Note that markers support both absolute (integer) and relative (floating point) index arguments, as well as negative ones to express reverse indices.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     MARKER EXPRESSION
\subsection{Marker Expression}
\label{sec:json-ld-marker-expression}
%\begin{itemize}
%\item expressionType
%\item items
%\end{itemize}
\desc{Used to group multiple markers into boolean expressions.}
\extends{\iqlBaseType{Marker}}{\ref{sec:json-ld-marker}}
\begin{attributes}{\iqlType{MarkerExpression}}
	\attribute{expressionType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{expressionType}] Defines whether the group should be treated as a \texttt{disjunctive} or \texttt{conjunctive} expression. \texttt{disjunctive}
\end{description}
\begin{elements}{\iqlType{Payload}}
	\element{items}{array of \iqlBaseType{Marker}(\ref{sec:json-ld-marker})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{items}] List of the nested markers to be evaluated.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PAYLOAD
\section{Payload}
\label{sec:json-ld-payload}
%\begin{itemize}
%\item id
%\item name
%\item queryType
%\item bindings
%\item lanes
%\item constraint
%\end{itemize}
\desc{Every payload encapsulates all the (processed) query constraints to be evaluated against a single stream of corpus data.}
\begin{attributes}{\iqlType{Payload}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{no}{}
	\attribute{queryType}{enum}{yes}{}
	\attribute{queryModifier}{enum}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Automatically generated identifier to uniquely identify the payload within the entire query.
	\item[\iqlType{name}] Custom identifier to uniquely identify the payload within the entire query. This attribute is deprecated but currently being kept to shift its use case.
	\item[\iqlType{queryType}] The overall type of query strategy to be applied for this query payload. Legal values are \texttt{all} (returns the entire corpus and disallows any kind of constraint, leaving only the \iqlType{Result} (\ref{sec:json-ld-result}) declaration as option to modify the result volume), \texttt{plain} (disabling any kind of structural constraints/lanes), \texttt{singleLane} and \texttt{multiLane}. The last two values dictate the minimal/maximal number of \iqlType{Lane} definitions in this payload.
	\item[\iqlType{queryModifier}] Allows to limit the number of times an individual \acp{uoi} will be returned in the result. Supported values are \texttt{first}, \texttt{last} and \texttt{any}. The specific semantics of this modifier are described in more details in \cref{sec:constraints}.
\end{description}
\begin{elements}{\iqlType{Payload}}
	\element{bindings}{array of \iqlType{Binding} (\ref{sec:json-ld-binding})}{no}
	\element{lanes}{array of \iqlType{Lane} (\ref{sec:json-ld-lane})}{no}
	\element{filter}{\iqlType{Constraint} (\ref{sec:json-ld-constraint})}{no}
	\element{constraint}{\iqlType{Constraint} (\ref{sec:json-ld-constraint})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{bindings}] Optional collection of bindings used within this payload. Note that member variables inside constraints or structural query elements will not resolve unless previously bound to corpus members.
	\item[\iqlType{lanes}] If \iqlType{queryType} is set to \texttt{singleLane} or \texttt{multiLane}, this array is expected to hold either exactly 1 or at least 2 \iqlType{Lane} declarations that define structural constraint for the evaluation.
	\item[\iqlType{filter}] If \iqlType{queryType} is set to anything other than \texttt{plain}, this constraint expression allows to filter contextual \acp{uoi} prior to the actual structural matching.
	\item[\iqlType{constraint}] If \iqlType{queryType} is set to \texttt{plain}, this is expected to contain the basic constraints for matching candidates. In any version involving \iqlType{Lane} declarations, global constraints can be defined here as a means of implementing complex query features that are tested once the lanes have produced preliminary result candidates.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     PROPERTY
\section{Property}
\label{sec:json-ld-property}
%\begin{itemize}
%	\item key
%	\item value
%\end{itemize}
\desc{Allows customization of the evaluation process by changing parameters or switching certain features on/off.}
\begin{attributes}{\iqlType{Property}}
	\attribute{key}{string}{yes}{}
	\attribute{value}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{key}] The identifier of the targeted parameter or switch. The evaluation engine might report unknown keys as errors.
	\item[\iqlType{value}] The actual value to apply to the specified property in case it is not a switch.
\end{description}

\subsection{Switches}
\label{sec:json-ld-switches}
For increased flexibility, \ac{iql} supports a collection of switches to turn certain optional features on or off when needed. Switches are static and cannot be changed for the active query evaluation once set. All the native \ac{iql} switches use the prefix \texttt{iql:} for their name. Any extensions that offer additional switches should declare and use their own namespace for those switches! Currently supported switches are shown in \cref{tab:switches}.

\begin{table}[!htb]
\noindent\begin{tabular}{|p{0.35\textwidth}|p{0.58\textwidth}|}
\hline 
\textbf{Name}	& \textbf{Description} \\ 
\hline 
\hline
iql.string.case.off         & Turns of case sensitivity when performing string operations such as equality checks.  \\ 
\hline
iql.string.case.lower       & Another approach to case insensitivity, this switch turns all strings into lower case.  \\ 
\hline
iql.expansion.off           & Effectively shuts down value expansion \cref{sec:value-expansion}.  \\ 
\hline
iql.string2bool.off         & Deactivates the interpretation of strings as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.int2bool.off            & Deactivates the interpretation of integers as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.float2bool.off          & Deactivates the interpretation of floating point numbers as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.obj2bool.off            & Deactivates the interpretation of arbitrary objects as Boolean values as described in \cref{sec:constraints}.  \\ 
\hline
iql.any2bool.off            & Deactivates the interpretation of anything non-Boolean as Boolean value. This is a combination of ``iql.string2bool.off'', ``iql.int2bool.off'', ``iql.float2bool.off'' and  ``iql.obj2bool.off''.  \\ 
\hline
iql.direction.reverse       & Reverses the direction used to traverse top-level corpus data for a search.  \\ 
\hline
iql.array.zero              & Change array access (\ref{sec:list-access}) to be 0-based.  \\ 
\hline
iql.markers.position.relative & Allow position markers (\ref{sec:position-markers}) to use relative (percentage) arguments.  \\ 
\hline
iql.warnings.off            & Deactivates all warnings, potentially resulting in confusing results if there are mistakes in the query.  \\ 
\hline
iql.parall.off			  & Forces the query evaluation engine to run single-threaded. This does however only affect the actual matcher, not additional. modules such as monitoring or item caches  \\ 
\hline
\end{tabular}
\caption[Supported query switches]{Currently supported switches in \ac{iql} and their explanations.}
\label{tab:switches}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     QUANTIFIER
\section{Quantifier}
\label{sec:json-ld-quantifier}
%\begin{itemize}
%\item quantifierType
%\item value
%\item lowerBound
%\item upperBound
%\end{itemize}
\desc{Specifies the multiplicity of an associated \iqlBaseType{Element} (\ref{sec:json-ld-element}).}
\begin{attributes}{\iqlType{Quantifier}}
	\attribute{quantifierType}{enum}{yes}{}
	\attribute{value}{integer}{no}{}
	\attribute{lowerBound}{integer}{no}{}
	\attribute{upperBound}{integer}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{quantifierType}] Defines how to interpret the other attributes. Legal values are \texttt{all} (universal quantification), \texttt{exact}, \texttt{atMost} (0..n), \texttt{atLeast} (n+), \texttt{range} (n..m).
	\item[\iqlType{value}] Target or limit value when \iqlType{quantifierType} is set to \texttt{exact}, \texttt{atMost} or \texttt{atLeast}.
	\item[\iqlType{lowerBound}] Used for \texttt{range} quantification to define the minimum multiplicity.
	\item[\iqlType{upperBound}] Used for \texttt{range} quantification to define the maximum multiplicity.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     QUERY
\section{Query}
\label{sec:json-ld-query}
%\begin{itemize}
%\item id
%\item dialect
%\item imports
%\item setup
%\item embeddeData
%\item streams
%\end{itemize}
\desc{Encapsulates all the global configuration and extension of the query engine, as well as shared embedded data. Each query contains at least one \iqlType{Stream} declaration that in turn holds the actual query payload with constraints for the matching process.}
\begin{attributes}{\iqlType{Query}}
	\attribute{id}{string}{yes}{}
	\attribute{dialect}{string}{no}{1.0}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier for the query, chosen by the client. In more complex (asynchronous) query workflows this id is used to map answers and results to the correct query.
	\item[\iqlType{dialect}] Specifies which basic version of \ac{iql} to use. The initial version of \ac{iql} is ``1.0`` and by leaving the dialect part of a query blank the engine will default to this initial version.
\end{description}
\begin{elements}{\iqlType{Query}}
	\element{imports}{array of \iqlType{Import} (\ref{sec:json-ld-import})}{no}
	\element{setup}{array of \iqlType{Property} (\ref{sec:json-ld-property})}{no}
	\element{embeddeData}{array of \iqlType{Data} (\ref{sec:json-ld-data})}{no}
	\element{streams}{array of \iqlType{Stream} (\ref{sec:json-ld-stream})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{imports}] Defines extensions to be applied to the evaluation engine prior to actual query evaluation.
	\item[\iqlType{setup}] Allows to configure the core evaluation engine or already defined extensions in a simple manner.
	\item[\iqlType{embeddeData}] Binary data to be used in the evaluation process, such as audio or video fragments.
	\item[\iqlType{streams}] Corpus data streams to be queried. In the initial version, the engine only supports single-stream querying!
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     REFERENCE
\section{Reference}
\label{sec:json-ld-reference}
%\begin{itemize}
%\item id
%\item name
%\item referenceType
%\end{itemize}
\desc{Models references usable from within query expressions for accessing corpus members or variables.}
\begin{attributes}{\iqlType{Reference}}
	\attribute{id}{string}{yes}{}
	\attribute{name}{string}{yes}{}
	\attribute{referenceType}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the reference within the entire query.
	\item[\iqlType{name}] The local identifier to be used for addressing this reference. Note that this is the bare name without any type-specific prefixes (such as '\textdollar' for members, cf. \cref{sec:variables-references}).
	\item[\iqlType{referenceType}] Specifies the nature of this reference. Legal values are \texttt{reference}, \texttt{member} or \texttt{variable}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     RESULT
\section{Result}
\label{sec:json-ld-result}
%\begin{itemize}
%\item resultTypes
%\item resultInstructions
%\item limit
%\item percent
%\item sortings
%\end{itemize}
\desc{Encapsulates all the information on result processing and preparation.}
\begin{attributes}{\iqlType{Result}}
	\attribute{limit}{integer}{no}{}
	\attribute{percent}{Boolean}{no}{false}
\end{attributes}
\begin{description}
	\item[\iqlType{limit}] Optional limitation on the total size of the result to be returned. If the \iqlType{percent} flag is not set to \texttt{true}, this number is in reference to the units provided by the query's primary \repoLink{\modelsUrl layer/ItemLayer.java}{item layer}.
	\item[\iqlType{percent}] If set to \texttt{true} the value defined in \iqlType{limit} is treated as a integer percentage value in the interval 1 to 99, with boundaries included.
\end{description}
\begin{elements}{\iqlType{Result}}
	\element{resultTypes}{array of enum}{yes}
	\element{resultInstructions}{array of \iqlType{ResultInstruction} (\ref{sec:json-ld-result-instruction})}{no}
	\element{sortings}{array of \iqlType{Sorting} (\ref{sec:json-ld-sorting})}{no}
\end{elements}
\begin{description}
	\item[\iqlType{resultTypes}] Defines the result format or type the engine should return data in. At least one result type must be declared and the engine can also be instructed to return the results in multiple formats simultaneously. In the first iteration only \texttt{kwic} (keyword-in-context) and \texttt{custom} (as a placeholder for the raw corpus members) are supported.
	\item[\iqlType{resultInstructions}] Optional collection of additional processing instructions to generate (textual) result reports.
	\item[\iqlType{sortings}] Allows to sort matches before generating result reports.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     RESULT INSTRUCTION
\section{Result Instruction}
\label{sec:json-ld-result-instruction}
%\begin{itemize}
%\item TODO
%\end{itemize}
%TODO fill once the specification is fleshed out
\desc{Currently unused dummy for declaring post-processing instructions on the query result to perform conversions and/or tabular calculations.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     SCOPE
\section{Scope}
\label{sec:json-ld-scope}
%\begin{itemize}
%\item id
%\item layers
%\end{itemize}
\desc{Very detailed vertical filtering of the layers available in a query.}
\begin{attributes}{\iqlType{Scope}}
	\attribute{id}{string}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the scope within the entire query.
\end{description}
\begin{elements}{\iqlType{Scope}}
	\element{layers}{array of \iqlType{Layer} (\ref{sec:json-ld-layer})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{layers}] The layer members of this scope.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     SORTING
\section{Sorting}
\label{sec:json-ld-sorting}
%\begin{itemize}
%\item expression
%\item order
%\end{itemize}
\desc{Defines a single rule for sorting query results based on an arbitrarily complex expression.}
\begin{attributes}{\iqlType{Sorting}}
	\attribute{order}{enum}{yes}{}
\end{attributes}
\begin{description}
	\item[\iqlType{order}] Hint on sorting direction, legal values are \texttt{asc} or \texttt{desc} for ascending or descending order, respectively.
\end{description}
\begin{elements}{\iqlType{Sorting}}
	\element{expression}{\iqlType{Expression} (\ref{sec:json-ld-expression})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{expression}] The actual sorting expression. It can use any (member) reference or variable available in the query to compute its result and must return a type that is comparable to allow stable sorting. Per default any of the primitive numerical types (\texttt{int} or \texttt{float}), the text type \texttt{string} and any member of the \icarus framework implementing the \texttt{java.lang.Comparable} interface can be used as return type.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STREAM
\section{Stream}
\label{sec:json-ld-stream}
%\begin{itemize}
%	\item id
%	\item primary
%	\item corpus
%	\item layers
%	\item scope
%	\item rawPayload
%	\item payload
%	\item rawGrouping
%	\item grouping
%	\item rawResult
%	\item result
%\end{itemize}
\desc{A stream encapsulates all the information and query constraints to extract, evaluate and prepare data from a single corpus. Note that many of the attributes and/or elements below are marked as optional, but the following restrictions are in effect:}
\vspace{-\medskipamount}
\begin{itemize}[leftmargin=*,topsep=0pt]\compresslist
	\item Either \iqlType{rawPayload} or \iqlType{payload} must be provided by the client.
	\item Either \iqlType{layers} or \iqlType{scope} must be provided to define the granularity of data being loaded for evaluation.
\end{itemize}
\begin{attributes}{\iqlType{Stream}}
	\attribute{id}{string}{yes}{}
	\attribute{primary}{Boolean}{no}{false}
	\attribute{rawPayload}{string}{no}{}
	\attribute{rawGrouping}{string}{no}{}
	\attribute{rawResult}{string}{no}{}
\end{attributes}
\begin{description}
	\item[\iqlType{id}] Identifier to uniquely identify the stream within the entire query.
	\item[\iqlType{primary}] Flag to indicate that the primary layer of this stream is meant to be used as primary layer of the entire search result. Only one stream can declare this property and it primarily dictates the order of result elements in a multi-stream query or which stream is allowed to dictate sorting.
	\item[\iqlType{rawPayload}] The textual (raw) form of the payload for this stream, i.e. all the constraints and structural query content.
	\item[\iqlType{rawGrouping}] The textual (raw) grouping definitions to be applied for results of this stream.
	\item[\iqlType{rawResult}] The textual (raw) result configuration and post-processing instructions for this stream.
\end{description}
\begin{elements}{\iqlType{Stream}}
	\element{corpus}{\iqlType{Corpus} (\ref{sec:json-ld-corpus})}{yes}
	\element{layers}{array of \iqlType{Layer} (\ref{sec:json-ld-layer})}{no}
	\element{scope}{\iqlType{Scope} (\ref{sec:json-ld-scope})}{no}
	\element{payload}{\iqlType{Payload} (\ref{sec:json-ld-payload})}{no}
	\element{grouping}{array of \iqlType{Grouping} (\ref{sec:json-ld-group})}{no}
	\element{result}{\iqlType{Result} (\ref{sec:json-ld-result})}{yes}
\end{elements}
\begin{description}
	\item[\iqlType{corpus}] The corpus to extract data from.
	\item[\iqlType{layers}] Vertical filtering to be applied to the corpus prior to actual query evaluation.
	\item[\iqlType{scope}] Another and more fine-grained form of vertical filtering that allows for more precise selection of layers to be part of this stream's data.
	\item[\iqlType{payload}] The processed form of \iqlType{rawPayload}.
	\item[\iqlType{grouping}] The processed form of \iqlType{rawGrouping}.
	\item[\iqlType{result}] The processed form of \iqlType{rawResult}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Inner \ac{iql} ELements}
\label{chap:inner-iql-elements}

Certain parts of an \ac{iql} query can be defined in \textit{raw} form, that is, in a keyword-driven formal language.
During the first phase of query evaluation they get (partly) translated into their respective JSON-LD counterparts described in \cref{chap:elements} (unless of course the query or query fragments are provided fully processed).
This section defines the syntax and additional rules for those raw statements.
Note that the textual form of all following \ac{iql} elements is expected to be encoded in UTF-8, so no special escape mechanisms are needed for unicode content.


\section{Reserved Words}
\label{sec:reserved-words}

The following list of keywords is reserved and any of the words may not be used as direct identifier strings in a query. They are reserved in both all lowercase and all uppercase variants, and while camel-cased versions are technically permitted, it is highly discouraged to use them:

\vbox{%
\begin{multicols}{4}
\parindent=0pt
\texttt{%
\begingroup
\obeylines
\input{keywords.txt}
\endgroup
}
\end{multicols}
}

\noindent In addition the following strictly lowercase words are reserved as type identifiers and may not be used otherwise:

\vbox{%
\begin{multicols}{4}
\parindent=0pt
\texttt{%
\begingroup
\obeylines
\input{types.txt}
\endgroup
}
\end{multicols}
}

\section{Comments}
\label{sec:comments}

\ac{iql} supports single-line comments, indicated by ``//''. All remaining content in a line after the comment indicator will be ignored when parsing and evaluating a query. 

\section{Literals}
\label{sec:literals}

Literals are statically-typed fixed-value expressions in \ac{iql}.
They are parsed only once during the initial processing part of a query.

\subsection{String Literals}
\label{sec:string-literals}

\ac{iql} uses simple double quotes (\lit{"} or U+0022) to define string literals. 
String literals may not contain any of the following symbols directly:

\begin{Verbatim}[samepage=true]
\n line break
\r carriage return
\t tab
\ backslash
" nested quotation mark
\end{Verbatim}

\noindent Any of those symbols listed above can be embedded into a string literal as part of an escape sequence with a preceding backslash.
At the current time there is no planned mechanism to provide additional escape support for unicode symbols, since the default encoding scheme for \ac{iql} is UTF-8.

\paragraph{Examples for valid string literals:}

\begin{Verbatim}[samepage=true]
"string"
"123"
"some fancy number (123.456e-789) and special symbol â£"
"a more complex string!"
"a\n multiline\n string..."
\end{Verbatim}

\subsection{Boolean Literals}
\label{sec:boolean-literals}

Boolean literals are limited to either all lowercase or all uppercase versions of the literals \keyword{true} and \keyword{false}.

\subsection{Integer Literals}
\label{sec:integer-literals}

\paragraph{Signed Integer Literals}
Literals representing regular \keyword{int} (32bit) or \keyword{long} (64bit) integers consist of an optional initial sign (\lit{+} or \lit{-}) and the body consisting of digits (\lit{0} to \lit{9}) or underscore (\lit{\_}) characters.
Underscore characters may only appear inside the integer literal, never at the beginning or end (not counting the sign symbol).

\begin{gram}
	\label{gram:integer}
	\begin{rrdiag*}{integerLiteral}
		\sst \\ `+' \\ `\textminus' \est
			<digit> \sst \\ \sst \\ \srp \sst <digit> \\ `\_' \est \\ \erp \est <digit> \est
	\end{rrdiag*}
\end{gram}

\paragraph{Examples for valid (signed) integer literals:}

\begin{Verbatim}[samepage=true]
1
+123
-123
1_000_000
-99_000000_0
\end{Verbatim}

\paragraph{Pure Integer Literals}
Some parts of the \ac{iql} syntax only allow unsigned "pure" integers and will explicitly state this fact. In those special cases integer literals may neither contain the initial sign symbol nor intermediate underscores.

\subsection{Floating Point Literals}
\label{sec:floating-point-literals}

Floating point literals are constructed by using a (signed) integer literal for the pre-decimal part, a dot \lit{.} as delimiter and a decimal part made up by a unsigned integer literal. They represent either single-precision \keyword{float} (32bit) or double-precision \keyword{double} (64bit) values.

\begin{gram}
	\label{gram:floating-point}
	\begin{rrdiag*}{floatingPointLiteral}
		<signedInteger> `.' <unsignedInteger>
	\end{rrdiag*}
\end{gram}

\paragraph{Examples for valid (signed) floating point literals:}

\begin{Verbatim}[samepage=true]
1.0
+123.456
-123.456
1_000_000.999
-99_000000_0.000_000_001
\end{Verbatim}

\noindent While many languages offer to express floating point literals in the scientific notation with explicit exponent declaration, we do not include this in the initial draft of \ac{iql}.

\section{Identifiers}
\label{sec:identifiers}

\noindent Identifiers in \ac{iql} are combinations of lowercase or uppercase alphabetic \texttt{[a-zA-Z]} characters that may contain underscore symbols \texttt{\_} between the first and last position and may also contain digits \texttt{[0-9]} on any position except as initial symbol (cf. \cref{gram:identifier}).

\begin{gram}
	\label{gram:identifier}
	\begin{rrdiag*}{identifier}
		<character> \sst \\ 
			\sst \\ \srp \sst <character> \\ <digit> \\ `\_' \est \\ \erp \est
				\sst <character> \\ <digit> \est
		\est
	\end{rrdiag*}
\end{gram}

\paragraph{Examples for valid identifiers:}

\begin{Verbatim}[samepage=true]
x
myIdentifier
x1
x_1
x__1
x321
some_random_id
someRandomId002
random_2_4
notTheBest______________example
\end{Verbatim}

\noindent Identifiers are limited in length by the engine to a total of 255 characters. This is a purely arbitrary choice to keep queries readable and not subject to any technical limitations.

\section{Variables and References}
\label{sec:variables-references}

In \ac{iql} all top-level (i.e. not part of the tail expression in a hierarchical path) identifiers are expected to reference 'something' from the global namespace available to the query. This namespace is populated with all the globally available constants, methods and helper objects from the \ac{iql} core and any imported extensions, as well as all the corpus members defined in the scoping part of the query. Outside this global namespace any dynamically created identifiers from within a query reside in the variable namespace and are marked with a preceding \lit{@} (e.g. \texttt{@myVariable}). They can be used the same way as any regular identifier, with the exception of additionally allowing assignment expressions when inside script blocks. In addition any corpus members bound within a constraint section are prefixed with a \lit{\$} sign, such as \texttt{\$token1}. \cref{tab:identifiers} provides a compact overview of the available identifiers and their capabilities/features.

\begin{table}[ht]
	\centering\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline 
		Type	& Prefix & Example & Scope & Fixed\footnotemark & Final & Re-Assign \\ 
		\hline 
		Reference	&  & \texttt{max()} & global & X & X &  \\ 
		\hline 
		Variable	& \texttt{@} & \texttt{@myVar} & limited & (X) &  & X \\ 
		\hline 
		Member	& \texttt{\$} & \texttt{\$token} & limited & X & (X) &  \\ 
		\hline 
	\end{tabular}
	\footnotetext{Fixed as in ``fixed type'', i.e. the type of value stored is pre-determined and cannot be changed during query evaluation.} %TODO doesn't work properly
	\caption[Identifier types]{Identifier types available in \ac{iql} and their properties.}
	\label{tab:identifiers}
\end{table}

\paragraph{Special remarks:}
\noindent Variables are more or less general-purpose storage objects for arbitrary values and without a fixed type. Their first assignment however hints at the implied type to be used and as such they can cause cast errors when used for situations where an incompatible type would be needed.

Member identifiers are final in the sense that they cannot be re-assigned explicitly but will be implicitly for every iteration of the query on a new part of the corpus. For example, above \texttt{\$token} member will point to a new token object every time the inner constraint parts of the query are evaluated. Therefore member identifiers could be viewed as a sort of loop variable. 

\section{Expressions}
\label{sec:expressions}

Expressions are the foundation of every query.
Each expression has a (usually fixed) result type and evaluates to a value of that type.
They can take any of the following forms and a overview diagram is available in the appendix as \cref{gram:expression}.

\subsection{Primary Expressions}
\label{sec:primary-expressions}

Any literal of types \keyword{boolean}, \keyword{string}, \keyword{int} or \keyword{float} can serve as a primary expression of that type.
See \cref{sec:literals} for examples and a more detailed specification of the various types of literals in \ac{iql}.

\subsubsection{References}
\label{sec:references}
Any reference or variable as described in \cref{sec:variables-references} is also a valid primary expression.
Note that the process for resolving references strongly relies on the context the reference is being used in, for instance to allow simple references to be used as aliases for method calls.

Additionally a special construct is available as primary expression to more easily access annotation values from within a node definitions (\ref{sec:structural-constraints}).
Normally the evaluation engine tries to resolve any otherwise unknown identifier inside a node as the key (aliased or original) of an annotation that should be fetched for the item matched to this node.
But since this is not always possible in an unambiguous way or there exists a name clash between an annotation key and another identifier available in the current environment, a \synt{qualifiedIdentifier} (\cref{gram:qualified-identifier}) can be used instead.

\begin{gram}[\synt{qualifiedIdentifier}]
	\label{gram:qualified-identifier}
	\begin{grammar}	
		<qualifiedIdentifier> ::= <identifier> `::' <identifier> 	
	\end{grammar}
\end{gram}

A qualified identifier consists of two identifiers that are joined by a double colon \lit{::}.
The first (or left) identifier is expected to unambiguously resolve to a annotation layer available for the current context.
The second (or right) identifier in turn acts as specification of an annotation key (or its alias) available from the previously defined annotation layer.

\subsubsection{List Expression}
\label{sec:list-expression}
Arrays (or more generally ``lists'') in \ac{iql} can be defined by enclosing a sequence of expressions within curly brackets (\lit{\{} and \lit{\}}), using the comma symbol (\lit{,}) as separator.
Optionally the desired type for elements in the list can be made explicit with a special type marker in front of the opening bracket as illustrated by \cref{gram:list-expression}.
If no type is provided, the overall element type will be determined by checking the types of all elements and choosing the least restrictive one.
Note that for empty lists (no elements are given inside the curly brackets) it is mandatory to specify the element type!

\begin{gram}[\synt{listExpression}]
	\label{gram:list-expression}
	\begin{grammar}	
		<listExpression> ::= (<type> `[]')? `{' (<expression> (`,' <expression>)* )? `}'	
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{listExpression}
		\sst \\ <type> `[]' \est `{' \sst \\ \srp <expression> \\ `,'\erp  \est `}' \\	
	\end{rrdiag*}
\end{gram}

\subsection{Path Expressions}
\label{sec:path-expressions}

For navigating hierarchically structured object graphs or namespaces, expressions can take the form of paths, consisting of a original expression, a dot as separator and finally an identifier that denotes the path element or ``field'' within the context of whatever the original expression returned.

\begin{gram}[\synt{path}]
	\label{gram:path-expression}
	\begin{grammar}	
		<path> ::= <expression> `.' <identifier> 	
	\end{grammar}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
someObejct.someProperty
some.really.long.winded.path
\end{Verbatim}

\noindent Note that for a lot of native classes of the ICARUS2 framework, \ac{iql} provides convenient path-based alternatives to method invocations. For example in  the context of navigating a structure, ``someStructure.getParent(someItem)`` can be replaced by ``someItem.parent`` as long as ``someStructure`` is unambiguous in the current context and already bound.

\subsection{Method Invocation}
\label{sec:method-invocations}

Method invocations consist of an expression that points to the actual method (such as an identifier in the global namespace or a path expression) and round brackets for the invocation with an optional argument list:

\begin{gram}[\synt{method}]
	\label{gram:method-invocation}
	\begin{grammar}	
		<method> ::= <expression> `(' <arguments>? `)'
		
		<arguments> ::= <expression> (`,' <expression>)*	
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{method}
		<expression> `(' \sst \\ \srp <expression> \\ `,' \erp \est `)'
	\end{rrdiag*}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
myFunction()
myNamespace.someFunction(someArgument, anotherArgument)
min(123, 456, dynamicContent())
some().chained().methods()
\end{Verbatim}

\subsection{List Access}
\label{sec:list-access}

Lists or arrays are accessed by an expression pointing to the list or array object itself and an index expression in square brackets indicating the position(s) of the desired element(s) within the array. Note that the index or indices expression must evaluate to values within 32bit signed integer space. Positive values indicate the position beginning from the start of the 0-based array, whereas negative values allow backwards referencing of elements with \lit{-1} pointing to the last array element and \lit{-2} to the second to last one. For a list of length $N$ any reverse index $-N \le i \le -1$ therefore yields the effective position $N+i$. For multidimensional arrays several index statements can be chained or even combined in a single comma-separated list.

\begin{gram}[\synt{array}]
	\label{gram:list-access}
	\begin{grammar}	
		<array> ::= <expression> `[' <indices> `]'
		
		<indices> ::= <expression> (`,' <expression>)*	
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{method}
		<expression> `[' \srp <expression> \\ `,' \erp `]'
	\end{rrdiag*}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
myArray[1]
myArray[-1]
myArray[-myArray.length] // same as myArray[0]
complexArray[1][2][3]
complexArray[-1][2][-3]
complexArray[1, 2][3]
complexArray[1, 2, 3]
\end{Verbatim}

\noindent Note that \ac{iql} provides convenient ways of using array access patterns to access list-like data structures and/or classes of the framework:
Every \repoLink{\modelsUrl /members/item/manager/ItemLookup.java}{ItemLookup} implementation, such as \repoLink{\modelsUrl /members/container/Container.java}{Container} or \repoLink{\modelsUrl /members/structure/Structure.java}{Structure} that would traditionally access its content via \code{myContainer.getItemAt(someIndex)} can be used the same as any regular array with the expression \code{myContainer[someIndex]}.


\todo{complete examples and add subsection about list regions}
\begin{figure}[!htb]\centering
	{
	\tikzset{
		baseline=-1.5mm,
		item/.style={rectangle, draw=black!60, fill=black!5, thick, minimum size=5mm},
		region/.style={red!60, draw, line width=0.7pt}
	}
	
	\newcommand{\items}{\foreach \x in {0,1,...,9}  {\node[item] (x\x) at (\x,0) {\x};} }
	\renewcommand{\arraystretch}{2.0}

	\begin{tabular}{l r}
		Regular explicit [3,6] & \tikz{\items\node[region, fit=(x3)(x6)]{};} \\
		Right reverse [3..-6] & \tikz{\items\node[region, fit=(x3)(x4)]{};} \\
		Left reverse [-8..5] & \tikz{\items\node[region, fit=(x2)(x5)]{};} \\
		Both reverse [-8..-5] & \tikz{\items\node[region, fit=(x2)(x5)]{};} \\
		Regular wrap [5..2] & \tikz{\items\node[region, fit=(x0)(x2)]{};\node[region, fit=(x5)(x9)]{};} \\
		Right reverse wrap [5..-8] & \tikz{\items\node[region, fit=(x0)(x2)]{};\node[region, fit=(x5)(x9)]{};} \\
		Left reverse wrap [-5..2] & \tikz{\items\node[region, fit=(x0)(x2)]{};\node[region, fit=(x5)(x9)]{};} \\
		Reverse wrap [-5,-8] & \tikz{\items\node[region, fit=(x0)(x2)]{};\node[region, fit=(x5)(x9)]{};} \\
	\end{tabular}
	}
	
	\caption[Illustration of ranged list access]{Graphical illustration of the different ways to address regions in list objects in \ac{iql}.}
	\label{fig:list-access-examples}
\end{figure}

\subsection{Annotation Access}
\label{sec:annotation-access}

The \ac{icmf} models segmentation, structure and content of a corpus resource as different aspects. As such the information about any annotation attached to a given Item is stored apart from it and therefore is not easily accessible from the item alone. To simplify the usage of annotations within a query, \ac{iql} provides the following expression as syntactic sugar for accessing (multiple) annotations directly from an item:

\begin{gram}[\synt{annotation}]
	\label{gram:annotation-access}
	\begin{grammar}	
		<annotation> ::= <expression> `{' <keys> `}'
		
		<keys> ::= <expression> (`,' <expression>)*
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{method}
		<expression> `{' \srp <expression> \\ `,' \erp `}'
	\end{rrdiag*}
\end{gram}

\noindent The first expression must evaluate to an item reference and the annotation pointers inside curly brackets must evaluate to strings (if only a single expression is given, it can evaluate to a list or array and be expanded, cf. \cref{sec:value-expansion}) that uniquely denote annotation layers in the current context of the query. Typically users will use string literals in double quotes to explicitly state the annotations to be accessed, but the \ac{iql} syntax allows for very flexible extraction statement. If the evaluation of those annotation pointers yields more than one string, the result will be an array-like object containing the resolved values for each of the annotation keys in the same order as those were specified.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
myItem{"pos"}
myItem{"form", "pos", "lemma"} 

// extract values from multiple concurrent annotation layers
// and pick the first one present
firstSetValue(myItem{"parser1.head", "parser2.head"})  
\end{Verbatim}

\subsection{Type Cast}
\label{sec:type-cast}

Expressions in \ac{iql} are automatically cast to matching types according to the actual consumer's needs (unless this feature gets deactivated via the corresponding switch, cf. \cref{sec:json-ld-switches}). Explicit casts can be performed by preceding an expression with one of the type keywords listed above (\ref{sec:reserved-words}) in round brackets.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
(int) myValue
(int) 12345.678
(float) average(myVector)
(string) 123.456
\end{Verbatim}

\subsection{Wrapping}
\label{sec:wrapping}

Expression hierarchy and evaluation order follows the order the different types of expressions are listed here. To dictate another order, expressions can be wrapped into round brackets. This will cause the inner expression to be evaluated independent of potential hierarchical rules from the outside context.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
6 + 4 * 2   // multiplication evaluated first -> result 14
(6 + 4) * 2 // addition is evaluated first -> result 20
\end{Verbatim}

\subsection{Unary Operation}
\label{sec:unary-operation}

\ac{iql} only allows four unary operators to be used directly in front of an expression, the exclamation mark \lit{!} and the \keyword{NOT} keyword for Boolean negation, the minus sign \lit{\textminus} for negating numerical expressions and the \lit{\texttildelow} symbol of bitwise negation of integer numbers.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
!someBooleanFunction()
NOT someBooleanValue
-123
-myNumericalFunction()
~123
~myIntegerFunction()
\end{Verbatim}

\subsection{Binary Operation}
\label{sec:binary-operation}

Binary operations between two expressions take the following simple form:

\begin{gram}[\synt{binary_op}]
	\label{gram:binary-operations}
	\begin{grammar}	
		<binary_op> ::= <expression> <operator> <expression>
	\end{grammar}
\end{gram}

\noindent Binary operators follow an explicit hierarchy, listed in \cref{tab:binary-operators} in the order of priority, from highest to lowest.

\begin{table}[ht]
	\centering
	\begin{tabular}{|p{0.25\textwidth}|p{0.6\textwidth}|}
		\hline 
		\textbf{Operators}	& \textbf{Explanation} \\ 
		\hline 
		\hline
		\verb|*  /  %|& multiplication, division and modulo \\ 
		\hline 
		\verb|+  -|& addition and subtraction \\ 
		\hline 
		\verb#<<  >>  &  |  ^#& shift left, shift right, bitwise and, bitwise or, bitwise xor \\ 
		\hline 
		\verb|<  <=  >  >=|& less, less or equal, greater, greater or equal \\ 
		\hline 
		\verb|=~  !~  =#  !#|& string operators: matches (regex), matches not (regex), contains, contains not \\ 
		\hline 
		\verb|==  !=|& equality, inequality \\ 
		\hline 
		\verb|&&  AND|& logical conjunction \\ 
		\hline 
		\verb#||  OR#& logical disjunction \\ 
		\hline 
	\end{tabular} 
	\caption[Binary operators]{Binary operators available in \ac{iql} and their hierarchical order.}
	\label{tab:binary-operators}
\end{table}

\subsubsection{Basic Numerical Operations}
\label{sec:basic-numerical-operations}

Basic numerical operations follow the standard mathematical rules for priorities.
While the basic numerical types (\keyword{int}, \keyword{float}) can be arbitrarily mixed inside those expressions, the type used during the expression and as result will be determined by the least restrictive type of any operand involved.

\subsubsection{Bit Operations}
\label{sec:bit-operations}

Bitwise operations (\lit{\&}, \lit{|} and \lit{\textasciicircum}) take integer expressions (or any other form of \textit{bitset}) as inputs and generate a result of the corresponding type. If different types are used (e.g. \texttt{int} and \texttt{long}), one must be cast~\ref{sec:type-cast} to match the other. If value expansion~\ref{sec:value-expansion} is active, any array-like data can also be used and will be subject to element-wise bit operations.

The two shift operations (\lit{\textless{}\textless} and \lit{\textgreater{}\textgreater}) take arbitrary integer types as left operand and an \keyword{int} value as right operand.

\subsubsection{Ordered Comparisons}
\label{sec:ordered-comparisons}

Comparisons are special binary operators that take two expressions of equal or compatible result type and produce a Boolean value. Note that their exact semantics are type specific, e.g. when comparing strings, the operation is performed lexicographically and may be subject to case conversions (\ref{sec:json-ld-switches}).

\subsubsection{String Operations}
\label{sec:string-operations}

To account for the ubiquity of textual annotations in corpora, \ac{iql} provides a set of dedicated string operators to perform substring matching (with the \textit{contains} operator \lit{=\#} or its negated form \lit{!\#}) and regular expression matching (via \lit{=\textasciitilde} and \lit{!\textasciitilde}). Per default \ac{iql} uses the Java regex syntax, but for the future, additional switches (\ref{sec:json-ld-switches}) are planned to allow finer control over regex details.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
// find verbal forms
somePosAnnotation # "V"       
// alternative to the set predicate with more flexibility
somePosAnnotation !~ "NN|NS"   
\end{Verbatim}

\subsubsection{Equality}
\label{sec:equality}

Equality checks follow the same basic conditions as ordered comparisons (\ref{sec:ordered-comparisons}), but with the following rules for comparable values ``a`` and ``b``:

\begin{Verbatim}[samepage=true]
a == b iff !(a<b) && !(a>b)
a != b iff a<b || a>b
\end{Verbatim}

\noindent More generally, equality between expressions in \ac{iql} is based on content equality and therefore type specific.
Note that trying to check two expressions of incompatible types (such as \keyword{int} and \keyword{string}) for equality will always evaluate to \keyword{false} and also emit a warning. 
%TODO is this part actually implemented?

\subsubsection{Logical Composition}
\label{sec:logical-composition}

All Boolean expressions can be combined via disjunction (either double pipes \lit{||} or the \keyword{OR} keyword) or conjunction (double ampersand \lit{\&\&} or the \keyword{AND} keyword), with conjunction having higher priority. 
While not strictly mandatory, evaluation of \ac{iql} expressions is recommended to employ optimized interpretation such that only the first operand is evaluated if possible. 
When the first operand of a disjunction evaluates to \keyword{true}, the entire expression is already determined, same for a conjunction's first operand yielding \keyword{false}.

\paragraph{Examples:}
\begin{Verbatim}[samepage=true]
a>1 && b<2
x==1 or x==3
\end{Verbatim}

Note that aforementioned optimization strategy also applies to chained boolean expressions, such as \query{a \&\& b \&\& c} and that the evaluation engine is free to reorder operands here as it sees fit.
As such individual operands may never be evaluated at all and the overall correctness of a query expression must not rely on side-effects stemming from specific expressions being evaluated or not.

\subsection{Assignment}
\label{sec:assignment}

\ac{iql} offers a special construct to assign (member) variables and at the same time verify the successful assignment with a Boolean result value. 
\Cref{gram:assignment} illustrates the basic syntax for assignment operations inside a constraint, allowing the result of an arbitrary expression to be assigned to any previously defined member variable (or dynamically allocated variable).

\begin{gram}[\synt{assignment}]
	\label{gram:assignment}
	\begin{grammar}	
		<assignment> ::= <expression> `AS' `OPTIONAL'? (<member> | <variable>)
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{assignment}
		<expression> `AS' \sst \\ `OPTIONAL' \est \sst <member> \\ <variable> \est
	\end{rrdiag*}
\end{gram}

If a member variable is used for the assignment or the variable has already been used previously and thereby has been type-bound, the result type of the \synt{expression} has to be compatible!
Assignment operations provide a Boolean return value that is \keyword{true} iff the assignment was successful and the (member) variable holds a non-null value.
If the assignment is declared to be \keyword{OPTIONAL}, it will always evaluate to \keyword{true} regardless of the final value the (member) variable is holding.
As the name of that keyword implies, this allows to have parts of the query effectively becoming optional when it comes to capturing information.
Keep in mind that optional (member) variables might not be assigned a valid non-null value when trying to read them in subsequent constraints or final result processing.
As such care must be taken not to create errors when trying to access their content.

\paragraph{Examples:}
\begin{Verbatim}[samepage=true]
// global constraint over two tree nodes to fetch their first 
// ancestor, failing if $x and $y do not have a common ancestor
... HAVING ancestor($x, $y) AS $a

// optionally assign the last child of $x as a member variable,
// not failing if $x has no children
... HAVING lastChild($x) AS OPTIONAL $c
\end{Verbatim}


\subsection{Set Predicate}
\label{sec:set-predicate}

Also called 'containment predicate', this expression allows to check if a given value is a member of a specified set (or generally speaking 'collection') as shown in \cref{gram:set-predicate}. 
The entire expression evaluates to a Boolean value and will be \keyword{true} iff the input expression (left-most one) evaluates to the same value as any of the elements inside the set definition to the right (typically a list expression, cf. \cref{sec:primary-expressions} or \cref{gram:list-expression}). 
See about equality operators in \cref{sec:binary-operation} on how elements are compared. 
Note that methods or collections used inside the set definition are subject to the expansion rules described in \cref{sec:value-expansion}.
The primary use case for set expressions is to greatly simplify the declaration of constraints for multiple alternative target values. 

Set predicates can be directly negated (apart from wrapping~\ref{sec:wrapping} them and negating~\ref{sec:unary-operation} the entire expression) with an exclamation mark \lit{!} or the keyword \keyword{NOT} in front of the \keyword{IN} keyword. 
If the input expression evaluates to an array-like object, the set predicate will expand its content and evaluate to \keyword{true} if at least \textit{one} of its elements is found to be contained in the set. 
The set predicate can be universally quantified with a star \lit{*} or the \keyword{ALL} keyword in front to change the overall behavior such that the result will be \keyword{true} iff \textit{all} of the elements are contained in the set (or none of them are, if the set predicate is directly negated).

\begin{gram}[\synt{setPredicate}]
	\label{gram:set-predicate}
	\begin{grammar}	
		<setPredicate> ::= <expression> <all>? <not>? `IN' <expression>
		
		<all> ::=  `ALL' | `*'
		
		<not> ::=  `NOT' | `!'
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{setPredicate}
		<expression> \sst \\ `ALL' \\ `*' \est \sst \\ `NOT' \\ `!' \est `IN' <expression>
	\end{rrdiag*}
\end{gram}

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
someAnnotationValue IN {"NP","VP","-"}
someAnnotationValue NOT IN {"NN","DET"}
someAnnotationValue NOT IN {"NN","DET", STTS.getVerbTags()}
"John" IN getLegalNames()
fetchCharacterNamesInChapterOne() IN getOrcishNames()
\end{Verbatim}

\subsection{Ternary Operation}
\label{sec:ternary-operation}

A single ternary operation is supported in \ac{iql}, which is the popular if-then-else replacement with the following syntax:

\begin{gram}[\synt{ternary}]
	\label{gram:ternary-operations}
	\begin{grammar}	
		<ternary> ::= <expression> `?' <expression> `:' <expression>
	\end{grammar}
\end{gram}

\noindent The first expression must evaluate to a \keyword{boolean} value and determines which of the following two alternatives will be evaluated for the final value of the expression. Note that the second and third expressions must have compatible result types.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
x<2 ? "text for smaller value" : "some other text"
\end{Verbatim}

\subsection{Value Expansion}
\label{sec:value-expansion}

\ac{iql} supports expansion of arrays, lists and array-like method return values for situations where an immediate consumer supports lists of values as input. Assuming the method ``randomPoint()'' returns an array of 3 integer values or a \textit{array-like} data type (such as a 3D point) and another method ``invertPoint(int, int, int)'' takes 3 integer arguments, then the invocation of ``invertPoint(randomPoint())'' is legal and the array or object from the inner method call will be automatically expanded into the separate 3 values. This is especially handy when dealing with multidimensional arrays, as regular indexing would require manual extraction of method return values into variables to then be used in accessing the different array dimensions. With automatic expansion, a three-dimensional array could directly be accessed with aforementioned method via ``array[randomPoint()]''.

\section{Constraints}
\label{sec:constraints}

Simply put, constraints are expressions that evaluate to a Boolean result. 
Apart from native Boolean expressions (such as comparisons, Boolean literals or Boolean functions), \ac{iql} allows certain evaluations as syntactic sugar, listed in \cref{tab:constraints-translation}.
Note that those conversions are only active if the respective switches to disable them (\ref{sec:json-ld-switches}) have not been set.

\begin{table}[!htb]\centering
	\begin{tabular}{|l|c|c|}
		\hline 
		\textbf{Type} & \textbf{Condition} & \textbf{Value} \\ 
		\hline 
		\keyword{string} & empty or null & \keyword{false}  \\ 
		\hline 
		\keyword{int} & \texttt{0} & \keyword{false} \\ 
		\hline 
		\keyword{float} & \texttt{0.0} & \keyword{false} \\ 
		\hline
		any object & \keyword{null} & \keyword{false} \\ 
		\hline 
	\end{tabular}
	\caption[Boolean conversion rules]{Rules for converting arbitrary values or objects in a query to Boolean values.}
	\label{tab:constraints-translation}
\end{table}

\paragraph{Result Expansion}
Besides their obvious role as filters, constraints can also be used to expand the set of captured members in a match, subsequently usable for instance in advanced result processing.\footnote{Per default members defined as bindings (\ref{sec:bindings}) are captured when used as labels for nodes (\ref{sec:structural-constraints}) in the query.}
The assignment operation (\ref{sec:assignment}) allows arbitrary expressions to be evaluated and having their results stored in either a general variable or, in case of a result type compatible to \repoLink{\modelsUrl members/item/Item.java}{items}, actual member variable (\ref{sec:variables-references}).
%TODO assigment part, explain how results can be expanded after absic candidates have been matched

\section{Payload Structure}
\label{sec:payload-structure}

The Payload section in \ac{iql} consists of either the sole \keyword{ALL} keyword or a selection statement (\ref{sec:selection}) with optional binding (\ref{sec:bindings}) definition and filter constraints (\ref{sec:filter-constraints}) preceding it.
If the \keyword{ALL} keyword is used, no constraints whatsoever can be defined and the engine is instructed to return the entire target corpus.
In this case the only way of restricting results is by using the \iqlType{Result} section (\ref{sec:json-ld-result}) of a query.

\begin{gram}[\synt{payload}]
	\label{gram:payload}
	\begin{grammar}	
		<payload> ::= `ALL' 
		\alt <bindingsList>? (`FILTER' `BY' <constraint>)? `FIND' <modifier>? <selection>
		
		<modifier> ::= (`FIRST' | `LAST' | `ANY') (<digits> `HITS')?	
	\end{grammar}
	\diagsep
	\begin{samepage} %TODO need alternative to prevent pagebreak between multiple rrfrag instances
	\rrhead{payload with content}
	\begin{rrfrag}{>-}{...}
		\sst \\ <bindingsList> \est \sst \\ `FILTER' `BY' <constraint> \est 
	\end{rrfrag}
	\newline
	\begin{rrfrag}{...}{->}
		`FIND' \sst \\
			\sst `FIRST' \\ `LAST' \\ `ANY' \est
			\sst \\ <digits> `HITS' \est
		\est <selection>
	\end{rrfrag}
	\end{samepage}
\end{gram}

\subsection{Filter Constraints}
\label{sec:filter-constraints}
\noindent For complex (i.e. structural) queries, \ac{iql} offers a way of filtering the \acp{uoi} before they are processed by the matchers for sequence, tree or graph structures (cf. \cref{sec:sequence-constraints,sec:tree-constraints,sec:graph-constraints}).
A dedicated \keyword{FILTER BY} section in the query payload preceding the actual structural constraints is available to define filtering rules that have to evaluate to \keyword{true} for a \ac{uoi} to be considered for actual matching.
Constraints within a filtering rules have only access to general properties of the \acp{uoi}, such as sentence length, tree height or similar information.
The do \textbf{not} have access to bound member variables, apart from those defined for the top-level members of lanes (\ref{sec:lanes})!
Note that filter constraints are \textbf{not} compatible with flat constraints (\ref{sec:flat-constraints}) as they both essentially fill the same function and flat constraints take precedence.

\subsection{Match Modifiers}
\label{sec:match-modifiers}
Per default, the search in \ac{iql} is expected to be exhaustive, i.e. the evaluation engine will attempt to find all of the instances in a target corpus that match the query constraints, potentially reporting individual \acp{uoi} (such as sentences) multiple times  if they contain several occurrences.
For instance, the sentence ``The dog chased the rabbit down the hill.'' will be treated as tree entries in the result if the query was only meant to find instances of the lemma ``the''.
This default behavior can be adjusted to only return each \ac{uoi} no more than once by using one of the modifiers (\keyword{FIRST}, \keyword{LAST}, \keyword{ANY}) listed in \cref{gram:payload}.
The semantics of the \keyword{ANY} modifier are such that the engine may freely pick any one match within a \ac{uoi}.
Note however, that to support reproducible search results, repeated evaluations of the same query on a corpus are still required to yield the same instances here.
The exact semantics of \keyword{FIRST} and \keyword{LAST} are depending on the type of structural constraints used in the payload, but generally are based on the natural order of items within the corpus (typically this is the flow of words in a text).
The evaluation behavior for them is subsequently covered in \cref{sec:sequence-constraints,sec:tree-constraints,sec:graph-constraints}.

All three available modifiers can also take an optional numerical argument that defines the upper bound for the number of hits to be reported, followed by the \keyword{HITS} keyword.
This \textit{limit} must be a positive non-zero integer that follows the syntax of ``pure integers'' as described in \cref{sec:integer-literals}.
If a modifier is accompanied by a limit value, the \ac{icqp} will report a number of hits per \ac{uoi} no greater than this limit.
In the absence of any explicitly set limit, the \ac{icqp} will default to 1 if either one of \keyword{FIRST}, \keyword{LAST}, \keyword{ANY} is used.

\subsection{Bindings}
\label{sec:bindings}
A binding is a collection of member references (\ref{sec:variables-references}) that get declared to belong to a certain member type or part of the corpus. 
The \keyword{DISTINCT} keyword enforces that multiple bound member references in this binding do \textbf{not} match the same target. 
Depending on the local constraints used in the query, this might be redundant (e.g. when using the member references as identifiers for tree nodes who already are structurally distinct), but can still be used to make that fact explicit. 
Additionally the \keyword{EDGES} keyword signals that the bound members of a structure are actually edges.
In this case using \keyword{DISTINCT} is redundant, as bound edges are implicitly assumed to be distinct when matching.

\begin{gram}[Bindings]
	\label{gram:bindings}
	\begin{grammar}	
		<bindingsList> ::= `WITH' <binding> (`AND' <binding>)* 
		
		<binding> := <option>? <member> (`,' <member>)* `FROM' <layer>
		
		<option> := `DISTINCT' | `EDGES'	
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{bindingsList}
		`WITH' \srp
			\sst \\ `DISTINCT' \\ `EDGES' \est \srp <member> \\ `,' \erp `FROM' <layer>
			\\ `AND'
		\erp 
	\end{rrdiag*}
\end{gram}

\noindent Raw binding definitions in the payload are parsed and stored in their JSON counterpart (\iqlType{Binding},~\ref{sec:json-ld-binding}) during query processing.

\subsection{Selection Statement}
\label{sec:selection}

Constraints are further divided into local constraints as part of node or edge definitions and global ones (with the \keyword{HAVING} keyword). 
Local constraints are obligatory and define the basic complexity of the query (flat, tree or graph). 
They also introduce certain limitations on what can be expressed or searched (e.g. a ``flat'' local constraints declaration will not provide implicit access to tree information). 
However, global constraints can introduce arbitrary constraints or relations and thereby increase the evaluation complexity, potentially without limits. 
Since there is no way for an evaluation engine to assess the complexity of user macros or extensions, extensive use of global constraints could in fact lead to extremely slow searches or even create situations where an evaluation will never terminate at all.

\begin{gram}[\synt{selectionStatement}]
	\label{gram:selection}
	\begin{grammar}	
		<selectionStatement> ::= <constraint>
		\alt (<nodeStatement> | <laneStatementsList>) (`HAVING' <constraint>)?	
		
		<laneStatementsList> ::= <laneStatement> (`AND' <laneStatement>)*
		
		<laneStatement> ::= `LANE' <identifier> (`AS' <member>)? <nodeStatement>
	\end{grammar}
	\diagsep
	
	\begin{rrdiag*}{selectionStatement}
		\sst
			\sst <nodeStatement> \\ \srp <laneStatement> \\ `AND' \erp \est
				\sst \\ `HAVING' <constraint> \est \\ 
			<constraint> 
		\est
	\end{rrdiag*}

	\begin{rrdiag*}{laneStatement}
		`LANE' <identifier> \sst \\ `AS' <member> \est <nodeStatement>
	\end{rrdiag*}
\end{gram}

%TODO a few words about nodeStatement and link to section about structural constraints?

\subsection{Lanes}
\label{sec:lanes}
\noindent Lane statements can be used to extract information from concurrent structures that exist for the \ac{uoi} of the payload.
Each lane statement is introduced by the \keyword{LANE} keyword and an identifier that matches the name or alias of a layer in the outer query definition (cf. \cref{gram:selection}).
Optionally the source layer of a lane can also be assigned a member variable (\ref{sec:variables-references}) so that it can be explicitly referenced in the payload.\footnote{This is particularly useful when using the global constraints to compare content of different lanes. Imagine for instance a query that searches for a certain syntactic construct \texttt{C} to be present in two concurrent parse trees \texttt{A} and \texttt{B}, but will only consider sentences where \texttt{C} is embedded deeper inside \texttt{A} compared to its embedding depth in \texttt{B}.}
During query processing raw lane statements will be parsed into \iqlType{Lane} objects (\ref{sec:json-ld-lane}).

%TODO from here rework

Constraints are further divided into local constraints as part of node or edge definitions and global ones (with the \keyword{HAVING} keyword). 
Local constraints are obligatory and define the basic complexity of the query (flat, tree or graph). 
They also introduce certain limitations on what can be expressed or searched (e.g. a ``flat'' local constraints declaration will not provide implicit access to tree information). 
However, global constraints can introduce arbitrary constraints or relations and thereby increase the evaluation complexity, potentially without limits. 
Since there is no way for an evaluation engine to assess the complexity of user macros or extensions, extensive use of global constraints could in fact lead to extremely slow searches or even create situations where an evaluation will never terminate at all.

\subsection{Flat Constraints}
\label{sec:flat-constraints}

Flat constraints provide no extra helpers to declare structural properties of the query. 
They consist of arbitrary basic constraints \cref{sec:constraints} and disallow both global constraints (\ref{sec:global-constraints}) and filter constraints (\ref{sec:filter-constraints}). 
Note that flat constraints rely on the availability of member references from the binding or lane sections in the query payload to have access to any content at all.
In this regard they behave very similar to global constraints.

\subsection{Structural Constraints}
\label{sec:structural-constraints}

\ac{iql} provides several classes of structural constraints that each feature distinctive syntax features to express structures of increasing complexity.
Those structures are sequences (\ref{sec:sequence-constraints}), trees (\ref{sec:tree-constraints}) and graphs (\ref{sec:graph-constraints}).
They all get explained in more detail in their respective sections, but the syntactic basics for all of them will be defined here.
To simplify the overall \ac{iql} grammar, a general syntax exists for the declaration of nodes (and edges).
This general form honors the aspects specific to each of those structure types, but generally over-generates and only some of its features are actually applicable in concrete use cases.
\Cref{gram:structural-constraint} shows the basic for defining structural constraints in \ac{iql}.
More detailed illustrations of the various components (\synt{node}, \synt{quantifier} and \synt{edge}) follow below.

\begin{gram}[\synt{structuralConstraint}]
	\label{gram:structural-constraint}
	\begin{grammar}		
		<structuralConstraint> ::= <nodeStatement>+
			
		<nodeStatement> ::= <quantifier>? `\{' <nodeStatement>+ `\}'
		\alt <arrangement> <nodeStatement>+
		\alt <node>
		\alt <element> (`,' <element>)*
		\alt <nodeStatement> `or' <nodeStatement>
		
		<arrangement> ::= `ORDERED' | `ADJACENT'
		
		<memberLabel> ::= <member> `:'
		
		<element> ::= <node> | <node> <edge> <node>
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{nodeStatement}
		\sst
			\sst \\ <quantifier> \est `\{' \srp <nodeStatement> \\ \erp `\}' \\
			<node> \\
			<nodeStatement> `or' <nodeStatement> \\
			\sst `ORDERED' \\ `ADJACENT' \est \srp <nodeStatement> \\ \erp \\
			<element> \srp \\ `,' <element> \erp
		\est
	\end{rrdiag*}

	\begin{rrdiag*}{element}
		\sst <node> \\ <node> <edge> <node> \est
	\end{rrdiag*}
\end{gram}

\noindent There are four (partly recursive) approaches to express node statements, i.e. grouping, node sequence, element sequence and disjunction. 
The distinction between node and element sequences exists to easily distinguish sequence or tree queries from graph definitions.
Sequence queries do not include hierarchical structural information and as such have no use for edges.
In the syntax used for tree nodes in \ac{iql} information about the incoming edge is implicitly available from every nested node and constraints related to outgoing edges are to be attached to the respective child terminals of those edges.
For graphs where no simple association between nodes and edges exists, there is a necessity to have explicit edge declarations available for querying.
As such the \synt{element} rule in \cref{gram:structural-constraint} is a placeholder that can be filled with either node or edge declarations.

\subsubsection{Nodes}
\label{sec:nodes}
\ac{iql} uses square brackets (\lit{[} and \lit{]}) to mark individual nodes.
\cref{gram:node} gives an overview of the syntax used for defining nodes with all the optional content elements.
\begin{gram}[\synt{node}]
	\label{gram:node}
	\begin{grammar}			
		<node> ::= <quantifier>? `[' <memberLabel>? (<marker> `,')? <constraint>? <nodeStatement>? `]'
		
		<memberLabel> ::= <member> `:'
	\end{grammar}
	%TODO add grammar fragment for markers
	\diagsep
	\rrhead{node}
	\noindent\begin{rrfrag}{>-}{...}
		\sst \\ <quantifier> \est `[' 
		\sst \\ <memberLabel> \est
		\sst \\ <marker> `,' \est
	\end{rrfrag}\\
	\begin{rrfrag}{...}{->}
		\sst \\ <constraint> \est
		\sst \\ <nodeStatement> \est `]'
	\end{rrfrag}\\
\end{gram}
Declaring a node in a structural constraint implicitly marks it as existentially quantified.
Additionally, nodes can be \textbf{explicitly quantified} with an arbitrary combination of \textit{universal} quantification, \textit{negation}, \textit{explicit} quantification, \textit{at-most} (0 to n), \textit{at-least} (n to inf) or \textit{bounded range} quantification. 
The \cref{gram:quantifier} simplifies the overall rules for \synt{quantifier} to keep it compact.
Albeit being shown here as unrelated to each other, the appearance of the angle brackets (\lit{\textless} and \lit{\textgreater}) before or after the actual quantifier content is restricted to either \textit{both} of them being used (for a proper wrapping, such as \lit{\textless 3..10 \textgreater}) or \textit{none} of them (for plain quantifiers, such as \lit{1|4|ALL}).
\ac{iql} allows multiple quantifiers to be separated by the pipe symbol \lit{|} to express disjunction between quantifiers.
This way complex constraints can be defined very neatly, such as the ``all or nothing'' quantification \lit{\keyword{all}|\keyword{not}}.
This quantifier combination ensures that either all targets in a certain context match the node in question, or none does.\footnote{Example: find all sentences that either have no word with more than five characters or all of their words have five or more characters.}
Note that this \textit{context} of a quantifier plays a fundamental role, as for instance the usage of path markers (\ref{sec:path-markers}) changes along what dimension or path the quantification is to be applied.

\begin{gram}[\synt{quantifier}]
	\label{gram:quantifier}
	\begin{grammar}			
		<quantifier> ::= <simpleQuantifier> (`|' <simpleQuantifier>)*
		\alt `\textless' <simpleQuantifier> (`|' <simpleQuantifier>)* `\textgreater'
		
		<simpleQuantifier> ::=  (`ALL' | `*')
		\alt (`NOT' | `!')
		\alt <digits> (`+' | `-')? (`? ' | `!')?
		\alt <digits> `..' <digits> (`? ' | `!')?
	\end{grammar}
	\diagsep	
	\begin{rrdiag*}{quantifier}
		\sst \\ `\textless' \est \srp
		\sst `ALL' \\ `*' \\ `NOT' \\ `!' \\ \sst 
			<digits> `..' <digits> \\ 
			<digits> \sst \\ `+' \\ `-' \est 
			\est \sst \\ `?' \\ `!' \est
		\est
		\\ `|' \erp \sst \\ `\textgreater' \est
	\end{rrdiag*}
\end{gram}

A node's inner content can optionally have an initial \textbf{member label} (identifier with a colon \lit{:} afterwards) to link this node to a previously defined member binding (\ref{sec:bindings}).
Such as binding restricts the type of corpus member that the node can be matched against.
It also provides a point of reference that subsequent constraints (e.g. in the global constraints section, cf. \cref{sec:global-constraints}) can use to access information of the target the node has been matched against.
Note that cross-referencing between nodes from within local constraints (such as in \verb|[$x:][$y: pos!=$x.pos]|) is discouraged\footnote{The reason behind this is that the \ac{icqp} per default is not required to honor the order of nodes defined in a query or the linking relations between them when planning the state machine for evaluation. As such there is no guarantee that node \member{x} will have already been matched against a valid target when the cross-reference constraint inside \member{y} is evaluated. This would cause an error during evaluation time to occur, which in turn will abort the entire search.} and global constraints should be used for this.
This approach guarantees that by the time such cross-reference constraints (or ``joins'', to use database terminology) are evaluated all involved member variables will be assigned preliminary candidates.

Besides the local constraint described below, nodes can declare special \textbf{marker} expressions, separated from regular constraint or nested nodes by a single comma `,' \footnote{The \ac{iql} grammar declares this comma as mandatory, even if no local constraints or other contents succeeds the marker. This way they can be unambiguously distinguished from normal constraints, both by the \ac{icqp} and human readers.}.
Marker can be regarded as glorified flags and functions that are used to specify a node's intended place in a sequence, hierarchy or tree path.
They are logically separated from normal constraints, as they are used to construct an independent part of the \ac{icqp} state machine with the sole purpose of pruning the search space by limiting the actual target elements to be visited for individual nodes.
A comprehensive introduction to the available markers of various types is given in \cref{chap:utility}. 

Nodes can also optionally define \textbf{local constraints} that must evaluate to \keyword{true} for target item to be considered as result candidate.
Local constraints have full access to properties and annotations of the target item currently being inspected and can take any form described in \cref{sec:constraints}.
Note that it is up to the evaluation engine how to optimize and potentially prune the evaluation process of constraint expressions.
Correct evaluation of a conjunctive local constraints with external function calls \query{[\$x:~func1(\$x) \&\&~func2(\$x) \&\&~func3(\$x)]} must not rely on the premise of any particular function (\texttt{func1}, \texttt{func2} or \texttt{func3}) actually being called at all.
The evaluation semantics of conjunctive Boolean concatenation allow an early determination of the final result as soon as the stable predicate of one of the inner terms evaluating to \keyword{false} is met.
Therefore it is perfectly legal (and in parts expected from an efficient evaluation engine) to not evaluate the calls to \texttt{func2} and \texttt{func3} after \texttt{func1} has already caused the result to remain \keyword{false}.

If a \synt{node} is used within a tree environment, it can also contain a \textbf{nested} \synt{nodeStatement} declaration to define structural constraints on child nodes.
The target item a node is matched against during query evaluation defines the structural context that is then in turn being used for matching the nested \synt{node} instances.
Note that this opens up the entire spectrum of node grouping, disjunctions and arrangement modifiers to define constraints on (sub-)trees.

\subsubsection{Dummy Nodes}
\label{sec:dummy-nodes}
\noindent Sometimes complex queries require that nodes be added to the structural constraints in order to serve as placeholders for (optional) gaps in the target sequence.
Consider for instance a situation where one wants to find multiple pairs of nodes \query{X}\query{Y} in a sequence that might look like ``XY---XY''.
\todo{Rework example, as discontinuous quantifiers already solve that in a more elegant way}
A simple query \query{<1+>\{ADJACENT [X][Y]\}} (see below sections for detailed explanations of the query features used here) will find the two \query{XY} pairs, but not within the same match, as it is not able to expand across the ``empty'' space between them within the same matching pass.
Introducing optional ``dummy'' nodes will help accomplish the desired result and yield \query{<1+>\{ADJACENT <0+?>[] [X][Y]\}} as query.
Note that the \query{<0+?>[]} consumes arbitrary elements in the target sequence as long as the following \query{XY} nodes haven't been matched (cf. explanation on ``reluctant'' quantification in \cref{sec:quantification}).
For simplicity the \ac{iql} specification allows a total of 3 short forms for declaring dummy nodes, listed in \cref{tab:dummy-nodes}.
The query above can then be shortened to \query{<1+>\{ADJACENT [*] [X][Y]\}} to make it more readable.
Dummy node syntax is supported everywhere regular nodes can be declared, except when the node serves as terminal of an edge (\ref{sec:edges}) definition.

\begin{table}[!htb]\centering
	\begin{tabular}{|p{0.15\textwidth}|p{0.15\textwidth}|p{0.60\textwidth}|}
		\hline 
		\textbf{Short Form} & \textbf{Original Form} & \textbf{Description} \\ 
		\hline 
		\hline  
		[?] & <0..1>[] & Optional reluctant node: find up to 1 node if needed. \\ 
		\hline  
		[*] & <0+?>[] & Optional reluctant expansion: find 0 or more nodes if needed. \\ 
		\hline  
		[+] & <1+?>[] & Required reluctant expansion: find 1 or more nodes, expand only if needed. \\ 
		\hline 
	\end{tabular}
	\caption[Dummy node short forms]{Supported short forms for declaring dummy nodes (\cref{sec:dummy-nodes}) in a compact way. Note that all these short forms expand to reluctant quantifier expressions. If another behavior is desired, the respective full form of the quantifier must be used!}
	\label{tab:dummy-nodes}
\end{table}

A technical peculiarity to keep in mind when using dummy nodes is that they effectively influence what counts as ``begin'' of a successful match for the surrounding structural constraint.
\todo{either explain here or add a section in ICQP specification document and link here}

\subsubsection{Quantification}
\label{sec:quantification}
\ac{iql} knows a total of 12 quantifier types (22 when also taking discontinuous counterparts into account), which are grouped into six sets of basic quantification types as shown in \cref{tab:quantifiers}.
Those basic sets are \textit{existential negation}, \textit{universal quantification}, \textit{exact}, \textit{at-least}, \textit{at-most} and \textit{range}.
Note that the \textit{at-most} quantifier implies existential quantification, so it cannot quantify to less than one element. 
For modeling optional existence the \textit{range} quantifier should be used with a lower bound of 0, as in \query{0..4}.

Some quantifiers differentiate between \textit{greedy} (the default), \textit{reluctant} and \textit{possessive} mode.
The differences of those three modes are explained below, assuming that the quantifier in question occurred on a node constraint $n_i$ that is followed by an optional sequence of additional node constraints $n_{i+1}..n_N$.
Note that the complete query will only succeed if $n_i$ \textbf{and} all its successors successfully match!
The primary effect caused by different modes is the size and number of matches reported by the evaluation engine.
\begin{description}
	\item[greedy] Match as many instances for $n$ as possible, while still allowing $n_{i+1}..n_N$ to find appropriate candidates. This will find at least as many instances of $n$ as the \textit{reluctant} mode and at most as many as the \textit{possessive} mode, but is guaranteed to leave room for $n_{i+1}..n_N$ when collecting hits.
	\item[reluctant] Match as few instances for $n$ as possible, considering the need of $n_{i+1}..n_N$ to also produce candidates. This will produce the shortest possible sequence of hits for $n$ and is guaranteed to leave room for $n_{i+1}..n_N$ when collecting hits.
	\item[possessive] Match as many instances for $n$ as possible, completely ignoring $n_{i+1}..n_N$. This is guaranteed to find the longest sequence of hits for $n$ but might cause the query to fail when subsequently there is no more room to match $n_{i+1}..n_N$.
\end{description}

\begin{table}[!htb]\centering
	\begin{tabular}{|p{0.08\textwidth}|p{0.10\textwidth}|p{0.11\textwidth}|p{0.60\textwidth}|}
		\hline 
		\textbf{Greedy} & \textbf{Reluctant} & \textbf{Possessive} & \textbf{Description} \\ 
		\hline 
		\hline  
		not &  &  & Existential negation. Alternatively the exclamation mark \lit{!} can be used instead of the \keyword{not} keyword. \\ 
		\hline  
		all &  &  & Universal quantification. Alternatively the asterisk \lit{*} can be used instead of the \keyword{all} keyword. Note that this quantifier can only be used directly on nodes and using it on a node that is not the only one within its context will cause an error. \\ 
		\hline 
		X &  &  & Exact quantification of $X$ instances. \\ 
		\hline 
		X+ & X+? & X+! & Open quantification of \textit{at least} $X$ instances. \\ 
		\hline 
		X- & X-? & X-! & Bounded quantification of \textit{at most} $X$ instances. \\ 
		\hline 
		X-Y & X-Y? & X-Y! & Bounded quantification of \textit{at least} $X$, but \textit{at most} $Y$ instances. \\ 
		\hline 
	\end{tabular}
	\caption[Node quantifiers]{Complete list of element quantifiers supported by \ac{iql}, separated into the six fundamental groups. For quantifier types that do not distinguish between modes the \textit{greedy} column shows the only way of formulating those. The effect of different modes is illustrated in \cref{fig:quantifier-examples}.}
	\label{tab:quantifiers}
\end{table}

An illustration of how the different quantification modes affect matching in an example sequence is shown in \cref{fig:quantifier-examples}.
Using two independent properties of the elements in a sequence (in this case color and shape) and an example query that uses them both a conflicting scenario is provided where individual elements can be matched by both query ``nodes''.
The \cref{fig:greedy-quantifier,fig:reluctant-quantifier,fig:possessive-quantifier} depict in simple terms how the different modes behave in such a conflicting situation.

The greedy mode (\ref{fig:greedy-quantifier}) will always produce the smallest amount of total matches of the entire query, as it is possible for adjacent matches to collapse.
On the other hand, the reluctant mode (\ref{fig:reluctant-quantifier}) will produce the maximum number of matches of an entire query, as it enforces the smallest individual match sizes.
Finally \cref{fig:possessive-quantifier} shows how the possessive mode can cause an entire query to fail by blindly consuming elements that otherwise could have been used by subsequent constraints to produce a successful match.
If in the example however the node \lit{8} was square instead of round, the entire query could still have been successfully matched.

\begin{figure}[!htb]\centering
	\tikzset{
		red node/.style={draw=red!60, fill=red!5, very thick},
		green node/.style={draw=green!60, fill=green!5, very thick},	
		sized node/.style={minimum size=7mm},	
		redround/.style={circle, red node, sized node},
		greenround/.style={circle, green node, sized node},
		redsquare/.style={rectangle, red node, sized node},
		greensquare/.style={rectangle, green node, sized node},
		hit/.style={red!60, draw, dashed, line width=0.7pt},
		match/.style={black!50, draw, very thin}
	}

	\newcommand{\targetNodes}{
		\node[greenround]       at (0,0) {1};
		\node[greensquare]      at (1.5,0) {2};
		\node[redround]    (x1) at (3,0) {3};
		\node[redround]    (x2) at (4.5,0) {4};
		\node[redsquare]   (x3) at (6,0) {5};
		\node[redround]    (x4) at (7.5,0) {6};
		\node[redsquare]   (x5) at (9,0) {7};
		\node[greenround]       at (10.5,0) {8};
		\node[greensquare]      at (12,0) {9};
	}

	\begin{subfigure}{.8\textwidth}\centering
		\begin{tikzpicture}
		\targetNodes
		\end{tikzpicture}
		\caption{Target Sequence}
	\end{subfigure}
	\par\bigskip % force a bit of vertical whitespace
	\begin{subfigure}{.8\textwidth}\centering
		\begin{tikzpicture}
		\targetNodes
		
		\node[hit, label={[label distance=.2em]270:red+}, fit=(x1)(x4)](hit1){};
		\node[hit, label={[label distance=.2em]270:box}, fit=(x5)](hit2){};
		\end{tikzpicture}
		\caption{Hits for greedy mode: \query{red+ box}.}
		\label{fig:greedy-quantifier}
	\end{subfigure}
	\par\bigskip % force a bit of vertical whitespace
	\begin{subfigure}{.8\textwidth}\centering
		\begin{tikzpicture}
		\targetNodes
		
		\node[hit, label={[label distance=.4em]270:red+?}, fit=(x1)(x2)](hit1){};
		\node[hit, label={[label distance=.4em]270:box}, fit=(x3)](hit2){};
		\node[hit, label={[label distance=.4em]270:red+?}, fit=(x4)](hit3){};
		\node[hit, label={[label distance=.4em]270:box}, fit=(x5)](hit4){};
		
		\node[match, fit=(hit1)(hit2)](m1){};
		\node[match, fit=(hit3)(hit4)](m2){};
		\end{tikzpicture}
		\caption{Hits for reluctant mode: \query{red+? box}. Since \query{red+?} allows \query{box} to match the first red square (5), the entire query can actually be matched twice.}
		\label{fig:reluctant-quantifier}
	\end{subfigure}
	\par\bigskip % force a bit of vertical whitespace
	\begin{subfigure}{.8\textwidth}\centering
		\begin{tikzpicture}
		\targetNodes
		
		\node[hit, label={[label distance=.2em]270:red+!}, fit=(x1)(x5)](hit1){};
		\end{tikzpicture}
		\caption{Partial hits for possessive mode: \query{red+! box}. Note that the query fails since \query{red+!} already consumes all the elements that could have been matched by \query{box}.}
		\label{fig:possessive-quantifier}
	\end{subfigure}
	
	\caption[Illustration of quantification]{Graphical illustration of the different quantifier modes. The example query used is \query{red+ box}, looking for first a sequence of red nodes and then a single square formed one.}
	\label{fig:quantifier-examples}
\end{figure}

The evaluation of quantified elements per default looks for continuous repetitions of the quantified element.
To accept discontinuous target instances, all quantifiers except \textit{existential negation} and \textit{universal quantification} can be used with a special flag \texttt{\textasciicircum} (the circumflex symbol) appended to it.
If this flag is present, repetitions of the underlying quantified element will be found by scanning and may contains gaps between successful hits.
This allows for very powerful expressions that can match multiple occurrences of a node in a target structure at different locations.

\subsubsection{Marker}
\label{sec:marker}
%TODO explanation?

\begin{gram}[\synt{marker}]
	\label{gram:marker}
	\begin{grammar}	
		<marker> ::= <identifier> (`(' <number> (`,' <number>)* `)')?
		\alt `(' <marker> `)'
		\alt <marker> (`AND' | `\&\&') <marker>
		\alt <marker> (`OR' | `||') <marker>
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{marker}
		\sst 
		<identifier> \sst \\ `(' \srp <number> \\ `,' \erp `)' \est \\
		`(' <marker> `)' \\
		<marker> \sst `AND' \\ `\&\&' \est <marker> \\
		<marker> \sst `OR' \\ `||' \est <marker> 
		\est
	\end{rrdiag*}
\end{gram}

\subsubsection{Edges}
\label{sec:edges}
Edges are a structural element that is available exclusively to \textbf{graph} constraints (\ref{sec:graph-constraints}).
Each edge minimally consists of a source and target node and a type indicator\footnote{Type indicators for empty edges (i.e. edges without an inner constraint or label definition) always consist of three symbols, cf. \cref{gram:edge}} to signal whether the edge is meant to be undirected, uni- or bidirectional and in the case of unidirectional edges which direction between source and target node it takes.

\begin{gram}[\synt{edge}]
	\label{gram:edge}
	\begin{grammar}	
		<edge> ::= `\textless\textminus\textminus' | `\textminus\textminus\textgreater' | `\textless\textminus\textgreater' | `\textminus\textminus\textminus'
		\alt (`\textless\textminus' | `\textminus\textminus') `[' <memberLabel>? <constraint>? `]' (`\textminus\textminus' | `\textminus\textgreater')
	\end{grammar}
	\diagsep
	\begin{rrdiag*}{edge}
		\sst 
		\sst \lit{\textless\textminus} \\ \lit{\textminus\textminus} \est `[' 
		\sst \\ <memberLabel> \est
		\sst \\ <constraint> \est `]' 
		\sst \lit{\textminus\textminus} \\ \lit{\textminus\textgreater} \est \\
		\lit{\textless\textminus\textminus} \\
		\lit{\textminus\textminus\textgreater} \\ 
		\lit{\textless\textminus\textgreater} \\
		\lit{\textminus\textminus\textminus}
		\est
	\end{rrdiag*}
\end{gram}

Optionally, an edge can also be assigned its own member label and/or local constraints.
In that case the type indicator gets split into two separate parts\footnote{When split, each part of a type indicator uses two symbols, which are the respective 2/3 of the original three-symbol indicator.} with a node-like part in the middle to host the edge's label and/or constraints.
Note that the same guidelines for cross-referencing from within local constraints that were mentioned above in the section about nodes, also apply to local edge constraints: 
Correct evaluation of an edge's local constraints must not rely on the availability of cross-referenced external nodes (including the edge's own source and target nodes) or edges.
As usual global constraints should be used to define constraints that link individual elements such as edges to other (external) parts of the payload.
The section about global constraints (\ref{sec:global-constraints}) contains further hints on the optimization the \ac{icqp} implements in order to prevent unnecessary exploration of the search space.

The \textbf{quantification} of edges follows slightly different rules as compared to regular nodes.
Every edge can have \textbf{up to one} explicit quantifier declaration attached to it, either on the source or target node.
If no quantifier is present, the entire edge is by default existentially quantified, otherwise the following rules apply:
The node not bearing any quantifier is existentially quantified (or ``fixed'') and the quantifier on the other node acts as an indicator for the multiplicity of the edge itself.
The following examples illustrate some use cases for quantification on edges:

\begin{Verbatim}[samepage=true]
// a node x linked to 3 nodes that match y
[$x:]--> <3>[$y:]
// 3 nodes matching x that are linked to the same node y   
<3>[$x:]-->[$y:]
// node x with no direct link to a node that would match y
[$x:]-->![$y:]
\end{Verbatim}

Note that edge definitions cannot be chained, so the query ``find x linked to y, linked to z'' must be expressed in two separate edge definitions, one linking \member{x} to \member{y} and one linking \member{y} to \member{z}.
This means that graph constraints (\ref{sec:graph-constraints}) require some redundancy, but the linked section also explains some easy strategies to minimize overhead.

\subsubsection{Grouping}
\label{sec:node-grouping}
Nodes (or elements) can be grouped together within curly brackets (\lit{\{}~and~\lit{\}}) as defined by the first \synt{nodeStatement} rule in \cref{gram:structural-constraint}.
This is useful for either restricting the scope of modifiers or directives such as the \keyword{ADJACENT} keyword to only a selected few nodes or when expressing a disjunction.
Optionally a node grouping can also be assigned quantifiers (\ref{sec:quantification}) similar to normal nodes (\ref{sec:nodes}) and as such can be used to express very powerful pattern such as repetition of sequences:
\begin{Verbatim}[samepage=true]
ADJACENT <3+>{ADJACENT [$a:][$b:]} [$c:]
\end{Verbatim}
The above query will match at least three repetitions of the pair a+b and the entire repeated sequence is followed by an adjacent node c.

Note that a group counts as an individual node statement inside the outer scope and as such is subject to order directives defined there.
However, those directives are \textbf{not} automatically \textbf{inherited} to the inner collection of nodes in the group, allowing for expressions such as the following node sequence:
\begin{Verbatim}[samepage=true]
ADJACENT [$x:] {[$a:][$b:]} {[$c:][$d:]} [$y:]
\end{Verbatim}
\noindent This would read as ``Find x immediately followed by a, later followed by b+c, later followed by d+y''.
Note that the adjacency modifier does not apply to the inner sequences a+b and c+d, which are only subject to the implicit order of the sequence declaration.\footnote{An additional \keyword{ORDERED} in each of the groups would make that explicit, but is redundant.}
The concept of node grouping is especially important for the tree (\ref{sec:tree-constraints}) and graph (\ref{sec:graph-constraints}) constraints introduced below, as by default those do not impose an a priori order of nodes.
Also note that evaluation of node groupings will not be performed exhaustively if the group has quantifiers assigned to it that allow repetition of the group's content.
In such a case the ``internal'' elements will be evaluated in a one-shot evaluation attempt where only the first possible match is counted and then control is returned to the repetition element.

\subsubsection{Node Sequence}
\label{sec:node-sequences}
\noindent Nodes usable for sequences (\ref{sec:sequence-constraints}) and trees (\ref{sec:tree-constraints}) are defined in a simple sequence style (second \synt{nodeStatement} rule in \cref{gram:structural-constraint}).
Instances of \synt{node} in a sequence are defined one after another without special separator symbols.
They may optionally be preceded by a \synt{arrangement} directive to guide the matching progress.
Currently there are only two directives available to specify the node arrangement (\keyword{ORDERED} and \keyword{ADJACENT}), but this might increase in the future, making node grouping a very important tool for defining complex structural compositions.

\subsubsection{Element Sequence}
\label{sec:element-sequence}
\noindent Similar to node sequences, \synt{element} instances can also be used in a list-style collection (third rule of \synt{nodeStatement} in \cref{gram:structural-constraint}), but with noticeable differences: 
Element sequences do use a separator symbol (a simple comma \lit{,}) between \synt{element} definitions.
Since \ac{iql} does not use keywords to signal the structural type to be expected in a query payload\footnote{An earlier draft made use of \keyword{TREE} and \keyword{GRAPH} keywords to distinguish those types from the basic node sequence, but in an effort to reduce the overall number of keywords (that users had to learn) this approach was dropped.} this approach was necessary to easily detect the type of structure.
It also hints at the second difference, that is, element sequences do not support arrangement modifiers (as \synt{element} instances can be either nodes or edges, with the latter not being suitable for this kind of ordering) and as such can be more intuitively be understood as sets of \synt{element} instances.

\subsubsection{Structural Disjunction}
\label{sec:structural-disjunction}
\noindent As the forth option of \synt{nodeStatement} in \cref{gram:structural-constraint}, the disjunction of entire node statements provides a very powerful tool to express complex queries.
Two node statements are linked with the \keyword{OR} keyword to mark them as ``either or'' cases.
Since this opens up recursion, a complex disjunction may contain more than two node statements in total.
Note that the order of node statements in a disjunction does not imply a specific priority the evaluation engine has to follow.
For illustration, the second example below might match an instance of \verb|[$y:]| first:
\begin{Verbatim}[samepage=true]
[$x:] or [$y:]          // x or y
[$x:] or [$y:] or [$z]  // x or y or z
[$x:] or {[$y:][$z]}    // either x alone or a sequence y+z
[$x: {[$y:] or [$z]}]   // tree node x with either y or z as child
// complex nested disjunctions
[$x: [$y: [$z: [$a:] or [$b:]]] or [$z]]
\end{Verbatim}

\subsection{Sequence Constraints}
\label{sec:sequence-constraints}

As the most basic form of structural constraints this type is used to match sequences of nodes to \repoLink{\modelsUrl members/item/Item.java}{items} in the target corpus.
Multiple nodes in a sequence declaration are required to match to items in exactly the order they are defined in (but not necessarily adjacent to each other, use the \keyword{ADJACENT} directive in front of a node sequence for that).

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
[]                  // empty node
[pos=="NN"]         // node with local constraint
<2>[$x:]            // node x exactly 2 times       
[$x:]<2-5>[][$y:]   // nodes x & y with 2-5 nodes in between
[$x:] ![$y:]        // node x without any node y following
ADJACENT [$x:][$y:] // node y directly following node x
[$x:] or [$y:]      // disjunction: either x OR y
{[$x:][$y:]} or [$z:] // disjunction: either group x+y OR z
\end{Verbatim}

\paragraph{Sequence Matching}
\noindent Sequence constraints only provide a single dimension for \textit{moving} the query sequence through the search space of the target corpus.
Matching is performed greedily by default in order of node appearance in the query, following the direction specified by the corpus itself.
That is, in a node sequence \verb|[$x:][$y:]| the node matched by \member{x} will \textbf{always} be before the node matched by \member{y} according to the original direction of items in the corpus.
This also leads to a very simple and intuitive semantic for the \keyword{FIRST} and \keyword{LAST} modifier keywords: They stay true to their names and limit the returned matches to either the first or last ones, with respect to the current direction.

Empty nodes with quantifiers can be used as proxies to model distance constraints, as seen in above examples.
Since the \keyword{ADJACENT} directive changes the behavior of an entire node sequence, some creativity can be necessary to achieve mixed cases, such as \textit{``find an adjacent pair a+b that is later followed by another adjacent pair c+d''}.
Possible (and simple) solutions for this query could be the following:
\begin{Verbatim}[samepage=true]
ADJACENT [$a:][$b:] <0+>[] [$c:][$d:]
{ADJACENT [$a:][$b:]} {ADJACENT [$c:][$d:]}
\end{Verbatim}

\subsection{Tree Constraints}
\label{sec:tree-constraints}

Located between mere sequences (\ref{sec:sequence-constraints}) and graphs (\ref{sec:graph-constraints}) this type of structural constraints is meant to target tree structures, such as (but not limited to) syntax trees, coreference structures, discourse, etc.
To simplify query syntax, \ac{iql} uses a similar approach as the original ICARUS project, which in turn took inspiration from PML-TQ:
To signal parent-child relations, child nodes are nested within their respective parent, effectively making each node yet another scope for a sequence of child nodes.
Contrary to bare sequence constraints (\ref{sec:sequence-constraints}) the order of (child) nodes to be matched in the corpus is \textbf{not} implicitly defined by the order of constraint nodes!
Instead, the \keyword{ORDERED} or \keyword{ADJACENT} keywords need to be used explicitly to signal that a specific kind of order should be honored.\footnote{Also note that \keyword{ORDERED} and \keyword{ADJACENT} when used inside tree nodes are referring to the order of nodes as defined by the parent, \textbf{not} their overall position when projected onto the underlying foundation layer!}
Apart from this little addendum tree constraints behave basically the same as nested sequence constraints:
They can be individually quantified or existentially negated, as well as grouped and linked via the \keyword{OR} keyword to expression disjunctions.

\paragraph{Examples:}

\begin{Verbatim}[samepage=true]
[[]]              // anonymous nesting of nodes
[$x: [$y:]]       // nesting of node y inside x
[[$x:] [$y:]]     // nesting of siblings x and y
[$x: [$y: [$z:]]] // deep nesting chain 
[$x: <2->[$y:]]   // at most 2 y nested inside x
[$x: ![$y:]]      // node x without any child matching y

// internal disjunction
[[$x:] or [$y:] or {[$z: <4+>[]]}]
\end{Verbatim}

\paragraph{Tree Matching}

\noindent As opposed to sequences (\ref{sec:sequence-constraints}), trees (and subsequently also graphs, cf.~\ref{sec:graph-constraints}) offer an additional dimension of matching freedom over the bare iteration of items in a container or structure to be matched.
This requires further specification of the matching process to guarantee consistent results and define basic expectations.
Below explanations are primarily intended to specify the behavior in the presence of limiting modifiers (\keyword{FIRST}, \keyword{LAST}, \keyword{ANY}) in the payload, but are also of interest for the expected order of returned matches if no limiting modifiers are defined.

\begin{wrapfigure}[12]{L}{0pt} %not sure what produced the 
	\centering
\begin{forest}
	for tree={
		if n children=0{
			tier=terminal
		}{},
	}
	[Root 
		[A\textsubscript{1} [1]] 
		[A\textsubscript{2} 
			[\textcolor{darkgreen}{X\textsubscript{1}} 
				[A\textsubscript{3} [2]]  
				[\textcolor{darkgreen}{Y\textsubscript{1}}
					[A\textsubscript{4} [3]]
					[A\textsubscript{5} [4]] 
				] 
				[\textcolor{darkred}{Y\textsubscript{2}} [5]] 
			]
		]		
		[\textcolor{darkred}{X\textsubscript{2}} 
			[A\textsubscript{6} [6]]  
			[\textcolor{darkred}{Y\textsubscript{3}} [7]] 
		] 
	]
\end{forest}
\caption[Example target tree for simple query]{\label{fig:tree-matching} Example tree with highlighted hits for the simple tree query \query{[\$x:~[\$y:]]}.}
\end{wrapfigure}

Consider a simple tree query \query{[\$x:~[\$y:]]} where \member{x} and \member{y} are bound nodes with individual constraints.
The nodes X\textsubscript{n} or Y\textsubscript{n} in the example tree (\cref{fig:tree-matching}) then denote the $n$-th node that match the constraints of query nodes \member{x} and \member{y}, respectively.
The nodes A\textsubscript{1} to A\textsubscript{6} are placeholders for nodes that match neither \member{x} nor \member{y}.

The tree contains 3 possible matches for the query, specifically the pairs \texttt{\{X\textsubscript{1},Y\textsubscript{1}\}}, \texttt{\{X\textsubscript{1},Y\textsubscript{2}\}} and \texttt{\{X\textsubscript{2},Y\textsubscript{2}\}}.
\todo{expand on the order of matches}

\noindent\query{[Root 
	[A\textsubscript{1}] 
	[A\textsubscript{2} 
	[\textcolor{darkgreen}{X\textsubscript{1}} 
	[A\textsubscript{3}]  
	[\textcolor{darkgreen}{Y\textsubscript{1}}
	[A\textsubscript{4}]
	[A\textsubscript{5}]] 
	[\textcolor{darkred}{Y\textsubscript{2}}]]]		
	[\textcolor{darkred}{X\textsubscript{2}} 
	[A\textsubscript{6}]  
	[\textcolor{darkred}{Y\textsubscript{3}}]]]
}

\subsection{Graph Constraints}
\label{sec:graph-constraints}

\todo[inline]{content, explain node and edge composition, mention referencing as a strategy to minimize edge declaration overhead, etc...}

\subsection{Global Constraints}
\label{sec:global-constraints}

Global constraints can be any basic constraint \cref{sec:constraints} and follow after the main section of structural constraints, indicated by the \keyword{HAVING} keyword (cf. \cref{gram:selection}).

\paragraph{Evaluation Priorities}
\noindent If global constraints are present, the evaluation process changes to a two-stage strategy:
Matchers for the associated structural constraints produce preliminary result candidates and the global constraints are then evaluated for each such candidate.
This makes global constraints both very powerful as they have access to more information compared to regular (internal or local) constraints (e.g. they already \textit{know} that all local constraints evaluated to \keyword{true} and the exact candidates produced for structural constraints) and also very critical when it comes to performance.
It can be very tempting to construct queries such as the following one (bindings section omitted) that only matches when \member{y} is the last child of \member{x}:
\begin{Verbatim}[samepage=true]
FIND [$x: [$y:]] HAVING $x.indexOf($y) == $x.size-1
\end{Verbatim}
This will cause the structural matcher to potentially propose \textbf{all} children of \member{x} as candidates to be processed by the global constraints section.
Subsequently, for a node of size $N$ this will produce $N-1$ candidates that are bound to fail the global constraint check.
\cref{chap:utility} lists several families of utility markers and functions that can be used to guide the evaluation engine into more efficient searches.
With the use of those utility markers, above query looks like the following and will be vastly more efficient to evaluate:
\begin{Verbatim}[samepage=true]
FIND [$x: [$y: isLastChild,]]
\end{Verbatim}
Similarly global constraints are not the place to perform filtering on general properties of the current \ac{uoi}, such as sentence length (use the \keyword{FILTER BY} expression for that, cf. \cref{sec:filter-constraints}).

\paragraph{Constraint Hoisting}
Per default, global constraints are second-class constraints, that are only consulted once the structural and local constraints in the other sections of a query payload have been evaluated.
This provides them with a lot more decision power and available information, but also can lead to rather inefficient evaluation scenarios.
Consider a query \query{FIND~[\$x:~[\$y:~[\$z]]] HAVING \$x.pos!=\$y.pos} that looks for nested nodes \member{x}, \member{y} and \member{z} where in addition to local constraints the nodes \member{x} and \member{y} are required to have different part-pf-speech tags.
With the default two-stage evaluation process described above this would result in a serious overhead when evaluating a target tree: 
For every successful match of \query{[\$x:~[\$y:]]} the engine would continue to look for children of \member{y} matching \member{z}, regardless of \member{x} and \member{y} satisfying the global constraint.

Through a optimization technique dubbed \textit{constraint hoisting} the \ac{icqp} will try to work around this performance issue and attach global constraints to the nodes in the (tree) automaton that matches a certain part of the query.
In the example above the matcher would evaluate the global constraint \query{\$x.pos!=\$y.pos} as soon as it successfully identified candidates for \member{x} and \member{y}, thereby reducing the overhead of searching for potential candidates for \member{z} that would ultimately fail due to \member{x} and \member{y} not satisfying the global constraint.

Note that only very specific global constraints can successfully be hoisted! 
\todo{list properties required for hoisting and mention hoisting of constraint fragments, since IQL splits boolean expressions into fragments}

\section{Result Processing}
\label{sec:result-processing}

There be dragons\dots

(Content of the result section will be added as \ac{iql} evolves)

\chapter{Utility Markers \& Functions}
\label{chap:utility}

The following utility features are provided by the \ac{icqp} but are \textbf{not} part of the core specification. 
As such it is possible for engine extensions to override them, change their behavior or completely remove them if desired.
They are listed here as per default they all are available and provide valuable improvements for performance and usability.

\section{Position Markers}
\label{sec:position-markers}

Every node (\ref{sec:structural-constraints}) in a query has an implicit \repoLink{\modelsUrl /members/container/Container.java}{Container} or \repoLink{/members/structure/Structure.java}{Structure} context that it is hosted  or contained in.\footnote{The \ac{icmf} specifies that each item can only be hosted (or more accurately \textit{owned}) by a single container or derived object, but be contained within an arbitrary number of additional containers or structures.}
\ac{iql} offers a variety of predefined helper functions  to exploit this fact and to optimize queries.
\cref{tab:position-markers} lists the functions currently available, their arguments and matching conditions.
Note that legal arguments for a node that occurs in a container of size $N$ reside in the closed integer interval $[1..N]$ for regular index values and $[-N..-1]$ for reverse indices (see below).\footnote{This is in contrast to the 0-based access of array or list elements in \ac{iql}.}
The syntax for providing arguments follows the normal rules for method invocations in \ac{iql} \ref{sec:method-invocations}, e.g. \query{isOutside(4, 12)}.
Arguments can be provided as literals, which is is the preferred way, or as any other kind of expression that evaluates to the necessary type (or can be converted, depending on the query configuration).
It is not possible to access properties from the node itself for which the marker is defined, as position markers are evaluated \textbf{before} the corresponding nodes are matched and subsequently any such attempts will result in an error during query evaluation.
However, globally accessible information or any data provided by surrounding containers or structures can be used to specify marker arguments.\footnote{For example, a node could be defined to be in first position for short sentences and in last position for long ones.}

\begin{table}[ht]\centering
\begin{tabular}{|p{0.17\textwidth}|p{0.14\textwidth}|p{0.60\textwidth}|}
	\hline 
	\textbf{Label} & \textbf{Arguments} & \textbf{Matching Condition} \\ 
	\hline 
	\hline  
	isFirst & - & Node is the first in its context ($index = 1$). \\ 
	\hline 
	isLast & - & Node is the last in its context ($index = N$). \\  
	\hline 
	isAfter & int & Node occurs after designated position ($index > arg$). Legal values are: $1 \leq arg < N$ (or $-N \leq arg < -1$ for reverse indices). \\  
	\hline 
	isBefore & int & Node occurs before designated position ($index < arg$). Legal values are: $1 < arg \leq N$ (or $-N < arg \leq -1$ for reverse indices). \\  
	\hline 
	isInside & int, int & Node occurs inside designated interval ($arg_1 \leq index \leq arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$ (or $-N \leq arg_1 < arg_2 \leq -1$ for reverse indices). \\  
	\hline 
	isOutside & int, int & Node occurs outside designated interval ($index < arg_1$ and $index>arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$ (or $-N \leq arg_1 < arg_2 \leq -1$ for reverse indices). \\  
	\hline 
	isAt & int & Node occurs at specific position ($index = arg$). Legal values are: $1 \leq arg \leq N$ (or $-N \leq arg \leq -1$ for reverse indices). \\  
	\hline 
	isNotAt & int & Node occurs at any position except the designated one ($index \neq arg$). Legal values are: $1 \leq arg \leq N$ (or $-N \leq arg \leq -1$ for reverse indices). \\  
	\hline 
\end{tabular}
\caption[Global position markers]{Position markers provided by the default evaluation engine for \ac{iql}. The conditions in the last column assume a container of size \textit{N} as context. If a marker function takes arguments, they appear in the conditions as $arg$ for the sole argument or $arg_i$ for the $i$-th argument list, with $arg_1$ being the first argument.}
\label{tab:position-markers}
\end{table} 

\subsection{Negation}
\label{sec:marker-negation}
Position markers cannot be negated when used in a constraint expression.\footnote{Depending on the query configuration doing so would either fail the evaluation process with an error or silently ignore the issue, potentially producing invalid results.}
For every function/marker in \cref{tab:position-markers} there exists a complement that can be used to easily express the negated condition.
For instance \query{isBefore(n)} can be negated into \query{isAfter(n-1)}, but the engine will not perform this conversion and it up to the user to properly provide the intended negated form.
Trying to negate a position marker inside structural constraints will result in an error during the preprocessing of the query payload.

\subsection{Reverse Indices}
\label{sec:marker-reverse}
Any position marker that takes at least one argument also supports negative values that are treated as reverse indices, starting from the end of the surrounding container's size.
This follows the same semantics as the index scheme for arrays or lists (\ref{sec:list-access}).
Note that certain position markers with interval arguments (such as \query{inBetween($arg_1$,~$arg_2$)}) still require actual interval boundaries to be in the proper order (generally $arg_1 \leq arg_2$).

\subsection{Relative Indices}
\label{sec:marker-relative}
%TODO rework the rounding explanation
Per default all the position markers that take argument expect them to be integer values for explicit designation of the desired index or index range.
This means that any other type of argument will be automatically converted to an integer value if the query configuration permits it.
However, if the associated switch (\ref{sec:json-ld-switches}) is active\footnote{This switch is off by default as it interferes with the automatic type conversion of arguments. If it is active, arguments must explicitly be cast if not already an integer or floating-point number. If the switch is not active, any floating-point argument will be cast to an integer (typically 0 if any of the arguments are intended to be reverse indices).}, position markers can use relative arguments in the form of floating-point numbers.
Relative indices are expected to be in the open interval $(0..1)$ (or $(-1..0)$ for negative reverse indices) and are treated as percentages of the total size of the surrounding container.
The following examples illustrate this approach (assume the markers are used inside a token node that is directly hosted within a sentence):
\begin{Verbatim}[samepage=true]
// the token can only occur in the first half of the sentence
isBefore(0.5)

// the token must occur in the closed interval [20%, 80%]
isBetween(0.2, 0.8)
\end{Verbatim}
The actual index values to be used for determining the legal position of the node are calculated by multiplying the context's size attribute (e.g. the length of the surrounding sentence) with the marker's relative argument and then rounding up the result to the nearest integer, after which a conversion into 0-based index space is applied.
It is easily possible to define the same position marker with relative indices in both normal and reverse form.
For instance, \query{isBefore(0.8)} and \query{isBefore(-0.2)} both describe the same 80\% interval.
As a general rule, relative indices should only be used with regular (positive) arguments.

\subsection{Marker Stacking}
\label{sec:marker-stacking}
Position markers can freely be mixed in disjunctive or conjunctive expressions.
\begin{Verbatim}[samepage=true]
[isLast,]
[isBefore(10), pos!="NN"]
[isBefore(10) || isAfter(24), pos!="NN"]
[isNotAt(5) && (isBefore(10) || isAfter(24)), pos!="NN"]
\end{Verbatim}
\todo{rework, since we dropped the DNF requirement}
The reasons for this stems from the underlying interval arithmetic.
Each positional marker effectively describes one or more non-empty intervals of possible index values for the node based on the overall size of the target container.
Conjunction of markers results in the intersection of their intervals, possibly creating an empty set, which will render the node constraint impossible to satisfy.
Disjunction of markers on the other hand creates a union of their intervals, either joining them if they overlap or creating a set of disjoint intervals that denotes a discontinuous collection of legal values.
The final result is a fixed\footnote{Fixed in the sense that it only depends on the overall size of the surrounding container.} collection of index values that can be iterated to check for potential result candidates.
In the absence of any kind of positional marker this default index set to be traversed is the complete interval $[1..N]$ for a host container of size $N$.

\subsection{Markers \& Quantification}
\label{sec:marker-quantification}
Markers can be freely combined with quantifiers on the same node, with the following rules:
\begin{itemize}
	\item Markers apply to \textbf{all} instances of a node, so they effectively take priority over quantifiers that allow multiple instances of a node to match.
	\item A node that bears at least one marker is effectively existentially quantified and so it is \textbf{not} possible to combine markers and the \textit{existential negation} quantifier.
	\item In similar fashion, universal quantification is not compatible with markers of any kind, even if they would allow the entire target sequence as legal index interval.
\end{itemize}

To illustrate the interaction of quantifiers and markers, consider the example of a node \query{<3..5>[\$x: isInside(1,0.25),]}.
This query requires at least three, but no more than five instances of \member{x} to be matched in the first 25\% of a target sequence.
Evaluated against a sequence of size 10, this query will automatically fail, as the legal interval produced by the marker only provides access to the first two elements of the sequence\footnote{Markers round down to the nearest integer size for relative indices, see \cref{sec:marker-relative}.}.
A sequence of size 12 is the smallest target that even has a chance of being matched.
Note however that until the target size for this example reaches 20, the total number of hits for \member{x} will never satisfy the upper bound for the range quantifier, as the marker's index interval won't support enough elements.

\subsection{Markers in Global Constraints}
\label{sec:marker-global}
Global constraints (\ref{sec:global-constraints}) have access to an extended version of the ``local'' position markers that acts as a general predicate for items (and additional index arguments, depending on the marker).
So for example \query{isLast(\$x)} is the method-equivalent to the local marker \query{[\$x: isLast,]}.
Note that there is no performance benefit by using those methods in global constraints, as actual position markers are only recognized within structural constraints.
The version for global constraints merely serves as syntactic sugar.
However, since those methods are not subject to the same limitations as mentioned int the section about stacking above, they can be used freely inside local constraints.

\section{Tree Markers}
\label{sec:tree-markers}

While the basic positional markers described in \cref{sec:position-markers} limit a node's overall position in the surrounding container, tree markers work on the hierarchical properties of tree structures.
As such they define legal positions of a node within its parent's list of children.
All tree markers are subject to the same rules as position markers regarding negation, relative and reverse indices, as well as stacking.
Note however, that the default order for traversing child nodes in a tree does not necessarily\footnote{The \ac{icmf} does however strongly encourage tree structures to order children according to their begin-offsets if it does not interfere with their intended semantics.} reflect the actual order of the child nodes position when projected onto the underlying foundation layer.
It can therefore make sense to define additional precedence constraints via global constraints if needed.

\begin{table}[!htb]\centering
	\begin{tabular}{|p{0.17\textwidth}|p{0.14\textwidth}|p{0.60\textwidth}|}
		\hline 
		\textbf{Label} & \textbf{Arguments} & \textbf{Matching Condition} \\ 
		\hline 
		\hline  
		isFirstChild & - & Node is the first child of its parent ($childIndex = 1$). \\ 
		\hline 
		isLastChild & - & Node is the last child of its parent ($childIndex = N-1$). \\  
		\hline 
		isChildAfter & int & Node occurs as child after designated position ($childIndex > arg$). Legal values are: $1 \leq arg < N$. \\  
		\hline 
		isChildBefore & int & Node occurs as child before designated position ($childIndex < arg$). Legal values are: $1 < arg \leq N$. \\  
		\hline 
		isChildInside & int, int & Node occurs as child inside designated interval ($arg_1 \leq childIndex \leq arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$. \\  
		\hline 
		isChildOutside & int, int & Node occurs as child outside designated interval ($childIndex < arg_1$ and $childIndex>arg_2$). Legal values are: $1 \leq arg_1 < arg_2 \leq N$. \\  
		\hline 
		isChildAt & int & Node occurs as child at specific position ($childIndex = arg$). Legal values are: $1 \leq arg \leq N$. \\  
		\hline 
		isChildNotAt & int & Node occurs as child at any position except the designated one ($childIndex \neq arg$). Legal values are: $1 \leq arg \leq N$. \\  
		\hline 
		isLeftChild & - & Node's covered region on the foundation layer is outside and to the left of that covered by its parent ($child.right < parent.left$). Legal values are: $1 \leq arg \leq N$. \\  
		\hline 
		isRightChild & - & Node's covered region on the foundation layer is outside and to the right of that covered by its parent ($child.left > parent.right$). Legal values are: $1 \leq arg \leq N$. \\  
		\hline 
	\end{tabular}
	\caption[Tree positional markers]{Positional markers for trees provided by the default evaluation engine for \ac{iql}. The conditions in the last column assume a parent node with \textit{N} children as context and $childIndex$ being the desired position of the node within its parent's list of children. If a marker function takes arguments, they appear in the conditions as $arg$ for the sole argument or $arg_i$ for the $i$-th argument list, with $arg_1$ being the first argument.}
	\label{tab:tree-position-markers}
\end{table}

\subsection{Hierarchy Markers}
\label{sec:hierarchy-markers}
Apart from the horizontal domain described above, tree markers also cover the hierarchical aspect of tree structures.
A series of additional markers is available to specify a node's vertical location in the tree, as shown in \cref{tab:tree-hierarchy-markers}.
These markers inherit all the rules of general tree markers, except that they cannot be used with relative indices.%\footnote{The reason is that all the hierarchy-related methods in \ac{icmf} are optional and as such a tree object cannot be expected to provide ready-to-use information about its depths or the heights of individual subtrees. Subsequently the \ac{icqp} would have to analyze a tree first before being able to construct an efficient matcher for it, which defeats the purpose of}

\begin{table}[!htb]\centering
\begin{tabular}{|p{0.23\textwidth}|p{0.14\textwidth}|p{0.54\textwidth}|}
	\hline 
	\textbf{Label} & \textbf{Arguments} & \textbf{Matching Condition} \\ 
	\hline 
	\hline  
	isRoot & - & Node is a designated root in the structure. \\ 
	\hline 
	isNoRoot & - & Node has a parent. \\ 
	\hline 
	isLeaf & - & Node is a leaf, i.e. it has no children. \\  
	\hline 
	isNoLeaf & - & Node is not a leaf, i.e. it has at least one child. \\  
	\hline 
	isIntermediate & - & Node is neither a designated root nor a leaf. \\  
	\hline 
	isGeneration & int & Node is a member of the $arg$-th generation of the parent node. Note that only values of $arg \geq 2$ make any sense, as per default parent-child nesting in tree constraints implies membership in the 1\textsuperscript{st} generation. \\  
	\hline
	isNotGeneration & int & Node is nested arbitrarily deep in its parent, but not in the designated generation. \\  
	\hline  
	isGenerationAfter & int & Node is nested at least $arg+1$ generations deep in its parent. \\  
	\hline 
	isGenerationBefore & int & Node is nested no more than $arg-1$ generations deep in its parent. \\  
	\hline 
	isAnyGeneration & - & Node is nested arbitrarily deep in its parent. This is the equivalent of a full transitive closure over the tree dominance relation between parent and child nodes. \\  
	\hline 
	isLeftmostt & - & Node is located along the path of leftmost descendants (according to the actual position on the underlying foundation layer, \textbf{not} necessarily the order of child nodes along each step). This marker is generally combined with one of the generation-based markers to provide an indicator on the vertical location of the desired descendant. \\  
	\hline 
	isRightmost & - & Represents the symmetric opposite of above \query{isLeftmost}, marker, following the path of rightmost descendants. \\  
	\hline 
\end{tabular}
\caption[Hierarchical markers]{Additional markers for hierarchical properties in tree structures. Note that ``parent'' in the matching conditions refers to the node in a target tree that has been matched by the original node's parent.}
\label{tab:tree-hierarchy-markers}
\end{table}

All the additional hierarchical markers in \cref{tab:tree-hierarchy-markers} operate purely on the vertical axis within a tree structure (with the exception of the two ``descendants'' markers that use the fringes of the subtree spanned by a node's parent to place candidate nodes in the target tree).
The initial lot of them (\query{isRoot}, \query{isNoRoot}, \query{isLeaf}, \query{isNoLeaf} and \query{isIntermediate}) are based on the presence or absence of child nodes and/or a parent.
The remaining markers use the concept of \textit{generations}\footnote{Also often called ``levels'' in tree structures.} in the tree.
Given a tree structure $T$ and the root node $R$, the set of nodes in $T$ are partitioned into disjoint sets of generations $G_0$ to $G_n$ where $n$ is the height of $T$ and $G_i$ is the set of nodes belonging to the $i$-th generation, that is all the nodes with a depth of $i$ (i.e. path distance $i$ to $R$). 
Note that $R$ is the only member in $G_0$ and $G_n$ can only contain leaf nodes.
Generations in structural \ac{iql} queries are always calculated based on the immediate parent of the node declaration that contains the marker(s).
If a constraint related to the nesting distance between transitively nested nodes or other non-immediate relations is desired, global constraints (\ref{sec:global-constraints}) should be used, possibly employing dedicated tree functions (\ref{sec:tree-functions}).

If no generation markers are used within a node constraint and the node is nested, a direct parent-child relation is assumed, which is equivalent to \query{isGeneration(1)}.
Nodes that represent the root of a tree query can also use generation-based markers to indicate where in a prospective target tree the associated item should be located.
Regular tree hierarchy markers can also be combined with generation-based markers to  further specify the location within a tree.
For instance, \query{[\$x: [isGenerationAfter(2) \&\& isNoLeaf,]]} will match any node that is nested at least 3 steps deep within \member{x} but ignores leaves.
The \query{isRoot} marker however cannot be combined with any other hierarchy-related markers, as only designated roots in the target structure can match it and the only sensible combinations would be with normal (horizontal) position markers (\ref{sec:position-markers}).
If the \query{isRoot} marker is being used within a nested node, an error will be issued as the query will be impossible to satisfy.\footnote{The \ac{icqp} does this for any kinds of obviously erroneous queries when the planning phase results in unsolvable issues.}


\subsection{Path Markers}
\label{sec:path-markers}

While hierarchical and regular tree markers (\ref{sec:tree-markers}, \ref{sec:hierarchy-markers}) operate on strictly one of either the horizontal or vertical dimension within a tree, path markers effectively combine horizontal and vertical navigation into a single marker.
As such they describe a path starting from a particular node downwards rather than a specific position within that node's list of immediate children or a vertical range within the tree.

\begin{table}[!htb]\centering
	\begin{tabular}{|p{0.23\textwidth}|p{0.14\textwidth}|p{0.54\textwidth}|}
		\hline 
		\textbf{Label} & \textbf{Arguments} & \textbf{Matching Condition} \\ 
		\hline 
		\hline 
		isLeftmost & - & Node is located along the path of leftmost descendants (according to the actual position on the underlying foundation layer, \textbf{not} necessarily the order of child nodes along each step). \\  
		\hline 
		isRightmost & - & Represents the symmetric opposite of above \query{isLeftmost}, marker, following the path of rightmost descendants. \\  
		\hline 
	\end{tabular}
	\caption[Path markers]{Additional markers for path properties in tree structures.}
	\label{tab:tree-path-markers}
\end{table}

\paragraph{Fringe Markers}
\noindent The two \textbf{fringe} markers \query{isLeftmost} and \query{isRightmost} signal that node candidates must be located at the left (or right) fringe of a target tree as illustrated by \cref{fig:tree-fringe}.
Note that the \textit{leftmost} and \textit{rightmost} properties do \textbf{not} refer to the position of children within their parent's list of child nodes.
Instead the actual position on the underlying foundation layer is taken as basis for determining which nodes belong to the respective fringes.
More specifically, an item's begin index is responsible for its position in the lift of \textit{leftmost} candidates, and the end index is taken as the decisive property when it comes to the \textit{rightmost} fringe.
Since the \ac{icmf} does not require structures to order outgoing edges for a parent node according to the positional indices of its children, using those fringe markers can incur a certain computational overhead.

\begin{figure}
	\centering
	\begin{forest}
		for tree={ circle, draw	}
		[Root 
			[\textcolor{darkgreen}{1}
				[\textcolor{darkgreen}{4} [\textcolor{darkgreen}{11}]] [5] [6 [12] [13]]
			] 
			[2
				[7] [8 [14]]
			]
			[\textcolor{darkred}{3}
				[9 [15] [16]] [\textcolor{darkred}{10}]
			]
		]
	\end{forest}
	\caption[Fringe illustration]{\label{fig:tree-fringe} Example tree with highlighted nodes on the fringes for the \query{isLeftmost} (\textcolor{darkgreen}{green}, nodes 1, 4 and 11) and \query{isRightmost} (\textcolor{darkred}{red}, nodes 3 and 10) markers.}
\end{figure}

\paragraph{Quantification}
\noindent With regular tree markers (\ref{sec:tree-markers}) quantifiers operate along the horizontal axis (either globally or within the context of a node's list of children).
Path markers however completely change this behavior in a way that quantification happens along the path defined by the marker.
This means that quantification effectively changes to be vertical with the path marker acting as guide for picking the next path element from a horizontal pool of candidates.

\paragraph{Marker Stacking}
\noindent Path markers are typically combined with one or more generation-based markers to further specify a node's position in the tree.
If no additional hierarchical marker is provided only the immediate children of a node are taken into account.
Otherwise the path marker will guide the selection of child nodes along the path to the desired vertical position.
Note however, that the presence of quantifiers greatly restricts what kind of marker stacking is actually legal in a particular case.
If for instance a quantifier requires more than one instance of the node to be matched along the path, but a generation-based marker limits the occurrence to be on only a single level, the query becomes unsolvable and the \ac{icqp} will issue an error.

\paragraph{Examples:}\footnote{Node references based on the example tree in \cref{fig:tree-fringe}.}
\begin{Verbatim}[samepage=true]
[isLeftmost && isLeaf,]            // node 11
[isRightmost && isGeneration(-2),] // node 3
// go down 2 to 4 nodes alongside the left fringe
<2-4>[isLeftmost,]
// impossible query
<2>[isLeftmost && isGeneration(3),]
\end{Verbatim}

\subsection{Evaluation Performance}
\label{sec:hierarchy-markers-performance}
Tree-related methods for fetching hierarchical information (such as height and depth of a node) are optional in \ac{icmf}.
As a result the \ac{icqp} might have to compute the data required for evaluating a query at runtime, generating some additional overhead from tree traversals. 
This is especially critical for hierarchical markers that use reverse indices, as knowledge about the overall tree height is required to effectively translate relative indices into absolute intervals of legal (generation) values.

\section{Sequence Functions}
\label{sec:sequence-functions}
\todo[inline]{finish}

\todo{correct description/caption in table}
\begin{table}[!htb]\centering
	\begin{tabular}{|p{0.20\textwidth}|p{0.14\textwidth}|p{0.10\textwidth}|p{0.45\textwidth}|}
		\hline 
		\textbf{Label} & \textbf{Arguments} & \textbf{Result} & Description \\ 
		\hline 
		\hline  
		isAdjacent & node[] & Boolean & Check whether the given nodes form a continuous interval on the underlying foundation layer. \\ 
		\hline  
		isOrdered & node[] & Boolean & Check whether the given nodes form an ordered sequence, as indicated by their begin indices, allowing for nodes to overlap. \\ 
		\hline  
		isOrderedDisjoint & node[] & Boolean & Check whether the given nodes form a disjoint ordered sequence, as indicated by their begin indices. \\ 
		\hline 
	\end{tabular}
	\caption[Sequence functions]{Utility functions for advanced sequence matching. Primarily these functions are intended to provide equivalents for the position markers in \cref{sec:position-markers} usable in global constraints and batch methods for checking the horizontal arrangement of nodes.}
	\label{tab:sequence-functions}
\end{table}

\section{Spatial Functions}
\label{sec:relative-markers}

To provide fine control over horizontal positioning of nodes, as set of utility functions is provided that models specific spatial relations regarding (relative) positioning, overlap or inclusion of a pair of nodes.

\begin{table}[!htb]\centering
\begin{tabular}{|p{0.20\textwidth}|p{0.74\textwidth}|}
	\hline 
	\textbf{Label} &  \textbf{Matching Condition} \\ 
	\hline 
	\hline  
	isLeftOf  & Node $n_1$ located completely outside and to the left of $n_2$ ($n_{1}.right < n_{2}.left$). \\  
	\hline  
	isRightOf  & Node $n_1$ located completely outside and to the right of $n_2$ ($n_{1}.left > n_{2}.right$). \\ 
	\hline  
	overlaps  & Nodes $n_1$ and $n_2$ overlap in some way ($n_{1}.left \le n_{2}.right \land n_{2}.left \le n_{1}.right$). \\ 
	\hline  
	overlapsNot  & Nodes $n_1$ and $n_2$ do not overlap ($n_{1}.left > n_{2}.right \lor n_{2}.left > n_{1}.right$). This function is a negation of \query{overlaps} that mainly exists as as syntactic sugar. \\  
	\hline 
	overlapsLeft  & Node $n_1$ overlaps $n_2$ on the left side ($n_{1}.left \le n_{2}.left \land n_{1}.right \ge n_{2}.left$). \\ 
	\hline 
	overlapsRight  & Node $n_1$ overlaps $n_2$ on the right side ($n_{1}.right \ge n_{2}.right \land n_{1}.left \le n_{2}.right$). \\ %TODO a word about surrounding with full overlap?
	\hline 
	surrounds  & Node $n_1$ fully surrounds $n_2$, i.e. it overlaps $n_2$ on both sides ($n_{1}.left \le n_{2}.left \land n_{1}.right \ge n_{2}.right$). \\ 
	\hline 
	fits  & Node $n_1$ exactly fits $n_2$, i.e. its boundaries match on both sides ($n_{1}.left = n_{2}.left \land n_{1}.right = n_{2}.right$). \\ 
	\hline 
	alignsLeft  & Node $n_1$ and $n_2$ share the same left boundary ($n_{1}.left = n_{2}.left$). \\ 
	\hline 
	alignsRight  & Node $n_1$ and $n_2$ share the same right boundary ($n_{1}.right = n_{2}.right$). \\ 
	\hline 
\end{tabular}
\caption[Spatial functions]{Spatial functions to model relative positioning between two nodes. All functions listed take exactly two node arguments, $n_1$ and $n_2$. For the matching condition column, $n.left$ stands for the begin index (the left boundary of the span covered by $n$ when projected onto the common foundation layer) and $n.right$ for the end index with $n.left \leq n.right$.}
\label{tab:spatial-functions}
\end{table}

\section{Tree Functions}
\label{sec:tree-functions}

\begin{table}[!htb]\centering
	\begin{tabular}{|p{0.17\textwidth}|p{0.14\textwidth}|p{0.60\textwidth}|}
		\hline 
		\textbf{Label} & \textbf{Arguments} & \textbf{Result} \\ 
		\hline 
		\hline  
		ancestor & node[] & Returns the first common ancestor of the given nodes. \\ 
		\hline  
		parentAt & node, int & Returns the $arg_2$-th parent of $arg_1$. The immediate parent of $arg_1$ is reached with $arg_2 = 1$, its grandparent with $arg_2 = 2$ and so on \dots Note that a node's immediate parent can (in the presence of a single unambiguous structure) be reached with the \query{parent} shortcut field. \\ 
		\hline 
	\end{tabular}
	\caption[Tree functions]{Utility functions for advanced tree matching. Primarily these functions are intended to complement the top-down tree matching strategy employed by the \ac{icqp} with bottom-up evaluation and navigation options.}
	\label{tab:tree-functions}
\end{table}

The nested style of defining tree queries in \ac{iql} in top-down manner and the associated matcher in the \ac{icqp} also producing top-down automata for evaluation cause some obvious shortcomings:
For problems in bottom-up style, for instance ``Find the first common ancestor of adjacent phrases x and y'' it can be more intuitive (and usually more efficient wrt evaluation) to define the query bottom-up.
Using the tree functions listed in \cref{tab:tree-functions} a simple query for this question could look like the following: 
\begin{Verbatim}[samepage=true]
FIND ADJACENT [$x:][$y:] HAVING ancestor($x,$y) AS $a}
\end{Verbatim}
This will first try to find two adjacent instances for \member{x} and \member{y} from the set of nodes in the target tree and then use the \query{ancestor(\$x,\$y)} method to fetch their first common ancestor node and assign it to \member{a} for further use.
The same can be achieved in a top-down fashion with a slightly more verbose query:
\begin{Verbatim}[samepage=true]
FIND [$a: childCount>=2
    [$x: isAnyGeneration,] 
    [$y: isAnyGeneration,]]
HAVING isAdjacent($x, $y)
\end{Verbatim}
%TODO actuall the top-down one is not guaranteed to produce the same result
Besides the differences in appearance those two approaches also differ greatly in their respective evaluation complexity.
While the bottom-up query can be efficiently solved in $\mathcal{O}(n+h)$ time for trees with $n$ nodes and height $h$ \footnote{Construction of a reverse lookup between indices and the nodes beginning/ending there and subsequent production of adjacent pairs for \member{x} and \member{y} requires $\mathcal{O}(n)$ time. Without a dedicated utility data structure, determining the first common ancestor of \member{x} and \member{y} is linear in the maximum depth of the two nodes.}, the top-down query results in a vastly more expensive search.
Since node \member{a} does not provide any strong filter mechanism besides needing at least 2 child nodes, the matcher will have to move the search tree through the target tree and repeatedly check any possible combination of descendant nodes matching \member{x} and \member{y} to be adjacent.

\section{Graph Functions}
\label{sec:graph-functions}

There be dragons\dots

(Content of the this section will be added as \ac{iql} evolves)
%TODO once tree evaluation is fully implemented, start the graph part



\begin{appendices}
\chapter{Extended Grammar Diagrams}


\begin{samepage}
\begin{gram*}
	\label{gram:expression}
	\begin{rrdiag*}{expression}
		\sst
		`NULL' \\
		`TRUE' \\
		`FALSE' \\
		<floatingPointLiteral> \\
		<integerLiteral> \\
		<stringLiteral> \\
		\sst \\ <type> `[]' \est `{' \sst \\ \srp <expression> \\ `,'\erp \est `}' \\
		\sst \\ <identifier> `::' \\ `@' \\ `\$' \est <identifier> \\
		<expression> `.' <identifier> \\ %path
		<expression> `(' \srp <expression> \\ `,' \erp `)' \\ %method invocation
		<expression> `[' \srp <index> \\ `,' \erp `]' \\ %list access
		<expression> `{' \srp <expression> \\  `,' \erp `}' \\ %annotation access
		`(' <type> `)' <expression> \\ %cast
		`(' <expression> `)' \\ %wrapping
		\sst `NOT' \\ `!' \\ `\textminus' \\ `\texttildelow' \est <expression> \\ %unary op
		<expression> \sst 
		\tok{`*' | `/' | `\%' } \\ 
		\tok{`+' | `\textminus'} \\ 
		\tok{`\verb|<<|' | `\verb|>>|' | `|' | `\&' | `\textasciicircum'} \\ 
		\tok{`\textless' | `\textless=' | `\textgreater' | `\textgreater='} \\ 
		\tok{`=\texttildelow' | `!\texttildelow' | `=\#' | `!\#'} \\ 
		\tok{`==' | `!='} \\ 
		\tok{`AND' | `\&\&' | `OR' | `||'} 
		\est <expression> \\ %binary op
		<expression> `AS' (<member> | <variable>) \\ %assignment op for later
		<expression> \sst \\ `ALL' \\ `*' \est \sst \\ `NOT' \\ `!' \est `IN' <expression> \\ %set predicate
		<expression> `?' <expression> `:' <expression> \\ %ternary op
		<loopExpression> % loop
		\est
	\end{rrdiag*}
\end{gram*}
\end{samepage}

\end{appendices}
\end{document}