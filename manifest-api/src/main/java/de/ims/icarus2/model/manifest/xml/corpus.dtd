<?xml version="1.0" encoding="UTF-8" ?>

<!--
	Element with mandatory identifier and optional
	name and description. The 'resources' parameter
	can be used to link to a set of localization
	files that will be used to interpret the declared
	name and description as localization keys.
-->

<!--
<!ENTITY % identity
		"id     CDATA #IMPLIED
		name      CDATA #IMPLIED
		description      CDATA #IMPLIED
		resources      CDATA #IMPLIED
		icon      CDATA #IMPLIED"
>
-->

<!--
	Element with optional name and description
-->

<!--
<!ENTITY % descriptor
		"name      		CDATA #IMPLIED
		description      CDATA #IMPLIED"
>
-->

<!-- 
    Type definition for some value. 
	Default type is always "string".
-->

<!ENTITY % typed "type 		(unknown | custom | extension | string | boolean | integer | double)">

<!-- 
    Type definition for container objects.
-->

<!ENTITY % container-type "container-type 		(singleton | set | list | span)">

<!-- 
    Type definition for structure objects.
-->

<!ENTITY % structure-type "structure-type 		(set | chain | tree | graph | directed-graph)">

<!-- 
    Type definition for locations.
-->

<!ENTITY % location-type "location-type 		(file | network | database)">

<!-- 
    Boolean expression that supports more "human readable" values 
-->

<!ENTITY % boolean "(yes | no | true | false)">

<!-- 
    Element with nested declaration of supported
	options and optional predefined properties.
-->

<!ENTITY % manifest "options?,  property*, implementation?">

<!-- 
    Lists possible nested layers
-->

<!ENTITY % layers "(markable-layer | structure-layer | annotation-layer)*">

<!-- 
    Extension of the manifest macro with oprional nested prerequisites
-->

<!ENTITY % layer "%manifest;, prerequisites?">

<!-- 
    Attribute to allow inheritence for manifest declarations 
	via template references.
	Note that the exact point in time, the reference is
	resolved at, is implementation specific. Therefore
	the parsing enginge will not check the template identifier
	while parsing! 
-->

<!ENTITY % template "template-id   	CDATA #IMPLIED">

<!-- 
    Basic attributes for layer manifests that define whether or not
	a layer is searchable and can be indexed.
-->

<!ENTITY % layeratts 
	"%template;
	search %boolean; #IMPLIED
	index %boolean; #IMPLIED
	base-layer CDATA #IMPLIED
	base-context CDATA #IMPLIED
	layer-type CDATA #IMPLIED"
>

<!--
	Templates section
-->

<!ELEMENT templates (corpus|context|annotation-layer|markable-layer|structure-layer|container|structure|annotation|options|content-reader|content-writer|path-resolver|values)*>

<!--
	Model
-->

<!ELEMENT corpora (corpus+)>

<!--
	Corpus manifest
-->

<!ELEMENT corpus (%manifest;, default-context, context*)>
<!ATTLIST corpus
		%identity;
		editable	%boolean;	"false"	
>

<!--
	Context manifest
-->

<!ELEMENT context (documentation?, %manifest;, location?, context-reader?, context-writer?, %layers;)>
<!ATTLIST context
		%identity;
		%template;
		independent	%boolean; "true"
>

<!ELEMENT documentation (#PCDATA)>

<!ELEMENT default-context (documentation?, %manifest;, location?, context-reader?, context-writer?, %layers;)>
<!ATTLIST default-context
		%identity;
		%template;
>

<!ELEMENT context-reader (implementation?)>
<!ATTLIST context-reader 
		id        	CDATA #IMPLIED
		%template;
		format		CDATA	#IMPLIED
>

<!ELEMENT context-writer (implementation?)>
<!ATTLIST context-writer 
		id        	CDATA #IMPLIED
		%template;
		format		CDATA	#IMPLIED
>

<!--
	Layer that holds information about annotations
-->

<!ELEMENT annotation-layer (%layer;, annotation*)>
<!ATTLIST annotation-layer
		%identity;
		%layeratts;
		deep-annotation %boolean; #IMPLIED
		unknown-keys %boolean; #IMPLIED
>

<!--
	Layer that holds information about markables
-->

<!ELEMENT markable-layer (%layer;, container*)>
<!ATTLIST markable-layer
		%identity;
		%layeratts;
>

<!--
	Layer that holds information about structures
-->

<!ELEMENT structure-layer (%layer;, container?, structure*)>
<!ATTLIST structure-layer
		%identity;
		%layeratts;
		boundary-layer		CDATA #IMPLIED
		boundary-context		CDATA #IMPLIED
>

<!--
	Container manifest
-->

<!ELEMENT container (%manifest;)>
<!ATTLIST container
		%identity;
		%template;	
		%container-type; #IMPLIED
>

<!--
	Structure manifest
-->

<!ELEMENT structure (%manifest;)>
<!ATTLIST structure
		%identity;
		%template;	
		%container-type; #IMPLIED
		%structure-type; #IMPLIED
>

<!--
	Location manifest
-->

<!ELEMENT location (path?, path-resolver?)>
<!ATTLIST location
		%location-type; #REQUIRED
		path		CDATA #IMPLIED
>

<!--
	Path declaration
-->

<!ELEMENT path (#PCDATA)>

<!--
	Path-resolver declaration
-->

<!ELEMENT path-resolver (%manifest;)>
<!ATTLIST path-resolver
		%identity;
		%template;
>

<!--
	Specifies possible values for an annotation. The 'key' attribute is
	taken as the key the annotation is associated with. If no key is
	defined than the annotation is taken as the default annotation of the
	surrounding annotation layer. Note that the behavior of the default implementation
	is undefined if more than one annotation is declared as default annotation.
	Therefore at most one annotation declaration should ommit the id attribute!	
-->

<!ELEMENT annotation (%manifest;, alias*, range?, values?)>
<!ATTLIST annotation
		key		CDATA #IMPLIED
		%template;
		%descriptor; 
		default %boolean; "false" 
		%typed; "string"
>

<!-- 
	An alternate identifier for an annotation.
	The name can either be set via attribute or 
	as nested text.
-->

<!ELEMENT alias (#PCDATA)>
<!ATTLIST alias
		name	CDATA #IMPLIED
>

<!-- 
	List of prerequisites a layer requires to work properly
-->

<!ELEMENT prerequisites (prerequisite+)>

<!-- 
	Describes a required type of layer
-->

<!ELEMENT prerequisite EMPTY>
<!ATTLIST prerequisite
		type-id CDATA #IMPLIED
		layer-id CDATA #IMPLIED
		context-id CDATA #IMPLIED
		alias CDATA #REQUIRED
>

<!-- 
	A single named property with its value either in attribute
	form or as nested text.	Note that for the type of a property
	to be resolved a vali options manifest declaration is required!	
-->

<!ELEMENT property (#PCDATA)>
<!ATTLIST property
		name	CDATA #REQUIRED
		%typed; "string"
		value	CDATA #IMPLIED
>

<!-- 
	Defines descriptors for a set of available options.
	The manifest can either define all options itself or
	refer to some previously registered template.
-->

<!ELEMENT options (option)*>
<!ATTLIST options 
		id        	CDATA #IMPLIED
		%template;
>

<!--
	Describes a single option in an options-manifest.
	The option can have a default value assigned to it
	and might either contain a predefined set of fixed
	values or a range that bounds supported values.
-->

<!ELEMENT option (default-value?, range?, values?)>
<!ATTLIST option 
		%typed; "string"
		%identity;
		published %boolean; "true"
		multi-value %boolean; "true"
>

<!--
	Denotes a range of possible values bound by a lower and
	upper limit.
-->

<!ELEMENT range (min, max)>
<!ATTLIST range 
		include-min	%boolean; #IMPLIED
		include-max	%boolean; #IMPLIED
>

<!ELEMENT min (#PCDATA|eval)* >
<!ELEMENT max (#PCDATA|eval)* >

<!--
    Wraps a fixed set of possible values which are converted into
	a de.ims.icarus.language.model.manifest.ValueIterator object when
	read.
	Note that values can be templated as well!
	In addition one can define an extension-point and the values for
	this set are the extensions connected to that point.
-->

<!ELEMENT values (value)* >
<!ATTLIST values 
		id        	CDATA #IMPLIED
		%typed; "string"
		extension-point    	CDATA #IMPLIED
		%template;
>

<!--
	A single value in serialized (textual) form that denotes a default value
	for an option. Type of the value is resolved by the surrounding 'option'
	element.
-->	
<!ELEMENT default-value (#PCDATA|eval)* >

<!--
	A single value in serialized (textual) form with optional
	name and description attributes
-->	
<!ELEMENT value (#PCDATA|eval)* >
<!ATTLIST value %descriptor; >

<!--
	Multiple ways of describing the source of an implementation
-->

<!ELEMENT implementation EMPTY>
<!ATTLIST implementation
		class			CDATA #IMPLIED
		plugin-id		CDATA #IMPLIED
		extension-id	CDATA #IMPLIED
>

<!--
	Expression that will be evaluated at runtime
-->

<!ELEMENT eval (#PCDATA)>

